<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asii</title>
  <subtitle>路漫漫其修远兮 吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luyaoming.com/"/>
  <updated>2021-06-25T05:39:34.804Z</updated>
  <id>http://luyaoming.com/</id>
  
  <author>
    <name>Asii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wsl2下下载与编译AOSP</title>
    <link href="http://luyaoming.com/2021/06/23/wsl2%E4%B8%8B%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91AOSP/"/>
    <id>http://luyaoming.com/2021/06/23/wsl2下下载与编译AOSP/</id>
    <published>2021-06-23T07:38:51.000Z</published>
    <updated>2021-06-25T05:39:34.804Z</updated>
    
    <content type="html"><![CDATA[<p>总结在wsl2下下载与安装aosp遇到的坑和解决方案</p>
<a id="more"></a>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载aosp-latest.tar 压缩包</p>
<p>使用官方的repo下载太慢 直接迅雷下载 清华的镜像 下了两个晚上 压缩包119g 解压又100多g repo sync之后又400多g 所以配备硬盘500g或以上再下载吧</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a></p>
<p>下载完开始解压aosp-latest.tar  解压需要等一段时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf  aosp-latest.tar</span><br></pre></td></tr></table></figure>
<p>解压完可查看解压是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? <span class="comment">#输出0代表解压成功</span></span><br></pre></td></tr></table></figure>
<p>取消根目录aosp文件只读属性  直接右键文件夹取消即可</p>
<p>设置根目录aosp文件及子文件大小写敏感 windows下使用cmd终端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fsutil.exe file SetCaseSensitiveInfo D:\path\aosp enable</span><br></pre></td></tr></table></figure>
<p>设置根目录“完全控制”</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/image-20210623160618008.png" alt="image-20210623160618008"></p>
<p>下载repo工具  可能需要搭一下梯子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#先配置下载路径 并加入环境变量中 如果已具备~/bin 可忽略此步骤</span><br><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line"></span><br><span class="line">#下载repo</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>
<p>下载后测试repo可用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo --help</span><br></pre></td></tr></table></figure>
<p>下载android源码目录树 </p>
<p>最简单的使用repo sync命令下载 但是由于网络原因可能会执行失败 可使用以下脚本循环下载直至成功</p>
<p>aosp根目录下新建reposync.sh文件</p>
<p>加入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">repo sync -j4 </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ $? = 1 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"======sync failed ,re-sync again======"</span></span><br><span class="line">    sleep 3</span><br><span class="line">    repo sync -j4</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"finish download!!!"</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>赋能执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x reposync.sh</span><br></pre></td></tr></table></figure>
<p>进入.repo目录执行此脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo</span><br><span class="line">../reposync.sh</span><br></pre></td></tr></table></figure>
<p>见到下载进度后 可以先去沏杯咖啡 慢慢等候 这里展示下载成功的进度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  .repo repo sync</span><br><span class="line">Fetching: 100% (1023/1023), <span class="keyword">done</span> <span class="keyword">in</span> 1h11m8.434s</span><br><span class="line">Garbage collecting: 100% (1023/1023), <span class="keyword">done</span> <span class="keyword">in</span> 13.784s</span><br><span class="line">Checking out: 100% (1023/1023), <span class="keyword">done</span> <span class="keyword">in</span> 10m24.574s</span><br><span class="line">repo sync has finished successfully.</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在aosp根目录下执行 source build/envsetup.sh</p>
<p>然后lunch 会得到一个菜单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  aosp <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">➜  aosp lunch</span><br><span class="line"></span><br><span class="line">You<span class="string">'re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_blueline-userdebug</span><br><span class="line">     4. aosp_blueline_car-userdebug</span><br><span class="line">     5. aosp_bonito-userdebug</span><br><span class="line">     6. aosp_bonito_car-userdebug</span><br><span class="line">     7. aosp_bramble-userdebug</span><br><span class="line">     8. aosp_car_arm-userdebug</span><br><span class="line">     9. aosp_car_arm64-userdebug</span><br><span class="line">     10. aosp_car_x86-userdebug</span><br><span class="line">     11. aosp_car_x86_64-userdebug</span><br><span class="line">     12. aosp_cf_arm64_auto-userdebug</span><br><span class="line">     13. aosp_cf_arm64_phone-userdebug</span><br><span class="line">     14. aosp_cf_x86_64_pc-userdebug</span><br><span class="line">     15. aosp_cf_x86_64_phone-userdebug</span><br><span class="line">     16. aosp_cf_x86_auto-userdebug</span><br><span class="line">     17. aosp_cf_x86_phone-userdebug</span><br><span class="line">     18. aosp_cf_x86_tv-userdebug</span><br><span class="line">     19. aosp_coral-userdebug</span><br><span class="line">     20. aosp_coral_car-userdebug</span><br><span class="line">     21. aosp_crosshatch-userdebug</span><br><span class="line">     22. aosp_crosshatch_car-userdebug</span><br><span class="line">     23. aosp_flame-userdebug</span><br><span class="line">     24. aosp_flame_car-userdebug</span><br><span class="line">     25. aosp_redfin-userdebug</span><br><span class="line">     26. aosp_sargo-userdebug</span><br><span class="line">     27. aosp_sunfish-userdebug</span><br><span class="line">     28. aosp_trout_arm64-userdebug</span><br><span class="line">     29. aosp_trout_x86-userdebug</span><br><span class="line">     30. aosp_x86-eng</span><br><span class="line">     31. aosp_x86_64-eng</span><br><span class="line">     32. arm_krait-eng</span><br><span class="line">     33. arm_v7_v8-eng</span><br><span class="line">     34. armv8-eng</span><br><span class="line">     35. armv8_cortex_a55-eng</span><br><span class="line">     36. armv8_kryo385-eng</span><br><span class="line">     37. beagle_x15-userdebug</span><br><span class="line">     38. beagle_x15_auto-userdebug</span><br><span class="line">     39. car_x86_64-userdebug</span><br><span class="line">     40. db845c-userdebug</span><br><span class="line">     41. fuchsia_arm64-eng</span><br><span class="line">     42. fuchsia_x86_64-eng</span><br><span class="line">     43. hikey-userdebug</span><br><span class="line">     44. hikey64_only-userdebug</span><br><span class="line">     45. hikey960-userdebug</span><br><span class="line">     46. hikey960_tv-userdebug</span><br><span class="line">     47. hikey_tv-userdebug</span><br><span class="line">     48. pixel3_mainline-userdebug</span><br><span class="line">     49. poplar-eng</span><br><span class="line">     50. poplar-user</span><br><span class="line">     51. poplar-userdebug</span><br><span class="line">     52. qemu_trusty_arm64-userdebug</span><br><span class="line">     53. silvermont-eng</span><br><span class="line">     54. uml-userdebug</span><br><span class="line">     55. yukawa-userdebug</span><br><span class="line">     56. yukawa_sei510-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng] 31</span></span><br></pre></td></tr></table></figure>
<p>我这里填入31 选择 31. aosp_x86_64-eng </p>
<p>开始编译 make -j8</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h4 id="1-错误："><a href="#1-错误：" class="headerlink" title="1.错误："></a>1.错误：</h4><p>prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory<br>10:04:12 ninja failed with: exit status 1</p>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>缺省库 先安装一批库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aosp sudo apt-get install git-core gnupg flex bison gperf build-essential</span><br><span class="line">  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386</span><br><span class="line">  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache</span><br><span class="line">  libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure>
<p>如果出现某些库没找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh: <span class="built_in">command</span> not found: lib32ncurses5-dev</span><br><span class="line">zsh: <span class="built_in">command</span> not found: libgl1-mesa-dev</span><br></pre></td></tr></table></figure>
<p>先执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<p>再次安装即可成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libncurses5</span><br><span class="line">sudo apt install libgl1-mesa-dev</span><br></pre></td></tr></table></figure>
<h4 id="2-错误"><a href="#2-错误" class="headerlink" title="2.错误"></a>2.错误</h4><p><img src="http://quqnn25zc.bkt.gdipper.com/img/编译错误1.jpg" alt></p>
<p>编译进度89%遇到这个错误 心塞！！ 没有明显的提示信息 于是又开始重新编译</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/image-20210624211950416.png" alt="image-20210624211950416"></p>
<p>再次进入后 发现有提示12.4GB ram不够 要16g 略过不管他 查看系统进程占有 发现vmmem这个进程消耗内存和cpu奇高 上面的错误估计来源于内存不足 网上有资料提示是wsl2的虚拟内存最大可占用默认80% 可通过.wslconfig配置修改限制 但是限制会影响我们的系统编译效率 所以我这里没有设置限制</p>
<h4 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h4><p>我笔记本电脑默认设置的性能模式是均衡模式 效率太低了 毕竟是8个线程并发跑 改成野兽模式（游戏模式）提供笔记本性能 提供风扇转速和功耗 make -j8 改成make -j4 稳一点 让内存不要溢出了  最后编译成功 耗时1.5小时 比之前低速模式编译8.5小时快6倍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Missing class org.jetbrains.annotations.NotNull (referenced from: com.android.settingslib.fuelgauge.Estimate<span class="variable">$Companion</span> com.android.settingslib.fuelgauge.Estimate.Companion and 36 other contexts)</span><br><span class="line">Missing class org.jetbrains.annotations.Nullable (referenced from: com.android.settingslib.fuelgauge.Estimate com.android.settingslib.fuelgauge.Estimate<span class="variable">$Companion</span>.getCachedEstimateIfAvailable(android.content.Context) and 3 other contexts)</span><br><span class="line">[100% 3917/3917] Target vbmeta image: out/target/product/generic_x86_64/vbmeta.img</span><br><span class="line"></span><br><span class="line"><span class="comment">#### build completed successfully (01:32:43 (hh:mm:ss)) ####</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结在wsl2下下载与安装aosp遇到的坑和解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="aosp" scheme="http://luyaoming.com/tags/aosp/"/>
    
  </entry>
  
  <entry>
    <title>wsl2下编译vsomeip的HelloWorld</title>
    <link href="http://luyaoming.com/2021/06/22/wsl2%E4%B8%8B%E7%BC%96%E8%AF%91vsomeip%E7%9A%84HelloWorld/"/>
    <id>http://luyaoming.com/2021/06/22/wsl2下编译vsomeip的HelloWorld/</id>
    <published>2021-06-22T09:41:25.000Z</published>
    <updated>2021-06-22T10:07:05.995Z</updated>
    
    <content type="html"><![CDATA[<p>总结wsl2下编译vsomeip遇到的问题和解决方案</p>
<a id="more"></a>
<h2 id="问题：Detecting-CXX-compiler-ABI-info-failed"><a href="#问题：Detecting-CXX-compiler-ABI-info-failed" class="headerlink" title="问题：Detecting CXX compiler ABI info failed"></a>问题：Detecting CXX compiler ABI info failed</h2><p>解决：</p>
<p>已经排除cmake和依赖包缺失引起的问题</p>
<p>查看/etc/wsl.conf是否存在 ，若不存在，在/etc/目录下创建wsl.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> wsl   #启动终端</span><br><span class="line">$ cd /etc/ #进入etc目录</span><br><span class="line">$ touch wsl.conf #创建wsl.conf文件</span><br><span class="line">$ vim wsl.conf   # 打开wsl.conf</span><br></pre></td></tr></table></figure>
<p>将代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[automount]</span><br><span class="line">enabled = true</span><br><span class="line">options = &quot;metadata&quot;</span><br></pre></td></tr></table></figure>
<p>写入wsl.conf保存后重新启动新终端</p>
<h2 id="问题：boost安装不成功"><a href="#问题：boost安装不成功" class="headerlink" title="问题：boost安装不成功"></a>问题：boost安装不成功</h2><p>解决：</p>
<p>最新支持1.72版本不能再高了</p>
<p>先卸载<br>dpkg -S /usr/include/boost/version.hpp<br>sudo apt-get autoremove libboost1.71-dev<br>sudo apt-get autoremove libboost-all-dev<br>直接去官网下载<br><a href="https://boostorg.jfrog.io/artifactory/main/release/1.72.0/source/" target="_blank" rel="external">https://boostorg.jfrog.io/artifactory/main/release/1.72.0/source/</a><br>这里选择boost_1_72_0.tar.gz</p>
<h2 id="问题：Could-NOT-find-PkgConfig-missing-PKG-CONFIG-EXECUTABLE"><a href="#问题：Could-NOT-find-PkgConfig-missing-PKG-CONFIG-EXECUTABLE" class="headerlink" title="问题：Could NOT find PkgConfig (missing: PKG_CONFIG_EXECUTABLE)"></a>问题：Could NOT find PkgConfig (missing: PKG_CONFIG_EXECUTABLE)</h2><p>解决：</p>
<p>sudo apt-get install pkg-config</p>
<h2 id="问题：No-package-‘automotive-dlt’-found"><a href="#问题：No-package-‘automotive-dlt’-found" class="headerlink" title="问题：No package ‘automotive-dlt’ found"></a>问题：No package ‘automotive-dlt’ found</h2><p>未找到解决方案 最后编译通过 该问题不影响编译</p>
<h2 id="问题：-GTEST-ROOT-is-not-defined-For-building-the-tests-the-variable"><a href="#问题：-GTEST-ROOT-is-not-defined-For-building-the-tests-the-variable" class="headerlink" title="问题： GTEST_ROOT is not defined. For building the tests the variable"></a>问题： GTEST_ROOT is not defined. For building the tests the variable</h2><p>解决：</p>
<p>上网下载googletest cmake时加入GTEST参数</p>
<p>cmake -DGTEST_ROOT=/mnt/d/libs4wsl/googletest  -Wno-dev ..</p>
<h2 id="问题：find-package-called-with-incorrect-number-of-arguments"><a href="#问题：find-package-called-with-incorrect-number-of-arguments" class="headerlink" title="问题：find_package called with incorrect number of arguments"></a>问题：find_package called with incorrect number of arguments</h2><p>解决：</p>
<p>sudo ldconfig</p>
<p><a href="https://github.com/GENIVI/vsomeip/issues/235" target="_blank" rel="external">https://github.com/GENIVI/vsomeip/issues/235</a></p>
<h2 id="问题：-usr-bin-ld-warning-libboost-thread-so-1-72-0-needed-by-usr-local-lib-libvsomeip3-so-3-1-7-not-found-try-using-rpath-or-rpath-link"><a href="#问题：-usr-bin-ld-warning-libboost-thread-so-1-72-0-needed-by-usr-local-lib-libvsomeip3-so-3-1-7-not-found-try-using-rpath-or-rpath-link" class="headerlink" title="问题：/usr/bin/ld: warning: libboost_thread.so.1.72.0, needed by //usr/local/lib/libvsomeip3.so.3.1.7, not found (try using -rpath or -rpath-link)"></a>问题：/usr/bin/ld: warning: libboost_thread.so.1.72.0, needed by //usr/local/lib/libvsomeip3.so.3.1.7, not found (try using -rpath or -rpath-link)</h2><p>解决：</p>
<p>找不到libboost_thread.so.1.72.0 是由于之前make intall 时指定了安装路径在/usr/local/boost172 （这么做的目的是为了方便删除不合适的boost版本 默认安装在/usr/local/bin 路径下）所以需要在/etc/ld.so.conf 文件中配置libboost_thread.so.1.72.0的路径<br>使用 echo “/usr/local/boost172/lib” &gt;&gt; /etc/ld.so.conf  插入路径即可 </p>
<p>为什么安装在自定义目录boost172有问题？ 是因为安装了新的动态链接库 没有运行ldconfig把缓存刷入到配置文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结wsl2下编译vsomeip遇到的问题和解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="someip" scheme="http://luyaoming.com/tags/someip/"/>
    
  </entry>
  
  <entry>
    <title>使用dos命令总结</title>
    <link href="http://luyaoming.com/2021/06/22/%E4%BD%BF%E7%94%A8dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://luyaoming.com/2021/06/22/使用dos命令总结/</id>
    <published>2021-06-22T07:46:16.000Z</published>
    <updated>2021-06-22T09:20:10.290Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结下dos的常用命令</p>
<a id="more"></a>
<h2 id="dos启动"><a href="#dos启动" class="headerlink" title="dos启动"></a>dos启动</h2><p>DOS启动也叫DOS系统引导，就是从系统引导盘上读取DOS并把它们装入内存的过程。系吮可以从软盘上引导也可以从硬盘上引导。计算机开机以后，要进行加电自检，检查内存、驱动器、打印机等内外部设备，然后就进行DOS系统引导。计算机首先检查驱动器A中是否有磁盘，如果驱动器A中有软盘插人，并且小门关闭，计机便试图从该软盘上引导装载DOS。如果驱动器A中没有磁盘，或是小门没有关闭·计机便试图从第一个硬盘上引导DOS。引导以〕S要由DOS系统盘来完成。上面一节已谈到了DOS主要由四个部分组成。DOS系统盘必须含有如下三个文件：IBMBIO．COM(或IO.SYS)文件，<a href="http://ibmdos.com/" target="_blank" rel="external">IBMDOS.COM</a>〈或MSDOS.SYS)和<a href="http://command.com/" target="_blank" rel="external">COMMAND.COM</a>,其中前两个文件是隐含文件，必须放在磁盘的根目录中。将一张软盘做成系统引导盘时简单地将这三个文件拷贝到磁盘上是不行的。</p>
<h2 id="分类总结"><a href="#分类总结" class="headerlink" title="分类总结"></a>分类总结</h2><h3 id="批处理符号简介"><a href="#批处理符号简介" class="headerlink" title="批处理符号简介"></a>批处理符号简介</h3><p>回显屏蔽 @</p>
<p>重定向1 &gt;与&gt;&gt;</p>
<p>重定向2 &lt;</p>
<p>管道符号 |</p>
<p>转义符 ^</p>
<p>逻辑命令符包括：&amp;、&amp;&amp;、||</p>
<h3 id="文件夹管理"><a href="#文件夹管理" class="headerlink" title="文件夹管理"></a>文件夹管理</h3><p>cd 显示当前目录名或改变当前目录。</p>
<p>md 创建目录。</p>
<p>rd 删除一个目录。</p>
<p>dir 显示目录中的文件和子目录列表。</p>
<p>tree 以图形显示驱动器或路径的文件夹结构。</p>
<p>path 为可执行文件显示或设置一个搜索路径。</p>
<p>xcopy 复制文件和目录树。</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>type 显示文本文件的内容。</p>
<p>copy 将一份或多份文件复制到另一个位置。</p>
<p>del 删除一个或数个文件。</p>
<p>move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有)</p>
<p>ren 重命名文件。</p>
<p>replace 替换文件。</p>
<p>attrib 显示或更改文件属性。设置文件只读 attrib +r filename  撤销只读 attrib -r filename 另外还有其他属性h隐藏 s系统 a备份</p>
<p>find 搜索字符串。</p>
<p>fc 比较两个文件或两个文件集并显示它们之间的不同</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><p>ping 进行网络连接测试、名称解析</p>
<p>ftp 文件传输net 网络命令集及用户管理</p>
<p>telnet 远程登陆</p>
<p>ipconfig显示、修改TCP/IP设置</p>
<p>msg 给用户发送消息</p>
<p>arp 显示、修改局域网的IP地址-物理地址映射列表</p>
<h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>at 安排在特定日期和时间运行命令和程序</p>
<p>shutdown立即或定时关机或重启</p>
<p>tskill 结束进程</p>
<p>taskkill结束进程(比tskill高级，但WinXPHome版中无该命令)</p>
<p>tasklist显示进程列表(Windows XP Home Edition中没有)</p>
<p>sc 系统服务设置与控制</p>
<p>reg 注册表控制台工具</p>
<p>powercfg控制系统上的电源设置</p>
<h2 id="批处理常用命令总结"><a href="#批处理常用命令总结" class="headerlink" title="批处理常用命令总结"></a>批处理常用命令总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 <span class="built_in">echo</span> 和 @</span><br><span class="line">回显命令</span><br><span class="line">@  <span class="comment">#关闭单行回显</span></span><br><span class="line"><span class="built_in">echo</span> off  <span class="comment">#从下一行开始关闭回显</span></span><br><span class="line">@<span class="built_in">echo</span> off  <span class="comment">#从本行开始关闭回显。一般批处理第一行都是这个</span></span><br><span class="line"><span class="built_in">echo</span> on <span class="comment">#从下一行开始打开回显</span></span><br><span class="line"><span class="built_in">echo</span> <span class="comment">#显示当前是 echo off 状态还是 echo on 状态</span></span><br><span class="line">echo. <span class="comment">#输出一个”回车换行”，空白行</span></span><br><span class="line"><span class="comment">#(同echo, echo; echo+ echo[ echo] echo/ echo)</span></span><br><span class="line"></span><br><span class="line">2 </span><br><span class="line">errorlevel</span><br><span class="line"><span class="built_in">echo</span> %errorlevel%</span><br><span class="line">每个命令运行结束，可以用这个命令行格式查看返回码</span><br><span class="line">默认值为0，一般命令执行出错会设 errorlevel 为1</span><br><span class="line">注意：检验errorlevel时  不是等于 而是大于或等于 </span><br><span class="line">例如 <span class="keyword">if</span> errorlevel 5 是判断errorlevel是否大于5 如果程序执行成功 一般返回0 </span><br><span class="line">如果不成功 判断是否大于等于1即可 <span class="keyword">if</span> errorlevel 1</span><br><span class="line"></span><br><span class="line">3 dir</span><br><span class="line">显示文件夹内容</span><br><span class="line">dir <span class="comment">#显示当前目录中的文件和子目录</span></span><br><span class="line">dir /a <span class="comment">#显示当前目录中的文件和子目录，包括隐藏文件和系统文件</span></span><br><span class="line">dir c: /a:d <span class="comment">#显示 C 盘当前目录中的目录</span></span><br><span class="line">dir c: /a:<span class="_">-d</span> <span class="comment">#显示 C 盘根目录中的文件</span></span><br><span class="line">dir c: /b/p <span class="comment">#/b只显示文件名，/p分页显示</span></span><br><span class="line">dir *.exe /s <span class="comment">#显示当前目录和子目录里所有的.exe文件</span></span><br><span class="line"></span><br><span class="line">4 <span class="built_in">cd</span></span><br><span class="line">切换目录</span><br><span class="line"><span class="built_in">cd</span> <span class="comment">#进入根目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="comment">#显示当前目录</span></span><br><span class="line"><span class="built_in">cd</span> /d d:sdk <span class="comment">#可以同时更改盘符和目录</span></span><br><span class="line"></span><br><span class="line">5 md</span><br><span class="line">创建目录</span><br><span class="line">md d:abc <span class="comment">#如果 d:a 不存在，将会自动创建中级目录</span></span><br><span class="line"><span class="comment">#如果命令扩展名被停用，则需要键入 mkdir abc</span></span><br><span class="line"></span><br><span class="line">6 rd</span><br><span class="line">删除目录</span><br><span class="line">rd abc <span class="comment">#删除当前目录里的 abc 子目录，要求为空目录</span></span><br><span class="line">rd /s/q d:temp <span class="comment">#删除 d:temp 文件夹及其子文件夹和文件，/q安静模式</span></span><br><span class="line"></span><br><span class="line">7 del</span><br><span class="line">删除文件</span><br><span class="line">del d:test.txt <span class="comment">#删除指定文件，不能是隐藏、系统、只读文件</span></span><br><span class="line">del /q/a/f d:temp*.*</span><br><span class="line">删除 d:temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录</span><br><span class="line">del /q/a/f/s d:temp*.*</span><br><span class="line">删除 d:temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录</span><br><span class="line"></span><br><span class="line">8 ren</span><br><span class="line">重命名命令</span><br><span class="line">ren d:temp tmp <span class="comment">#支持对文件夹的重命名</span></span><br><span class="line"></span><br><span class="line">9 cls</span><br><span class="line">清屏</span><br><span class="line">10 <span class="built_in">type</span></span><br><span class="line">显示文件内容</span><br><span class="line"><span class="built_in">type</span> c:boot.ini <span class="comment">#显示指定文件的内容，程序文件一般会显示乱码</span></span><br><span class="line"><span class="built_in">type</span> *.txt <span class="comment">#显示当前目录里所有.txt文件的内容</span></span><br><span class="line"></span><br><span class="line">11 copy</span><br><span class="line">拷贝文件</span><br><span class="line">copy c:test.txt d:test.bak</span><br><span class="line">复制 c:test.txt 文件到 d: ，并重命名为 test.bak</span><br><span class="line">copy con test.txt</span><br><span class="line">从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件</span><br><span class="line">con代表屏幕，prn代表打印机，nul代表空设备</span><br><span class="line">copy 1.txt + 2.txt 3.txt</span><br><span class="line">合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件</span><br><span class="line">如果不指定 3.txt ，则保存到 1.txt</span><br><span class="line">copy test.txt +</span><br><span class="line">复制文件到自己，实际上是修改了文件日期</span><br><span class="line"></span><br><span class="line">12 title</span><br><span class="line">设置cmd窗口的标题</span><br><span class="line">title 新标题 <span class="comment">#可以看到cmd窗口的标题栏变了</span></span><br><span class="line"></span><br><span class="line">13 ver</span><br><span class="line">显示系统版本</span><br><span class="line"></span><br><span class="line">14 label 和 vol</span><br><span class="line">设置卷标</span><br><span class="line">vol <span class="comment">#显示卷标</span></span><br><span class="line">label <span class="comment">#显示卷标，同时提示输入新卷标</span></span><br><span class="line">label c:system <span class="comment">#设置C盘的卷标为 system</span></span><br><span class="line"></span><br><span class="line">15 pause</span><br><span class="line">暂停命令</span><br><span class="line"></span><br><span class="line">16 rem 和 ::</span><br><span class="line">注释命令</span><br><span class="line">注释行不执行操作</span><br><span class="line"></span><br><span class="line">17 date 和 time</span><br><span class="line">日期和时间</span><br><span class="line">date <span class="comment">#显示当前日期，并提示输入新日期，按"回车"略过输入</span></span><br><span class="line">date/t <span class="comment">#只显示当前日期，不提示输入新日期</span></span><br><span class="line">time <span class="comment">#显示当前时间，并提示输入新时间，按"回车"略过输入</span></span><br><span class="line">time/t <span class="comment">#只显示当前时间，不提示输入新时间</span></span><br><span class="line"></span><br><span class="line">18 goto 和 :</span><br><span class="line">跳转命令</span><br><span class="line">:label <span class="comment">#行首为:表示该行是标签行，标签行不执行操作</span></span><br><span class="line">goto label <span class="comment">#跳转到指定的标签那一行</span></span><br><span class="line"></span><br><span class="line">19 find (外部命令)</span><br><span class="line">查找命令</span><br><span class="line">find <span class="string">"abc"</span> c:test.txt</span><br><span class="line">在 c:test.txt 文件里查找含 abc 字符串的行</span><br><span class="line">如果找不到，将设 errorlevel 返回码为1</span><br><span class="line">find /i “abc” c:test.txt</span><br><span class="line">查找含 abc 的行，忽略大小写</span><br><span class="line">find /c <span class="string">"abc"</span> c:test.txt</span><br><span class="line">显示含 abc 的行的行数</span><br><span class="line"></span><br><span class="line">20 more (外部命令)</span><br><span class="line">逐屏显示</span><br><span class="line">more c:test.txt <span class="comment">#逐屏显示 c:test.txt 的文件内容</span></span><br><span class="line"></span><br><span class="line">21 tree</span><br><span class="line">显示目录结构</span><br><span class="line">tree d: <span class="comment">#显示D盘的文件目录结构</span></span><br><span class="line"></span><br><span class="line">22 &amp;</span><br><span class="line">顺序执行多条命令，而不管命令是否执行成功</span><br><span class="line"></span><br><span class="line">23 &amp;&amp;</span><br><span class="line">顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</span><br><span class="line">find <span class="string">"ok"</span> c:test.txt &amp;&amp; <span class="built_in">echo</span> 成功</span><br><span class="line">如果找到了<span class="string">"ok"</span>字样，就显示<span class="string">"成功"</span>，找不到就不显示</span><br><span class="line"></span><br><span class="line">24 ||</span><br><span class="line">顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</span><br><span class="line">find <span class="string">"ok"</span> c:test.txt || <span class="built_in">echo</span> 不成功</span><br><span class="line">如果找不到<span class="string">"ok"</span>字样，就显示<span class="string">"不成功"</span>，找到了就不显示</span><br><span class="line"></span><br><span class="line">25 |</span><br><span class="line">管道命令</span><br><span class="line">dir *.* /s/a | find /c <span class="string">".exe"</span></span><br><span class="line">管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令</span><br><span class="line">该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数</span><br><span class="line"><span class="built_in">type</span> c:test.txt|more</span><br><span class="line">这个和 more c:test.txt 的效果是一样的</span><br><span class="line"></span><br><span class="line">26 &gt; 和 &gt;&gt;</span><br><span class="line">输出重定向命令</span><br><span class="line">&gt; 清除文件中原有的内容后再写入</span><br><span class="line">&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容</span><br><span class="line">主要将本来显示在屏幕上的内容输出到指定文件中</span><br><span class="line">指定文件如果不存在，则自动生成该文件</span><br><span class="line"><span class="built_in">type</span> c:test.txt &gt;prn</span><br><span class="line">屏幕上不显示文件内容，转向输出到打印机</span><br><span class="line"><span class="built_in">echo</span> hello world&gt;con</span><br><span class="line">在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的</span><br><span class="line">copy c:test.txt f: &gt;nul</span><br><span class="line">拷贝文件，并且不显示<span class="string">"文件复制成功"</span>的提示信息，但如果f盘不存在，还是会显示出错信息</span><br><span class="line">copy c:test.txt f: &gt;nul 2&gt;nul</span><br><span class="line">不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息</span><br><span class="line"><span class="built_in">echo</span> ^^W ^&gt; ^W&gt;c:test.txt</span><br><span class="line">生成的文件内容为 ^W &gt; W</span><br><span class="line">^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号</span><br><span class="line"></span><br><span class="line">27 &lt;</span><br><span class="line">从文件中获得输入信息，而不是从屏幕上</span><br><span class="line">一般用于 date time label 等需要等待输入的命令</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> 2005-05-01&gt;temp.txt</span><br><span class="line">date &lt;temp.txt</span><br><span class="line">del temp.txt</span><br><span class="line">这样就可以不等待输入直接修改当前日期</span><br><span class="line"></span><br><span class="line">28 %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*</span><br><span class="line">命令行传递给批处理的参数</span><br><span class="line">%0 批处理文件本身</span><br><span class="line">%1 第一个参数</span><br><span class="line">%9 第九个参数</span><br><span class="line">%* 从第一个参数开始的所有参数</span><br><span class="line">批参数(%n)的替代已被增强。您可以使用以下语法:</span><br><span class="line">%~1 - 删除引号(<span class="string">" )， 扩充 %1</span><br><span class="line">%~f1 - 将 %1 扩充到一个完全合格的路径名</span><br><span class="line">%~d1 - 仅将 %1 扩充到一个驱动器号</span><br><span class="line">%~p1 - 仅将 %1 扩充到一个路径</span><br><span class="line">%~n1 - 仅将 %1 扩充到一个文件名</span><br><span class="line">%~x1 - 仅将 %1 扩充到一个文件扩展名</span><br><span class="line">%~s1 - 扩充的路径指含有短名</span><br><span class="line">%~a1 - 将 %1 扩充到文件属性</span><br><span class="line">%~t1 - 将 %1 扩充到文件的日期/时间</span><br><span class="line">%~z1 - 将 %1 扩充到文件的大小</span><br><span class="line">%~<span class="variable">$PATH</span> : 1 - 查找列在 PATH 环境变量的目录，并将 %1</span><br><span class="line">扩充到找到的第一个完全合格的名称。如果环境</span><br><span class="line">变量名未被定义，或者没有找到文件，此组合键会</span><br><span class="line">扩充到空字符串</span><br><span class="line">可以组合修定符来取得多重结果:</span><br><span class="line">%~dp1 - 只将 %1 扩展到驱动器号和路径</span><br><span class="line">%~nx1 - 只将 %1 扩展到文件名和扩展名</span><br><span class="line">%~dp<span class="variable">$PATH</span>:1 - 在列在 PATH 环境变量中的目录里查找 %1，</span><br><span class="line">并扩展到找到的第一个文件的驱动器号和路径。</span><br><span class="line">%~ftza1 - 将 %1 扩展到类似 DIR 的输出行。</span><br><span class="line">可以参照 call/? 或 for/? 看出每个参数的含意</span><br><span class="line">echo load "</span>%%1<span class="string">" "</span>%%2<span class="string">"&gt;c:test.txt</span><br><span class="line">生成的文件内容为 load "</span>%1<span class="string">"  "</span>%2<span class="string">"</span><br><span class="line">批处理文件里，用这个格式把命令行参数输出到文件</span><br><span class="line"></span><br><span class="line">29 if</span><br><span class="line">判断命令</span><br><span class="line">if "</span>%1<span class="string">"=="</span>/a<span class="string">" echo 第一个参数是/a</span><br><span class="line">if /i "</span>%1<span class="string">" equ "</span>/a<span class="string">" echo 第一个参数是/a</span><br><span class="line">/i 表示不区分大小写，equ 和 == 是一样的，其它运算符参见 if/?</span><br><span class="line">if exist c:test.bat echo 存在c:test.bat文件</span><br><span class="line">if not exist c:windows (</span><br><span class="line">echo 不存在c:windows文件夹</span><br><span class="line">)</span><br><span class="line">if exist c:test.bat (</span><br><span class="line">echo 存在c:test.bat</span><br><span class="line">) else (</span><br><span class="line">echo 不存在c:test.bat</span><br><span class="line">)</span><br><span class="line">30 setlocal 和 endlocal</span><br><span class="line">设置”命令扩展名”和”延缓环境变量扩充”</span><br><span class="line">SETLOCAL ENABLEEXTENSIONS #启用"</span>命令扩展名<span class="string">"</span><br><span class="line">SETLOCAL DISABLEEXTENSIONS #停用"</span>命令扩展名<span class="string">"</span><br><span class="line">SETLOCAL ENABLEDELAYEDEXPANSION #启用"</span>延缓环境变量扩充<span class="string">"</span><br><span class="line">SETLOCAL DISABLEDELAYEDEXPANSION #停用"</span>延缓环境变量扩充<span class="string">"</span><br><span class="line">ENDLOCAL #恢复到使用SETLOCAL语句以前的状态</span><br><span class="line">“命令扩展名”默认为启用</span><br><span class="line">“延缓环境变量扩充”默认为停用</span><br><span class="line">批处理结束系统会自动恢复默认值</span><br><span class="line">可以修改注册表以禁用"</span>命令扩展名<span class="string">"，详见 cmd /? 。所以用到"</span>命令扩展名<span class="string">"的程</span><br><span class="line">序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确</span><br><span class="line">保程序能在其它系统上正确运行</span><br><span class="line">"</span>延缓环境变量扩充<span class="string">"主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程</span><br><span class="line"></span><br><span class="line">31 set</span><br><span class="line">设置变量</span><br><span class="line">引用变量可在变量名前后加 % ，即 %变量名%</span><br><span class="line">set #显示目前所有可用的变量，包括系统变量和自定义的变量</span><br><span class="line">echo %SystemDrive% #显示系统盘盘符。系统变量可以直接引用</span><br><span class="line">set p #显示所有以p开头的变量，要是一个也没有就设errorlevel=1</span><br><span class="line">set p=aa1bb1aa2bb2 #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2</span><br><span class="line">echo %p% #显示变量p代表的字符串，即aa1bb1aa2bb2</span><br><span class="line">echo %p:~6% #显示变量p中第6个字符以后的所有字符，即aa2bb2</span><br><span class="line">echo %p:~6,3% #显示第6个字符以后的3个字符，即aa2</span><br><span class="line">echo %p:~0,3% #显示前3个字符，即aa1</span><br><span class="line">echo %p:~-2% #显示最后面的2个字符，即b2</span><br><span class="line">echo %p:~0,-2% #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b</span><br><span class="line">echo %p:aa=c% #用c替换变量p中所有的aa，即显示c1bb1c2bb2</span><br><span class="line">echo %p:aa=% #将变量p中的所有aa字符串置换为空，即显示1bb12bb2</span><br><span class="line">echo %p:*bb=c% #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2</span><br><span class="line">set p=%p:*bb=c% #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2</span><br><span class="line">set /a p=39 #设置p为数值型变量，值为39</span><br><span class="line">set /a p=39/10 #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3</span><br><span class="line">set /a p=p/10 #用 /a 参数时，在 = 后面的变量可以不加%直接引用</span><br><span class="line">set /a p=”1&amp;0″ #”与”运算，要加引号。其它支持的运算符参见set/?</span><br><span class="line">set p= #取消p变量</span><br><span class="line">set /p p=请输入</span><br><span class="line">屏幕上显示”请输入”，并会将输入的字符串赋值给变量p</span><br><span class="line">注意这条可以用来取代 choice 命令</span><br><span class="line">注意变量在 if 和 for 的复合语句里是一次性全部替换的，如</span><br><span class="line">@echo off</span><br><span class="line">set p=aaa</span><br><span class="line">if %p%==aaa (</span><br><span class="line">echo %p%</span><br><span class="line">set p=bbb</span><br><span class="line">echo %p%</span><br><span class="line">)</span><br><span class="line">结果将显示</span><br><span class="line">aaa</span><br><span class="line">aaa</span><br><span class="line">因为在读取 if 语句时已经将所有 %p% 替换为aaa</span><br><span class="line">这里的"</span>替换<span class="string">"，在 /? 帮助里就是指"</span>扩充<span class="string">"、"</span>环境变量扩充<span class="string">"</span><br><span class="line">可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!</span><br><span class="line">@echo off</span><br><span class="line">SETLOCAL ENABLEDELAYEDEXPANSION</span><br><span class="line">set p=aaa</span><br><span class="line">if %p%==aaa (</span><br><span class="line">echo %p%</span><br><span class="line">set p=bbb</span><br><span class="line">echo !p!</span><br><span class="line">)</span><br><span class="line">ENDLOCAL</span><br><span class="line">结果将显示</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">还有几个动态变量，运行 set 看不到</span><br><span class="line">%CD% #代表当前目录的字符串</span><br><span class="line">%DATE% #当前日期</span><br><span class="line">%TIME% #当前时间</span><br><span class="line">%RANDOM% #随机整数，介于0~32767</span><br><span class="line">%ERRORLEVEL% #当前 ERRORLEVEL 值</span><br><span class="line">%CMDEXTVERSION% #当前命令处理器扩展名版本号</span><br><span class="line">%CMDCMDLINE% #调用命令处理器的原始命令行</span><br><span class="line">可以用echo命令查看每个变量值，如 echo %time%</span><br><span class="line">注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到</span><br><span class="line"></span><br><span class="line">32 start</span><br><span class="line">批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令</span><br><span class="line"></span><br><span class="line">33 call</span><br><span class="line">批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行</span><br><span class="line">有时有的应用程序用start调用出错的，也可以call调用</span><br><span class="line"></span><br><span class="line">34 choice (外部命令)</span><br><span class="line">选择命令</span><br><span class="line">让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……</span><br><span class="line">win98里是choice.com</span><br><span class="line">win2000pro里没有，可以从win98里拷过来</span><br><span class="line">win2003里是choice.exe</span><br><span class="line">choice /N /C y /T 5 /D y&gt;nul</span><br><span class="line">延时5秒</span><br><span class="line"></span><br><span class="line">35 assoc 和 ftype</span><br><span class="line">文件关联</span><br><span class="line">assoc 设置'文件扩展名'关联，关联到'文件类型'</span><br><span class="line">ftype 设置'文件类型'关联，关联到'执行程序和参数'</span><br><span class="line">当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开</span><br><span class="line">而是先判断.txt属于 txtfile '文件类型'</span><br><span class="line">再调用 txtfile 关联的命令行 txtfile=%SystemRoot%system32NOTEPAD.EXE %1</span><br><span class="line">可以在"</span>文件夹选项<span class="string">"→"</span>文件类型<span class="string">"里修改这2种关联</span><br><span class="line">assoc #显示所有'文件扩展名'关联</span><br><span class="line">assoc .txt #显示.txt代表的'文件类型'，结果显示 .txt=txtfile</span><br><span class="line">assoc .doc #显示.doc代表的'文件类型'，结果显示 .doc=Word.Document.8</span><br><span class="line">assoc .exe #显示.exe代表的'文件类型'，结果显示 .exe=exefile</span><br><span class="line">ftype #显示所有'文件类型'关联</span><br><span class="line">ftype exefile #显示exefile类型关联的命令行，结果显示 exefile="</span>%1<span class="string">" %*</span><br><span class="line">assoc .txt=Word.Document.8</span><br><span class="line">设置.txt为word类型的文档，可以看到.txt文件的图标都变了</span><br><span class="line">assoc .txt=txtfile</span><br><span class="line">恢复.txt的正确关联</span><br><span class="line">ftype exefile="</span>%1<span class="string">" %*</span><br><span class="line">恢复 exefile 的正确关联</span><br><span class="line">如果该关联已经被破坏，可以运行 command.com ，再输入这条命令</span><br><span class="line"></span><br><span class="line">36 pushd 和 popd</span><br><span class="line">切换当前目录</span><br><span class="line">@echo off</span><br><span class="line">c: &amp; cd &amp; md mp3 #在 C: 建立 mp3 文件夹</span><br><span class="line">md d:mp4 #在 D: 建立 mp4 文件夹</span><br><span class="line">cd /d d:mp4 #更改当前目录为 d:mp4</span><br><span class="line">pushd c:mp3 #保存当前目录，并切换当前目录为 c:mp3</span><br><span class="line">popd #恢复当前目录为刚才保存的 d:mp4</span><br><span class="line"></span><br><span class="line">37 for</span><br><span class="line">循环命令</span><br><span class="line">这个比较复杂，请对照 for/? 来看</span><br><span class="line">for %%i in (c: d: e: f:) do echo %%i</span><br><span class="line">依次调用小括号里的每个字符串，执行 do 后面的命令</span><br><span class="line">注意%%i，在批处理中 for 语句调用参数用2个%</span><br><span class="line">默认的字符串分隔符是"</span>空格键<span class="string">"，"</span>Tab键<span class="string">"，"</span>回车键<span class="string">"</span><br><span class="line">for %%i in (*.txt) do find "</span>abc<span class="string">" %%i</span><br><span class="line">对当前目录里所有的txt文件执行 find 命令</span><br><span class="line">for /r . %%i in (*.txt) do find "</span>abc<span class="string">" %%i</span><br><span class="line">在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行</span><br><span class="line">for /r . %%i in (.) do echo %%~pni</span><br><span class="line">显示当前目录名和所有子目录名，包括路径，不包括盘符</span><br><span class="line">for /r d:mp3 %%i in (*.mp3) do echo %%i&gt;&gt;d:mp3.txt</span><br><span class="line">把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去</span><br><span class="line">for /l %%i in (2,1,8) do echo %%i</span><br><span class="line">生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1</span><br><span class="line">for /f %%i in ('set') do echo %%i</span><br><span class="line">对 set 命令的输出结果循环调用，每行一个</span><br><span class="line">for /f "</span>eol=P<span class="string">" %%i in ('set') do echo %%i</span><br><span class="line">取 set 命令的输出结果，忽略以 P 开头的那几行</span><br><span class="line">for /f %%i in (d:mp3.txt) do echo %%i</span><br><span class="line">显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称</span><br><span class="line">for /f "</span>delims=<span class="string">" %%i in (d:mp3.txt) do echo %%i</span><br><span class="line">显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称</span><br><span class="line">for /f "</span>skip=5 tokens=4<span class="string">" %%a in ('dir') do echo %%a</span><br><span class="line">对 dir 命令的结果，跳过前面5行，余下的每行取第4列</span><br><span class="line">每列之间的分隔符为默认的"</span>空格<span class="string">"</span><br><span class="line">可以注意到 dir 命令输出的前5行是没有文件名的</span><br><span class="line">for /f "</span>tokens=1,2,3 delims=- <span class="string">" %%a in ('date /t') do (</span><br><span class="line">echo %%a</span><br><span class="line">echo %%b</span><br><span class="line">echo %%c</span><br><span class="line">)</span><br><span class="line">对 date /t 的输出结果，每行取1、2、3列</span><br><span class="line">第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列</span><br><span class="line">分隔符指定为 - 和"</span>空格<span class="string">"，注意 delims=- 后面有个"</span>空格<span class="string">"</span><br><span class="line">其中 tokens=1,2,3 若用 tokens=1-3 替换，效果是一样的</span><br><span class="line">for /f "</span>tokens=2* delims=- <span class="string">" %%a in ('date /t') do echo %%b</span><br><span class="line">取第2列给 %%a ，其后的列都给 %%b</span><br><span class="line"></span><br><span class="line">do后面可以加上逻辑语句 例如 for %f in (*.*) do if exist c:\%f del %f </span><br><span class="line">表示删除本目录下的文件 这些文件需要也存在在c盘有同样的名字</span><br><span class="line"></span><br><span class="line">38 subst (外部命令)</span><br><span class="line">映射磁盘。</span><br><span class="line">subst z: serverd #这样输入z:就可以访问serverd了</span><br><span class="line">subst z: /d #取消该映射</span><br><span class="line">subst #显示目前所有的映时</span><br><span class="line"></span><br><span class="line">39 xcopy (外部命令)</span><br><span class="line">文件拷贝</span><br><span class="line">xcopy d:mp3 e:mp3 /s/e/i/y</span><br><span class="line">复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件</span><br><span class="line">加 /i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问</span><br><span class="line"></span><br><span class="line">40 跳过用户选择</span><br><span class="line">del filename &lt; yes &gt;nul  如果删除文件有提示yes or no选项 可以在处理批处理文件时提前做好选择输入yes 并且结果输出到空设备 即不显示处理结果</span><br><span class="line"></span><br><span class="line">41 doskey 宏指令</span><br><span class="line">宏指令 doskey 存储在内存中 执行速度快 没有路径限制 不管在任何目录都可以直接执行 缺点是关机或重新载入dos会消失 无法像批处理文件一样存储在设备中持续使用 宏指令可以指定一些指令的简写 可以很方便地到处使用 结合宏指令的使用说明使用</span></span><br></pre></td></tr></table></figure>
<h2 id="应用实例代码"><a href="#应用实例代码" class="headerlink" title="应用实例代码"></a>应用实例代码</h2><p>使用goto和shift遍历输入的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem <span class="built_in">test</span>3.bat</span><br><span class="line">:start</span><br><span class="line"><span class="built_in">echo</span> hello %1 ,</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">if</span>(%1)==() goto end</span><br><span class="line">goto start</span><br><span class="line">:end</span><br><span class="line"><span class="built_in">echo</span> good <span class="built_in">bye</span></span><br><span class="line"></span><br><span class="line">输出以下</span><br><span class="line">D:\project\dos&gt;<span class="built_in">test</span>3 yaoming xiaohong xiaowang xiaoli</span><br><span class="line">hello yaoming ,</span><br><span class="line">hello xiaohong ,</span><br><span class="line">hello xiaowang ,</span><br><span class="line">hello xiaoli ,</span><br><span class="line">good <span class="built_in">bye</span></span><br></pre></td></tr></table></figure>
<p>使用宏指令 doskey</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\project\dos&gt;doskey d=dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\project\dos&gt;doskey /macros  ----展示所有的宏指令</span><br><span class="line">d=dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\project\dos&gt;d          -----使用宏指令</span><br><span class="line">驱动器 D 中的卷是 program</span><br><span class="line">卷的序列号是 3283-2514</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\project\dos 的目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2021/06/21  18:43    &lt;DIR&gt;          .</span><br><span class="line">2021/06/21  18:43    &lt;DIR&gt;          ..</span><br><span class="line">2021/06/21  09:56                15 <span class="built_in">test</span>2.bat</span><br><span class="line">2021/06/21  10:53               192 <span class="built_in">test</span>3.bat</span><br><span class="line">2021/06/21  10:54                36 <span class="built_in">test</span>4.bat</span><br><span class="line">2021/06/21  16:51                21 <span class="built_in">test</span>5.bat</span><br><span class="line">               4 个文件            264 字节</span><br><span class="line">               2 个目录 241,747,546,112 可用字节</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结下dos的常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="dos" scheme="http://luyaoming.com/tags/dos/"/>
    
  </entry>
  
  <entry>
    <title>测试迁移hexo到另一台主机</title>
    <link href="http://luyaoming.com/2021/06/15/%E6%B5%8B%E8%AF%95%E8%BF%81%E7%A7%BBhexo%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA/"/>
    <id>http://luyaoming.com/2021/06/15/测试迁移hexo到另一台主机/</id>
    <published>2021-06-15T01:14:45.000Z</published>
    <updated>2021-06-17T10:23:35.035Z</updated>
    
    <content type="html"><![CDATA[<p>最近买了台新电脑 默认win10系统 为了开发方便 装了wsl2 捣鼓编译环境</p>
<p>之前在mac Os上写日记更新hexo 买了新电脑图新鲜 想使用windows继续更新 </p>
<p>下面简单记录下迁移hexo到另一台电脑遇到的一些问题</p>
<a id="more"></a>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>思路很简单：备份mac上的hexo文件到gitee 另一台电脑下载下来 然后通过npm 安装软件</p>
<p>顺便说说这样做得好处：上传数据而非u盘拷贝 是为了每次更新方便  不用u盘考来考去 gitee是国内的 比github快 且区分一个发布用 一个备份用比较清晰</p>
<p>把hexo备份到<a href="https://gitee.com/asii2020/myhexo" target="_blank" rel="external">https://gitee.com/asii2020/myhexo</a> 目录下 </p>
<p>记得上传之前 把.gitignore文件的内容删除或注释掉 把所有文件先上传</p>
<p>换电脑 切换到新建的hexo目录下 git clone <a href="https://gitee.com/asii2020/myhexo" target="_blank" rel="external">https://gitee.com/asii2020/myhexo</a> </p>
<p>下面是在wsl2的环境下安装</p>
<p>重新执行sudo cnpm install –force</p>
<p>如果出现hexo-rederer-sass 安装失败 执行 </p>
<p>sudo rm -rf node_moudles</p>
<p>cnpm install –save node-sass</p>
<p>cnpm install </p>
<p>接着测试</p>
<p>hexo new “测试迁移hexo到另一台主机”</p>
<p>hexo g</p>
<p>hexo d</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>最近发现七牛提供的图床服务不好使了 我之前写的文章里带图片都不显示了  </p>
<p>发现原来现在他内部改革了 国内的域名需要备案才可以上传和浏览图像</p>
<p>我在16年搞建站的时候 没有这回事 很简单地就生成了图片链接了 </p>
<p>之前的空间划分在华东 由于我的域名是godaddy申请的 属于美国地区 内容空间提供商是github也在美国  没办法在国内备案</p>
<p>没办法 只能在七牛上新建一个北美地区的空间 迁移华东的图片到北美的空间 使用他们提供的脚本 发现不同区域的不能迁移</p>
<p>还好站点的图片我有备份在上一台电脑上 只能重新上传了 这时候七牛给我分配了一个图片服务的测试地址quqnn25zc.bkt.gdipper.com</p>
<p>期间我一直纠结 是否继续使用七牛 因为他们提供的北美空间是有回收期限的 30天后自动回收 </p>
<p>为应对这个机制 可以在七牛新建空间（同区域） 并且迁移内容到新的空间 然后替换博客内容的图片地址 具体操作看这个链接</p>
<p>[]: <a href="https://segmentfault.com/a/1190000018196548" target="_blank" rel="external">https://segmentfault.com/a/1190000018196548</a>    “七牛测试地址被回收了怎么办”</p>
<p>如果不使用图床  可以使用hexo-asset-image或者hexo-image-link等插件来插入图片 个人尝试了一下 发现不好使 图片依然不显示</p>
<p>下面介绍使用typora和picgo的方式插入图片的方法</p>
<p>首先 使用typora的文件–偏好设置–图像  设置如图所示</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/typora的偏好设置picgo.jpg" alt></p>
<p>这里 上传服务我选择了picgo app 可以直接使用gui进行配置</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/图床设置.jpg" alt></p>
<p>然后进入格式-图像-插入图片时-上传图像</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/image-20210617181200571.png" alt="image-20210617181200571"></p>
<p>这样可以很方便在typora上右键插入图片或者复制粘贴粘贴板的图像到文章里都可以了 也不需要自己按照固定路径放置图片等操作</p>
<p>只要插入操作 就会触发上传了  相当无脑 我喜欢</p>
<p>有时候插入后 hexo d -g 没有显示图片立马出来 不用担心  只要确认七牛上传的地址能够在浏览器上load到图片就可以了 网页会稍后才生效 还有网站和图片部署在美国 也可能是导致图片出来慢的原因吧</p>
<p>测试插入图片</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/lushi1.jpg" alt></p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/lushi2.jpg" alt></p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/lushi3.jpg" alt></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近买了台新电脑 默认win10系统 为了开发方便 装了wsl2 捣鼓编译环境&lt;/p&gt;
&lt;p&gt;之前在mac Os上写日记更新hexo 买了新电脑图新鲜 想使用windows继续更新 &lt;/p&gt;
&lt;p&gt;下面简单记录下迁移hexo到另一台电脑遇到的一些问题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（六）</title>
    <link href="http://luyaoming.com/2021/05/31/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/31/Primer-cpp-第五版读书笔记（六）/</id>
    <published>2021-05-31T06:49:18.000Z</published>
    <updated>2021-06-24T10:13:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的动态内存</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<h2 id="十二，动态内存"><a href="#十二，动态内存" class="headerlink" title="十二，动态内存"></a>十二，动态内存</h2><p>动态内存和智能指针</p>
<p>我们之前介绍了静态内存和栈内存 静态内存用来保存局部static对象 类static的数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象 分配在静态或栈内存中的对象由编译器自动创建和销毁 对于栈对象 仅在其定义的程序块运行时才存在 static对象在使用前被分配 在程序结束时销毁</p>
<p>在c++中 使用new分配空间并返回一个指向该对象的指针 使用delete来销毁对象并释放与之关联的内存</p>
<p>新的标准库采用智能指针来管理动态对象 类似于常规指针 重要的区别是负责自动释放所指向的对象 使用shared_ptr允许多个指针指向同一个对象 使用unique_ptr来独占所指向的对象 使用weak_ptr作为弱引用 指向shared_ptr所指向的对象 这些类型都定义在memory头文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是shared_ptr和unique_ptr都支持的操作</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; sp <span class="comment">// 空智能指针 可以指向类型为T的对象 使用if(sp)可以判断是否已经指向某个对象 使用*sp解引用sp 获得他所指对象</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; up</span><br><span class="line">p -&gt; mem <span class="comment">// 等价于 (*p).mem</span></span><br><span class="line">p.get() <span class="comment">// 返回p中保存的指针 小心使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr独有的操作</span></span><br><span class="line">make_shared&lt;T&gt; args <span class="comment">// 返回一个shared_ptr 指向一个动态分配的类型为T的对象 使用args初始化该对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q) <span class="comment">//p是shared_ptr q的拷贝 此操作会递增q的计数器 q中指针必须能转换成T*</span></span><br><span class="line">p = q <span class="comment">// p和q都是shared_ptr 所保存的指针可以相互转换 此操作递减p的引用计数 递增q的引用计数 若p的引用计数为0 则其管理的原内存释放</span></span><br><span class="line">p.unique() <span class="comment">// 若p.use_count()为1 返回true </span></span><br><span class="line">p.use_count() <span class="comment">//返回与p共享对象的智能指针数量 可能很慢 用于调试</span></span><br></pre></td></tr></table></figure>
<p>使用make_shared是最安全的分配和使用动态内存的方式<code>shared_ptr&lt;int&gt; p3=make_shared&lt;int&gt;(42);</code> 更简单地 使用auto来保存<code>auto p6=make_shared&lt;vector&lt;string&gt;&gt;();</code></p>
<p>当进行拷贝和赋值操作时 每个shared_ptr都会记录有多少个shared_ptr指向相同的对象 当拷贝一个shared_ptr时计数器会递增 一旦shared_ptr的计数器为0 他就会释放自己所管理的对象 举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);<span class="comment">//r指向的int只有一个引用</span></span><br><span class="line">r = q;<span class="comment">//给r赋值 他指向另一个地址 递增q指向的对象的引用计数 递减r原来指向的对象的引用计数 r原来指向的对象已经没有引用者 会自动释放</span></span><br></pre></td></tr></table></figure>
<p>一般在方法内创建的智能指针 会随着函数调用结束被回收 引用计数自动清零 但是有种情况例外 使用return返回指针的拷贝时 如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; useFactory(T arg)&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p = factory(arg);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的一点是 如果智能指针放置在容器内 当不再需要全部元素 只保留一部分的时候 确保eraser那些不需要的shared_ptr元素</p>
<p>程序使用动态内存的三个原因：</p>
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="built_in">string</span>&gt; b1;</span><br><span class="line">&#123;</span><br><span class="line">	Blob&lt;<span class="built_in">string</span>&gt; b2 = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"cdefg"</span>&#125;;</span><br><span class="line">	b1 = b2; <span class="comment">//b1和b2共享相同的元素 b2离开作用域时 他所引用的元素需要被保留 因为b1还在引用他们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用new分配动态内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *pr = new <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = new <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用列表初始化</span></span><br><span class="line"><span class="keyword">int</span> *p1 = new <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">string</span> *pr = new <span class="built_in">string</span>(<span class="string">"ac"</span>,<span class="string">"bd"</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = new <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以用auto让编译器根据初始化器的类型来推断要分配的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = new <span class="keyword">auto</span>(obj); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">auto</span> p2 = new <span class="keyword">auto</span>&#123;obj1,obj2,obj3&#125;; <span class="comment">// 错误 只能有一个初始化器</span></span><br></pre></td></tr></table></figure>
<p>动态分配const对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi = new <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>使用delete来释放动态内存 delete pi；代表两个动作 释放给定的指针指向的对象 释放对应的内存</p>
<p>内存耗尽时 使用new分配内存会默认抛出bad_alloc异常 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = new <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 如果分配失败 抛出std::bad_alloc异常</span></span><br><span class="line"><span class="keyword">int</span> *p2 = new (nothrow) <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 加入nothrow参数 失败时不会抛出异常 会返回一个空指针 这些参数定义在头文件new中</span></span><br></pre></td></tr></table></figure>
<p>由内置指针 而不是智能指针管理的动态内存在显式释放前会一直都存在 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Foo *<span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">	return new Foo(arg); <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    Foo *p = factory(arg); <span class="comment">// 使用 没有delete p就算在use_factory运行结束 离开作用域 也不会被释放</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 没有这一行 方法运行结束 p不会被释放 正确方法是使用delete释放此内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shared_ptr和new结合使用</p>
<p>使用new构造一个shared_ptr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; pr = new int(1024);//错误 </span><br><span class="line">shared_ptr&lt;int&gt; pr(new int(1024));//正确 </span><br><span class="line">shared_ptr&lt;int&gt; clone(int p)&#123;</span><br><span class="line">	return new int(p); // 错误 智能指针的构造函数是explicit的 不能使用隐式转换</span><br><span class="line">	return shared_ptr&lt;int&gt;(new int(p));//正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要混合使用普通指针和智能指针 也不要使用get来给另一个智能指针赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(new <span class="keyword">int</span>(<span class="number">1024</span>));</span><br><span class="line"><span class="keyword">int</span> *q = p.get();<span class="comment">//正确 但是要注意 不要让q管理的内存被释放 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(q); <span class="comment">// 两个独立的shared_ptr指向了相同的内存</span></span><br><span class="line">&#125;<span class="comment">//程序块运行结束 q被销毁  他指向的内存会被释放</span></span><br><span class="line"><span class="keyword">int</span> foo = *p; <span class="comment">// 未定义 p指向的内存已经被释放</span></span><br></pre></td></tr></table></figure>
<p>使用智能指针还有另一个好处 当遇到异常情况时  不再使用的对象的内存会被释放 但是直接管理的动态内存不会</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;p(new <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//发生异常 且在f中未捕获</span></span><br><span class="line">&#125;<span class="comment">//函数结束 p指向的内存会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = new <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//发生异常 且在f中未捕获</span></span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">//想正常释放内存</span></span><br><span class="line">&#125;<span class="comment">//当异常发生在释放p之前 delete p没有被正常调用 那么p所指内存不会被释放</span></span><br></pre></td></tr></table></figure>
<p>智能指针虽好  但是建立在正确使用的前提下 下面是使用智能指针应该要注意的部分</p>
<ol>
<li>不使用相同内置指针值初始化（或者reset）多个智能指针</li>
<li>不delete get()获得的指针</li>
<li>不使用get()初始化或者reset()另一个智能指针</li>
<li>如果使用了get()获取了指针 要记住这个指针被释放后就无效了</li>
<li>如果智能指针管理的内存不是通过new分配的 要记得传递给他一个删除器</li>
</ol>
<p>unique_ptr 指针</p>
<p>与智能指针不一样 某个时刻只能有一个unique_ptr指向一个给定的对象 当unique_ptr被销毁时 他指定的对象也会被销毁</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unique_ptr p1(new int(1024));//初始化</span><br><span class="line">unique_ptr p2(p1);//错误 不支持拷贝</span><br><span class="line">unique_ptr p3;</span><br><span class="line">p3 = p1;//错误 不支持赋值</span><br><span class="line">unique_ptr&lt;T&gt; u1;//u1指向T类型的对象 没有指定删除器 可以使用delete释放对应对象内存</span><br><span class="line">unique_ptr&lt;T,D&gt; u2;//u2指向T类型的对象 指定删除器D 使用D代替delete释放对应对象内存</span><br><span class="line">p1 = nullptr;</span><br><span class="line">p1.reset();</span><br><span class="line">p1.release();//这三个都是释放对象的方法</span><br><span class="line"></span><br><span class="line">//unique_ptr虽然不能拷贝和赋值 但是可以转移</span><br><span class="line">unique_ptr&lt;string&gt; p2(p1.release());//将所有权从p1 转移到p2</span><br><span class="line">unique_ptr&lt;string&gt; p3(new string("hello"));</span><br><span class="line">p2.reset(p3.release());//reset释放原来指向的内存 指向p3原来指向的内存 p3置空</span><br></pre></td></tr></table></figure>
<p>weak_ptr 弱指针</p>
<p>弱指针的特点是不增加引用计数 当弱指针指向的shared_ptr的引用计数为0时 即使还有弱指针指向 对象一样会被释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; w;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; w(p); <span class="comment">// 与shared_ptr p指向相同对象的弱指针</span></span><br><span class="line">w = p; <span class="comment">// 正确 共享shared_ptr指向的对象</span></span><br><span class="line">w.reset();<span class="comment">//w置空</span></span><br><span class="line">w.use_count();<span class="comment">//与他指向的shared_ptr使用use_count的值一样</span></span><br><span class="line">w.expired();<span class="comment">//若w.use_count为0，返回true 否则返回false</span></span><br><span class="line">w.lock();<span class="comment">//若w.use_count为0 返回空指针 否则返回一个指向w的对象的shared_ptr</span></span><br></pre></td></tr></table></figure>
<p>447</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的动态内存&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>十步学习法</title>
    <link href="http://luyaoming.com/2021/05/28/%E5%8D%81%E6%AD%A5%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>http://luyaoming.com/2021/05/28/十步学习法/</id>
    <published>2021-05-28T07:58:40.000Z</published>
    <updated>2021-06-15T01:08:34.810Z</updated>
    
    <content type="html"><![CDATA[<p>采摘自《软技能-代码之外的生存技能》</p>
<a id="more"></a>
<h2 id="第一步：了解全局"><a href="#第一步：了解全局" class="headerlink" title="第一步：了解全局"></a>第一步：了解全局</h2><p>比如学习一门语言 应该了解下他的应用领域 支持平台 编译环境 语法树目录 对比其他语言的优势 提供学习的动力  有个大概的框架 需要有一个全局的认识</p>
<h2 id="第二步：确定范围"><a href="#第二步：确定范围" class="headerlink" title="第二步：确定范围"></a>第二步：确定范围</h2><p>集中精力明确到底要学什么 在任何项目中 明确项目范围是至关重要的 唯有这样才能了解项目的全局 做好相应的准备 学习如是 不要试图全面掌握所有知识 可能你真正需要用到的就是全局里的20% 需要明确你要解决的问题在哪个学习的范围 选择一个专注而且聚焦的范围 潜心学习吧 范围务必大小适当 要符合自己的时间规划</p>
<p>示例：</p>
<p>定义初始的主题：学习c++</p>
<p>再定义分解的子主题：学习c++的基础知识 学习如何创建一个简单的控制台程序</p>
<h2 id="第三步：定义目标"><a href="#第三步：定义目标" class="headerlink" title="第三步：定义目标"></a>第三步：定义目标</h2><p>有了范围之后 目标其实很好定义  努力简明清晰地陈述 勾勒出你勤奋学习后的成功图像 并且明确其中具体的成功标准 从而更加充分地评估自己是否达成学习目标 好的成功标准应该是具体的 无二义性的</p>
<p>示例：</p>
<p>一个不好的目标：我学习了关于C++语言的基础知识</p>
<p>好的目标：我可以利用C++的基础知识写出一个小的应用程序</p>
<h2 id="第四步：寻找资源"><a href="#第四步：寻找资源" class="headerlink" title="第四步：寻找资源"></a>第四步：寻找资源</h2><p>不能只从一本书或一个人那里获取学习的资源 需要多方面的资源来整合 可以从下面这些方面去寻找资源：</p>
<p>图书  博客文章  在线视频 专家或者对此方面已经熟悉的人 播客 源代码 示例项目 在线文档</p>
<h2 id="第五部：创建学习计划"><a href="#第五部：创建学习计划" class="headerlink" title="第五部：创建学习计划"></a>第五部：创建学习计划</h2><p>看书时 我们经常看到书的目录是层层递进的  创建自己的学习路径 把它看成是自己写书的大纲 还有一个好方法是 观察别人是如何教你感兴趣的主题的</p>
<h2 id="第六步：筛选资源"><a href="#第六步：筛选资源" class="headerlink" title="第六步：筛选资源"></a>第六步：筛选资源</h2><p>对拿到的资源进行筛选 利用最有价值的来实现自己的目标 没有必要把所有资源都利用一遍 因为肯定有重复的 就像买书时 只需要最能体现主题的3-4本即可 就像我学习c++ 共挑选了4本书 </p>
<h2 id="第七步：开始学习-浅尝辄止"><a href="#第七步：开始学习-浅尝辄止" class="headerlink" title="第七步：开始学习 浅尝辄止"></a>第七步：开始学习 浅尝辄止</h2><p>学习过程中通常犯的两类错误：1，在知道不多的情况下盲目开始 行动太快 2，行动之前准备太多 即行动过慢 需要在两者之间取得平衡 不要溺死在知识海洋中 要做一个懂得游泳的人 每次只使用一种泳姿 学会了再换另一种 </p>
<h2 id="第八步：动手操作-边玩边学"><a href="#第八步：动手操作-边玩边学" class="headerlink" title="第八步：动手操作 边玩边学"></a>第八步：动手操作 边玩边学</h2><p>没有什么比兴趣更能成为自己的老师 哎 就是玩 只有从中感受到乐趣了才会更加深入地去探索 多动手 不要只停留在耳朵和口  慢慢就会习惯了  印证了古语有云：无他 唯手熟尔</p>
<h2 id="第九步：全面掌握-学以致用"><a href="#第九步：全面掌握-学以致用" class="headerlink" title="第九步：全面掌握 学以致用"></a>第九步：全面掌握 学以致用</h2><p>这一步的目标是找回好奇心 好驱动你的学习 回顾一些遗漏的知识 让自己在这个领域更加全面 并用在具体的地方</p>
<h2 id="第十步：乐为人师-融汇贯通"><a href="#第十步：乐为人师-融汇贯通" class="headerlink" title="第十步：乐为人师 融汇贯通"></a>第十步：乐为人师 融汇贯通</h2><p>走出舒适区 将自己学到的知识教给别人 这是学习最高最有效率的方式 可以用多种方式教别人 例如写博客 分享会  从中把之前没明白的事情弄明白了 并且复习了之前的知识</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;采摘自《软技能-代码之外的生存技能》&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="学习方法" scheme="http://luyaoming.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（五）</title>
    <link href="http://luyaoming.com/2021/05/25/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/25/Primer-cpp-第五版读书笔记（五）/</id>
    <published>2021-05-25T03:04:15.000Z</published>
    <updated>2021-06-17T04:01:37.354Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的泛型算法和关联容器</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<p>## </p>
<h2 id="十，泛型算法"><a href="#十，泛型算法" class="headerlink" title="十，泛型算法"></a>十，泛型算法</h2><p>标准库并未为每个容器定义成员函数来实现一些算法操作 如查找特定元素 替换或删除一个特定值 重排元素顺序等 而是定义了一个泛型算法放在头文件algorithm 和numeric中 现在想来 排序 替换 查找 删除这些操作完全可以不依赖于特定的容器 他们是一些公共的操作 只需要提供迭代器 操作迭代器既可以达成目的</p>
<p>常用的算法有 求和 <code>int sum = accumulate(vec.cbegin(),vec.cend(),0);</code></p>
<p>比较算法 <code>auto e1 = equal(vec.cbegin(),vec.cend,list1.cbegin());</code> 这里vec可以是vector<string> 而list1可以是list<const char*> </const></string></p>
<p>写容器算法 <code>fill(vec.begin(),vec.begin()+ vec.size()/2,10);</code></p>
<p>插入迭代器 <code>fill_n(back_insert(vec),10,0);</code></p>
<p>拷贝算法 <code>auto ret = copy(begin(a1),end(a1),a2);</code> 从a1到a2的拷贝 ret指向拷贝到a2的尾元素之后的位置</p>
<p>替换算法 <code>auto replace1 = replace_copy(ilst.begin(),ilst.end(),0,42);</code> 将所有值为0的元素都改为42</p>
<p>按字典排序 <code>sort(words.begin(),words.end*());</code></p>
<p>消除重复项 <code>auto end_unique =unique(words.begin(),words.end());</code></p>
<p>删除重复项 <code>words.erase(end_unique,words.end())</code> 上面的消除重复项并没有真正的删除重复的元素 只是放在序列的后面 而返回的end_unique指针指向最后一个不重复元素的后面 所以需要对容器进行删除操作才把重复项删除掉</p>
<p>除了可以按字典排序外 sort函数可以接收一个比较函数（谓词）来实现不同的排序方式 类似于java中的comparor比较器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">  return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(),words.end(),isShorter);<span class="comment">//传入比较函数</span></span><br></pre></td></tr></table></figure>
<p>stable_sort函数可以保证相等元素的相对位置不变 是sort的升级版 对比sort 在排序后 sort是不保证相等元素会按之前的顺序排序 而stable_sort可以做到这一点</p>
<p>lambda表达式是一个可调用对象 表示一个可调用的代码单元 可以将其理解为一个未命名的内联函数 一个lambda表示的形式如<code>[capturelist](parameter list) -&gt; return type { function body }</code> 其中<code>capturelist</code>是一个lambda所在函数中定义的局部变量的列表 其他的望文生义 有时可以忽略参数列表和返回类型 但是必须包含局部变量列表和函数体<code>auto f = [] {return 42};</code> 返回类型可以通过函数体推断出 这里是返回整数类型</p>
<p>使用lambda表达式来表示上面提到的isShorter函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a,<span class="keyword">const</span> &amp;b)&#123;return a.size() &lt; b.size();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将isShorter函数添加到sort函数时</span></span><br><span class="line">sort(words.begin(),words.end(),</span><br><span class="line">    [](const string &amp;a,const &amp;b)</span><br><span class="line">     &#123;return a.size() &lt; b.size();&#125;);</span><br></pre></td></tr></table></figure>
<p>使用for_each函数代替循环体打印例如 <code>for_each(wc,word.end(),[](const string &amp;s){cout &lt;&lt; s &lt;&lt; &quot; &quot;;});</code></p>
<p>在lambda表达式中如果要捕获引用 必须要保证在lambda执行时 绑定到迭代器 或指针 或引用的对象依然存在并且保证对象具有预期的值 因为在lambda创建到执行的过程中有可能代码会改变绑定的对象的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将words按字典排序并删除重复元素 使用os流输出大于sz长度的字符串 并以c隔开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz,</span><br><span class="line">            ostream &amp;os = <span class="built_in">cout</span>,<span class="keyword">char</span> c = <span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">  sort(words.begin(),words.end());</span><br><span class="line">  <span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</span><br><span class="line">  words.erase(end_unique,words.end());</span><br><span class="line">  <span class="comment">//稳定重排 按字符串长度大小为基准重排 重复元素保持之前的字典排序</span></span><br><span class="line">  stable_sort(words.begin(),words.end(),</span><br><span class="line">             [](const string &amp;a,const string &amp;b)&#123;</span><br><span class="line">               return a.size() &lt; b.size();</span><br><span class="line">             &#125;);</span><br><span class="line">  <span class="comment">//找到长度大于等于sz的字符串的迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> wc = find_if(words.begin(),words.end(),</span><br><span class="line">             [sz](const &amp;a)&#123;</span><br><span class="line">               return a.size() &gt;= sz;</span><br><span class="line">             &#125;);</span><br><span class="line">  <span class="comment">//计算距离 由于已经经过排序wc迭代器之后的元素长度必定都大于等于sz </span></span><br><span class="line">  <span class="keyword">auto</span> count = word.end() - wc;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"length = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//打印这些长度大于等于sz的元素</span></span><br><span class="line">  for_each(wc,words.end(),[](const string &amp;s)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda表达式的破获列表[capturelist] 可以分为隐式捕获和 显式捕获 区别就是隐式捕获会隐藏变量名 让编译器自动推断我们使用哪些变量 其中使用 &amp; 表示捕获引用方式 =表示值捕获 </p>
<p>捕获列表里的参数为局部变量 默认情况下 对于一个值被拷贝的变量 lambda不会改变其值 但是如果希望可以改变 使用mutable关键字<code>auto f = [v1]()mutable{return ++v1;}</code></p>
<p>在我们使用lambda时他的函数体是一个单一的return语句 编译器可以推断出他的return类型所以可以忽略不写 但是如果将单一的return语句替换成if else语句 就需要使用尾置返回类型来表示了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transfrom(vi.begin(),vi.end(),vi.begin,</span><br><span class="line">         [](int i)&#123;return i&lt;<span class="number">0</span> ? -i : i;&#125;);<span class="comment">//正确 单一的return语句 编译器可以推断return类型 无需显式表示</span></span><br><span class="line"></span><br><span class="line">transfrom(vi.begin(),vi.end(),vi.begin,</span><br><span class="line">         [](int i)&#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)return -i;<span class="keyword">else</span> return i;&#125;);<span class="comment">//错误 编译器推断他将返回void 但他返回了int值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一定要使用if else语句 那就需要显式定义返回类型 使用尾置返回类型</span></span><br><span class="line">transfrom(vi.begin(),vi.end(),vi.begin,</span><br><span class="line">         [](int i) -&gt; <span class="keyword">int</span></span><br><span class="line">          &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)return -i;<span class="keyword">else</span> return i;&#125;);<span class="comment">//正确 定义返回int</span></span><br></pre></td></tr></table></figure>
<p>参数绑定</p>
<p>对于只用到一两个地方使用的简单操作 使用lambda表达式是最佳的 但是如果很多地方用到同样的lambda时 每次都要编写同样的lambda表示式明显不利于代码重写 此时我们想到使用函数来代替lambda表达式是最简单的 如果lambda表示式的捕获列表为空这非常方便做到 但是如果捕获列表不为空  就需要解决向形参传递参数的问题了 </p>
<p>标准库bind函数应运而生 他可以解决向函数的参数传递带参数的函数问题 定义在头文件functional中 看做一个通用的函数适配器 可接受一个可调用对象 生成一个新的可调用对象来适应原对象的参数列表 形式<code>auto newcallable = bind(callable,arg_list);</code> 其中arg_list中包含参数如_n的参数  n为整数 表示传递给newcallable的参数的位置 _1表示newCallable的第一个参数 _2表示第二个参数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="built_in">string</span>::size_type sz)</span></span>&#123;</span><br><span class="line">  return s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> check6 = bind(check_size,_1,<span class="number">6</span>);<span class="comment">//只有一个占位符 表示check6只接受单一参数 出现在arg_list中的第一个位置</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">bool</span> b1 = check6(s);<span class="comment">//check6(s)会调用check_size(s,6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(),words.end(),</span><br><span class="line">             [sz](const &amp;a)&#123;</span><br><span class="line">               return a.size() &gt;= sz;</span><br><span class="line">             &#125;);</span><br><span class="line"><span class="comment">//使用bind替换find_if的lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(),words.end(),</span><br><span class="line">             bind(check_size,_1,sz));<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(),words.end(),</span><br><span class="line">             check_size(words,sz));<span class="comment">//错误 找不到sz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的参数_1是在placeholders命名空间中定义的 逐个引入有点麻烦 使用以下方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"><span class="comment">//若arg_list不止一个参数 可包含多个占位符_1 _2</span></span><br><span class="line"><span class="keyword">auto</span> g = bind(f,a,b,_2,c,_1);</span><br><span class="line"><span class="comment">//上面的f函数使用了5个参数 其中三个已经可以定下来 剩下两个可通过g调用对象设置</span></span><br><span class="line">g(_1,_2) <span class="comment">//将会映射成bind(f,a,b,_2,c,_1)</span></span><br></pre></td></tr></table></figure>
<p>插入迭代器</p>
<p>使用<code>back_inserter</code> or <code>front_inserter</code>或 <code>inserter</code>来生成插入迭代器 使用插入迭代器赋值语句<code>*it = val</code> 相当于 <code>it = c.insert(it,val);++it;</code> </p>
<p>iostream迭代器 标准库中定义了可以用于这些IO类型对象的迭代器包括istream_iterator 和 ostream_iterator 这些迭代器将他们对应的流当作一个特定类型的元素序列来处理 输入输出流迭代器只支持递增 不支持递减</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in(<span class="built_in">cin</span>),eof;<span class="comment">//初始化输入流迭代器 一个已经构造 一个空</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(in,eof);<span class="comment">//从迭代器范围构造vec</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accmulate(in,eof,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//对流中的元素求和 比循环输入的值求和方便多了</span></span><br><span class="line"></span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)&#123;</span><br><span class="line">  *out_iter++ = e;<span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过copy来打印vec的元素 比编写循环更加简单</span></span><br><span class="line">copy(vec.begin(),vec.end(),out_iter);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>算法形参模式</p>
<p>大多数算法具有以下4中形式之一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">alg(beg,end,other args);</span><br><span class="line">alg(beg,end,dest,other args);</span><br><span class="line">alg(beg,end,beg2,oter args);</span><br><span class="line">alg(beg,end,beg2,end2,oter args);</span><br></pre></td></tr></table></figure>
<p>注意 对于list和forward_list 应该优先使用成员函数版本的算法而不是通用算法</p>
<h2 id="十一，关联容器"><a href="#十一，关联容器" class="headerlink" title="十一，关联容器"></a>十一，关联容器</h2><p>下面列举c++标准库的8个关联容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按关键字有序保存元素</span></span><br><span class="line"><span class="built_in">map</span> <span class="comment">//关联数组 保存关键字 -值对</span></span><br><span class="line"><span class="built_in">set</span> <span class="comment">//只保存关键字的容器 </span></span><br><span class="line"><span class="built_in">multimap</span> <span class="comment">//关键字可重复的map</span></span><br><span class="line"><span class="built_in">multiset</span> <span class="comment">//关键字可重复的set</span></span><br><span class="line"><span class="comment">//无序集合</span></span><br><span class="line"><span class="built_in">unordered_map</span> <span class="comment">//用哈希函数组织的map</span></span><br><span class="line"><span class="built_in">unordered_set</span> <span class="comment">//</span></span><br><span class="line"><span class="built_in">unordered_multimap</span> <span class="comment">//哈希组织的map 关键字可以重复出现</span></span><br><span class="line"><span class="built_in">unordered_multiset</span> <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>要对容器的元素进行排序 那么就需要比较 就需要给出比较操作的定义 一般的基本类型不需要明确给出 但是自定义的类型就需要给出</p>
<p>pair类型</p>
<p>定义在utility头文件中 包含两个数据成员 是一个用来生成特定类型的模板 两个数据的类型可以不一样 初始化一个pair <code>pair&lt;string,string&gt; author{&quot;james&quot;,&quot;laov&quot;};</code> 可以使用成员变量名first和second来访问他们 可以使用字段key_type value_type 访问map和pair的关键字类型和值类型 map的value_type 比较特殊 是pair<const key_type,maped_type></const></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对map使用迭代器 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; word_count&#123;&#123;<span class="string">"xiao"</span>,<span class="string">"xiao"</span>.size()&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"lu"</span>;<span class="comment">//错误 关键字为const</span></span><br><span class="line">++map_it-&gt;second;<span class="comment">//正确 改变value的值自增</span></span><br></pre></td></tr></table></figure>
<p>遍历map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(map_it != word_count.end())&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">" : "</span>&lt;&lt; map_it-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  ++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向map添加元素 insert具有返回值 他的类型为pair<map<string,size_t>::iterator,bool&gt; 其中first元素是一个map 表示当前指向元素的迭代器 后者表示是否插入成功</map<string,size_t></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word_count.insert(word,<span class="number">1</span>);</span><br><span class="line">word_count.insert(make_pair(word,<span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">siez_t</span>&gt;(word,<span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt;::value_type(word,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>map删除元素 关联容器定义了三个版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word_count.erase(<span class="string">"xiao"</span>);<span class="comment">//指定关键字</span></span><br><span class="line">word_count.erase(word_count.begin());<span class="comment">//指定迭代器</span></span><br><span class="line">word_count.erase(word_count.begin(),word_count.end());<span class="comment">//指定范围</span></span><br></pre></td></tr></table></figure>
<p>对map使用下标操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word_count[<span class="string">"xiao"</span>] = <span class="number">1</span>;<span class="comment">//下标不存在 会添加新元素 或者覆盖旧的值</span></span><br></pre></td></tr></table></figure>
<p>与vector和string不同的是 map的下标运算符的返回类型和解引用map迭代器得到类型不同 下标操作时的返回类型是mapped_type 解引用迭代器是value_type类型 另外使用下标运算设置值时 如果关键字不在map中 则会添加新元素</p>
<p>使用count和find来访问map元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">iset.find(<span class="number">1</span>);<span class="comment">//返回迭代器 指向key == 1的元素</span></span><br><span class="line">iset.find(<span class="number">6</span>);<span class="comment">//返回迭代器 等于iset.end();</span></span><br><span class="line">iset.count(<span class="number">1</span>);<span class="comment">//返回1</span></span><br><span class="line">iset.count(<span class="number">6</span>);<span class="comment">//返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lower_bound 返回的迭代器指向第一个匹配关键字的元素 而upper_bound是最后一个匹配的元素的迭代器 多用在multi序列</span></span><br><span class="line"><span class="built_in">string</span> authors&#123;<span class="string">"hello world!"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.lower_bound(<span class="string">"l"</span>),end = authors.upper_bound(<span class="string">"l"</span>);beg != end; beg++)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equal_range 也用作查找指定重复元素 他的成员first代表第一个 second代表最后一个 表示一个等值范围</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.equal_range(<span class="string">"l"</span>);pos.first!=pos.second;++pos.first;)&#123;</span><br><span class="line">  count &lt;&lt; pos.first-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管理桶</p>
<p>无序容器使用一个哈希函数将元素映射到桶 为了访问一个元素 容器首先计算元素的哈希值 他指出容器应该搜索哪个桶 容器将具有一个特定哈希值的所有元素都保存到相同的桶中 无序容器提供一些函数来管理桶</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.bucket_count();<span class="comment">// 正在使用的桶的数目</span></span><br><span class="line">c.max_bucket_count();<span class="comment">// 容器能容纳的最多的桶的数量</span></span><br><span class="line">c.bucket_size(n);<span class="comment">//第n个桶的元素总数</span></span><br><span class="line">c.bucket(k);<span class="comment">//关键字为k的元素在哪个桶</span></span><br><span class="line"></span><br><span class="line">local_iteraror <span class="comment">//可以用来访问桶中元素的迭代器类型</span></span><br><span class="line">const_local_iterator <span class="comment">//const版本</span></span><br><span class="line">c.begin(n),c.end(n)<span class="comment">// 桶n的首元素迭代器和尾后迭代器</span></span><br><span class="line">c.cbegin(n),c.cend(n)<span class="comment">// 返回const_local_iterator</span></span><br></pre></td></tr></table></figure>
<p>如果要把自定义的类型作为map的key 那么必须重写hasher函数和eqOp函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> hasher(<span class="keyword">const</span> Sales_data &amp;sd)&#123;</span><br><span class="line">  return hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Slaes_data &amp;lhs,<span class="keyword">const</span> Slaes_data &amp;rhs)</span></span>&#123;</span><br><span class="line">  return lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个无序可重复的集合 使用别名</span></span><br><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data,<span class="keyword">decltype</span>(hasher)*,<span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>,hasher,eqOp)</span></span>;<span class="comment">//参数是桶的大小 哈希函数指针 相等性判断运算符指针 如果已经在Sales_data类中定义了==运算符 则eqOp可以省略</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的泛型算法和关联容器&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（四）</title>
    <link href="http://luyaoming.com/2021/05/21/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/21/Primer-cpp-第五版读书笔记（四）/</id>
    <published>2021-05-21T00:18:18.000Z</published>
    <updated>2021-06-17T04:01:32.184Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的常用标准库 包括IO库和顺序容器</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<h2 id="八，IO库"><a href="#八，IO库" class="headerlink" title="八，IO库"></a>八，IO库</h2><p>前面学到过的表示io的关键词有 istream ostream cin cout cerr &gt;&gt; &lt;&lt; getline</p>
<p>以上是操作char类型数据的io 另外还有操作文件的fstream 操作字符串的sstream 如果是操作宽字符wchar_t的 在对应流前面加w 例如宽字符版本的cin cout是wcin wcout 宽字符版本的类型和对象与其对应的普通char版本类型定义在同一个头文件中 例如头文件 fstream中定义了ifstream 和 wifsteam</p>
<p>类似于java c++中的io流也使用继承来实现不同流之间的差异 例如ifstream和istringstream继承自istream 我们如何使用cin的 也就同样的方式使用这些对象</p>
<p>不能使用复制的方式来传递或拷贝io对象 例如 <code>ostream out1,out2;out1 = out2</code>是错误的 正确的方式是使用引用的方式来传递或返回流 而且他们不能是const的</p>
<p>IO的条件状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">strm::iostate <span class="comment">// strm是一种IO类型</span></span><br><span class="line">strm::badbit <span class="comment">// 流已崩溃 不可恢复的读写操作</span></span><br><span class="line">strm::failbit <span class="comment">// io操作失败</span></span><br><span class="line">strm::eofbit <span class="comment">// 流到达文件结束</span></span><br><span class="line">strm::goodbit <span class="comment">// 流未处于错误状态</span></span><br><span class="line">s.eof() <span class="comment">// 若流处于eofbit置位 返回true</span></span><br><span class="line">s.fail() <span class="comment">// 若流处于failbit or badbit状态 返回true</span></span><br><span class="line">s.good() <span class="comment">// 若流处于有效状态 返回true</span></span><br><span class="line">s.clear() <span class="comment">// 将流所有条件状态复位 返回void</span></span><br><span class="line">s.clear(flags) <span class="comment">// 将flags标志位复位 返回void</span></span><br><span class="line">s.setstate(flags) <span class="comment">//设置标志位</span></span><br><span class="line">s.rdstate() <span class="comment">//读取当前标志位</span></span><br></pre></td></tr></table></figure>
<p>判断一个输入流是否有效的最简单操作是<code>while(cin &gt;&gt; word){...}</code> 或者使用<code>!fail()</code> good或fail 是确定流的总体状态的正确方式</p>
<p>输出缓冲区</p>
<p>每个输出流都管理一个缓冲区 用来保存程序读写的数据 由于设备的写操作可能耗时 所以允许操作系统将多个输出操作组合成单一的的设备写操作来提升性能</p>
<p>下面这些方式可以让缓冲区刷新 即数据真正写到输出设备或文件中</p>
<ol>
<li>程序正常结束</li>
<li>缓冲区满了</li>
<li>使用操作符endl flush ends显式刷新缓冲区</li>
<li>使用操作符unitbuf设置流的内部状态来清空缓冲区 默认cerr是设置unitbuf的 即立即刷新</li>
<li>一个输出流被关联到另一个流 当读写被关联的流时 关联的流的缓冲区会被刷新</li>
</ol>
<p>注意 当程序发生崩溃时 输出缓冲区不会被刷新 他所输出的数据很可能停留在输出缓冲区中等待打印 所以我们需要确认那些你认为已经输出的数据确实已经刷新了 否则会花费大量时间在追踪代码为什么没有执行上</p>
<p>使用tie函数关联两个流 <code>cin.tie(&amp;cout)</code></p>
<p>文件的输入输出 下面是文件流的常用方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fstream fstrm;<span class="comment">//未绑定文件</span></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s)</span></span>;<span class="comment">//打开名为s的文件</span></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s,mode)</span></span>;<span class="comment">//指定mode模式打开文件</span></span><br><span class="line"></span><br><span class="line">fstrm.open(s);<span class="comment">//打开名为s的文件</span></span><br><span class="line">fstrm.close();<span class="comment">//关闭文件</span></span><br><span class="line">fstrm.is_open();<span class="comment">//文件是否已经打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件模式</span></span><br><span class="line">in 读方式</span><br><span class="line">out 写方式</span><br><span class="line">app 每次写操作都定位到文件末尾 追加</span><br><span class="line">ate 打开文件后立即定位到文件末尾</span><br><span class="line">trunc 截断文件</span><br><span class="line">binary 以二进制进行IO</span><br></pre></td></tr></table></figure>
<p>注意 不指定模式 默认情况下 打开一个ofstream 文件内容会被丢弃 如果增加app模式 则不会情况 写的内容变成追加</p>
<p>使用istringstream</p>
<p>比如有一个需求 从文件中录入一些人员信息 然后组建成对象输出 文件内容如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前面是人员名称 后面是电话号码(个人，家庭等电话号码)</span></span><br><span class="line">morgan <span class="number">201341345</span> <span class="number">987434463</span></span><br><span class="line">drew <span class="number">97674632</span></span><br><span class="line">lee <span class="number">6735548</span> <span class="number">98265524</span> <span class="number">89366263</span></span><br></pre></td></tr></table></figure>
<p>下面开始使用istringstream来对这些文本进行处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先创建一个类来封装这些人员数据</span></span><br><span class="line"><span class="keyword">struct</span> PersonInfo&#123;</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; phones;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来使用一个方法将这些文本数据转换成对象集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PersonInfo&gt; parseData()&#123;</span><br><span class="line">  <span class="built_in">string</span> line,word;</span><br><span class="line">  Vector&lt;PersonInfo&gt; people;</span><br><span class="line">  <span class="keyword">while</span>(getline(cin,line))&#123; <span class="comment">//遍历每行字符串 赋值给line</span></span><br><span class="line">    PersonInfo info;<span class="comment">//每行对应一个对象 先声明类型</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;<span class="comment">//创建istringstream对象record 使用line字符串直接构造该对象</span></span><br><span class="line">    record &gt;&gt; info.name;<span class="comment">// istringstream的操作符&gt;&gt;来自于basic_isteam的操作符&gt;&gt; 用法同熟悉的cin&gt;&gt;都是遇到空格结束 意思从record字符串输入流读取下一个空格前的字符串保存到info.name中</span></span><br><span class="line">    <span class="keyword">while</span>(record &gt;&gt; word)&#123;<span class="comment">//如法炮制 读取名字后面的号码 传入info对象的vector中</span></span><br><span class="line">      info.phones.push_back(word);<span class="comment">//顺序添加到末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    people.push_back(info);<span class="comment">//保存对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  return people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ostringstream 分别输出有效和无效的电话号码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry: people)&#123;</span><br><span class="line">  ostringsteam formatted,badNums;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums:entry.phones)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">      badNums &lt;&lt; <span class="string">" "</span> &lt;&lt; nums;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      formatted &lt;&lt; <span class="string">" "</span> &lt;&lt; format(nums);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(badNums.str().empty())&#123;</span><br><span class="line">    os &lt;&lt; entry.name &lt;&lt; <span class="string">" "</span> &lt;&lt; formatted.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"input err:"</span> &lt;&lt;entry.name &lt;&lt; <span class="string">"invalid nums "</span> &lt;&lt; badNums.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九，顺序容器"><a href="#九，顺序容器" class="headerlink" title="九，顺序容器"></a>九，顺序容器</h2><p>不同容器需要考虑以下的性能折中：</p>
<ol>
<li>向容器添加或删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ol>
<p>下面列举顺序容器的类型和特点</p>
<p>vector   可变大小数组 支持快速随机访问 在尾部之外的位置插入或删除元素可能很慢</p>
<p>deque   双端队列 支持快速随机访问 在头部尾部插入或删除数据很快</p>
<p>list        双向链表 只支持双向顺序访问 在list中任何位置进行插入删除操作速度很快 </p>
<p>forword_list 单向链表 只支持单向顺序访问 在链表任何位置进行插入删除操作速度很快</p>
<p>array    固定大小的数组 支持快速随机访问 不能添加或删除元素</p>
<p>string   与vector相似的容器 但专门用于保存字符 随机访问快 在尾部插入删除元素速度快</p>
<p>新标准的容器比旧版本的快得多 现代c++程序应该使用标准库容器  而非原始的数据结构如内置数组</p>
<p>在选择容器方面 有一些基本原则 其中一个是：除非你有很好的理由选择其他容器 否则应该使用vector  </p>
<p>如果程序中既需要随机访问元素 又需要在容器中间插入元素 选择容器时 就要看取决于在list或forward_list 中访问元素与vector 或deque中插入/删除元素的相对性能 看哪一种操作作主导地位 是访问元素的操作更多还是插入删除的操作更多 必要时需要对容器的选择做测试工作</p>
<p>容器都定义为模板类 以便提供信息给编译器是特定的容器的类型 参考之前的vector<double> 也有list<sales_data> 容器中包含容器也是常见的vector<vector<string>&gt; 如果容器内的元素类没有默认构造函数 那么创建一个容器初始化时需要制定元素类的初始化器 如<code>vector&lt;NoDefaultClass&gt; v1(10, init) ;</code></vector<string></sales_data></double></p>
<p>下面列举容器中常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line">iterator <span class="comment">// 迭代器</span></span><br><span class="line">const_iterator <span class="comment">//可以读取元素 但不能修改元素的迭代器</span></span><br><span class="line">size_type <span class="comment">//无符号整数类型 足够保存容器类型的大小</span></span><br><span class="line">difference_type <span class="comment">//带符号的整数类型 足够保存两个迭代器之间的距离</span></span><br><span class="line">value_type <span class="comment">//元素类型</span></span><br><span class="line">reference <span class="comment">//元素的左值类型 与value_type&amp;含义相同</span></span><br><span class="line">const_reference <span class="comment">//元素的const左值类型 即 const value_type&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">C c;</span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>; <span class="comment">//构造c2的拷贝c1</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b,e)</span></span>; <span class="comment">//构造c 将迭代器b和e的指定范围内元素拷贝到c</span></span><br><span class="line">C c&#123;a,b,d...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值与交换</span></span><br><span class="line">c1 = c2;<span class="comment">//把c1的元素替换为c2的元素</span></span><br><span class="line">c1 = &#123;a,b,c...&#125;</span><br><span class="line">a.swap(b);<span class="comment">//ab交换元素</span></span><br><span class="line">swap(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">c.size();</span><br><span class="line">c.max_size();</span><br><span class="line">c.empty(); <span class="comment">//是否有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加或删除元素</span></span><br><span class="line">c.insert(args); <span class="comment">//将args中的元素插入到c</span></span><br><span class="line">c.emplace(inits); <span class="comment">//使用inits构造c中的一个元素</span></span><br><span class="line">c.erase(args);<span class="comment">//删除c中args指定的元素</span></span><br><span class="line">c.clear(); <span class="comment">//删除c的所有元素 返回void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关系运算符</span></span><br><span class="line">== , != <span class="comment">//所有容器都支持</span></span><br><span class="line">&lt; &lt;= &gt; &gt;= <span class="comment">//除无序关联容器外 所有容器都支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">c.begin(), c.end() <span class="comment">//返回指向c的首元素和尾元素之后位置的迭代器</span></span><br><span class="line">c.cbegin(),c.cend() <span class="comment">//返回const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反向容器的额外成员 不支持forward_list</span></span><br><span class="line">reverse_iterator <span class="comment">//按逆序寻址元素的迭代器 使用递增元素符会得到上一个元素</span></span><br><span class="line">const_reverse_iterator <span class="comment">//不能修改的 按逆序寻址元素的迭代器</span></span><br><span class="line">c.rbegin(),c.rend() <span class="comment">//返回指向c的尾元素和首元素之前位置的迭代器</span></span><br><span class="line">c.crbegin(),c.crend()</span><br></pre></td></tr></table></figure>
<p>容器的迭代器</p>
<p>所有标准库的迭代器都支持递增运算符 从当前元素移动到下一个元素 有一个例外是forward_list 迭代器不支持递减运算符</p>
<p>使用迭代器 我们经常这样来遍历一个容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(begin != end)&#123;</span><br><span class="line">  *begin = val;</span><br><span class="line">  ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于拷贝元素 一般要求容器类别和元素类型一样才能拷贝 但是也有例外 如果当迭代器参数是迭代器范围时 拷贝过来的元素类型能转换成接纳元素的类型 而且容器的类型不一样 也是可以的 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"xiaohong"</span>,<span class="string">"xiaoming"</span>,<span class="string">"xiaoguang"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; list2(authors); <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; deque1(authors) <span class="comment">//错误 容器类型不匹配</span></span><br><span class="line">forword_list&lt;<span class="built_in">string</span>&gt; words(articles.begin(),articles.end());</span><br></pre></td></tr></table></figure>
<p>显式指定容器中的元素初始值<code>vector&lt;int&gt; v1(10,-1)</code> 包含10个元素 每个初始化为-1</p>
<p>array容器的初始化需要包含元素个数 例如<code>array&lt;int,10&gt; a1 = {42};</code> 指定了包含10个元素的array容器 指定了第一个元素的值为42 其他元素被默认初始为0</p>
<p>注意 不能对c++内置数组类型进行拷贝或对象赋值操作 但是array无此限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> digs[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cpy[<span class="number">10</span>] = digs;<span class="comment">// 错误 内置数组不支持拷贝或赋值</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; digits = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; copyArray = digits; <span class="comment">// 正确 数组类型和数量大小匹配即可</span></span><br></pre></td></tr></table></figure>
<p>assign允许将右边运算对象中的所有元素拷贝到左边运算对象中  接着上上面authors和articles的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">authors = articles;<span class="comment">//错误 容器类型不相同</span></span><br><span class="line">authors.assign(articles.begin(),articles.end());<span class="comment">//正确</span></span><br><span class="line">authors.assign(<span class="string">"what"</span>,<span class="number">10</span>);<span class="comment">//正确 全部赋值为what字符串</span></span><br></pre></td></tr></table></figure>
<p>swap 函数可以交换两个容器的元素 除array外 不对任何容器的元素进行拷贝删除或插入 因此可以保证在常数时间内完成 除了string容器外 交换后 容器的指针 引用迭代器也会跟着交换 array是正在交换两个容器 需要开辟新的内存空间 swap既有成员函数版本 也有非成员函数版本 泛型编程中常用非成员函数版本</p>
<p>容器的相等运算符实际是调用元素的相等运算符来实现比较的 所以如果元素不支持所需运算符 那么保存这种元素的容器就不能使用相应的运算符</p>
<p>向顺序容器中添加元素的操作包括（不包含array 他不支持）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.push_back(t);<span class="comment">//在尾部添加一个值为t或由args创建的元素 返回void</span></span><br><span class="line">c.emplace_back(args);</span><br><span class="line">c.push_front(t);<span class="comment">//在头部添加</span></span><br><span class="line">c.emplace_front(args);</span><br><span class="line">c.insert(p,t);<span class="comment">//在迭代器p指向的元素之前插入t 返回新添加的元素的迭代器</span></span><br><span class="line">c.emplace(p,n,t);<span class="comment">//在迭代器p指向的元素之前插入n个t 返回新添加的第一个元素的迭代器</span></span><br><span class="line">c.insert(p,b,e);<span class="comment">//将迭代器b和e指定范围内的元素插入到迭代器p指向的元素之前</span></span><br><span class="line">c.insert(p,i1);<span class="comment">//i1是一个花括号包围的元素值列表 将这些插入到迭代器p指向的元素之前</span></span><br></pre></td></tr></table></figure>
<p>向一个vector string deque插入元素会使所有指向容器的迭代器 引用 指针失效</p>
<p>emplace函数的神奇之处在于他接收一个参数列表 参数为元素的构造函数所需要的参数 例如一个Sales_data类型的容器使用emplace时 <code>c.emplace(&quot;978-231432&quot;,25,15.99)</code>里面的三个参数为Sales_data类的构造函数需要的参数</p>
<p>at函数和下标操作可适用于string vector deque array类型容器如 c.at(n) c[n] 代表容器内第n个元素 如果下标越界 会抛出out_of_range 异常 编译器不会检查是否越界要靠程序员</p>
<p>删除元素的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.pop_back();</span><br><span class="line">c.pop_front();</span><br><span class="line">c.erase(p);<span class="comment">//删除迭代器p所指向的元素 返回一个指向被删元素之后的元素的迭代器</span></span><br><span class="line">c.erase(b,e); <span class="comment">//删除迭代器b和e所指定范围内的元素</span></span><br><span class="line">c.clear();<span class="comment">//删除c中所有元素 等价于c.clear(c.begin(),c.end());</span></span><br></pre></td></tr></table></figure>
<p>使用resize改变容器的大小 但是只是改变元素的数目 并非容器的容量 也不能改变预留的内存空间大小  如果当前大小大于所要求的大小 容器后面的元素会被删除 如果当前大小小于新大小 会将新元素添加到容器后面 如果容器保存的是类类型 则必须提供默认构造函数 resize不适用与array 使用resize的vector string deque的迭代器指针和引用会失效</p>
<p>capacity函数可以获取容器的容量 对于vector来说每次扩展时的策略是分配新内存为当前容量的两倍</p>
<p>shrink_to_fit函数可以请求容器退还超出当前大小的多余内存给系统 但是标准库并不保证系统这么做</p>
<p>string也可以看做一个容器 下面是更多的string的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n len2 pos2都是无符号值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp,n)</span></span>;<span class="comment">// s是cp所指向的数组中的前n个元素的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2,pos2)</span></span>;<span class="comment">//s是string s2从下标pos2开始的字符的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2,pos2,len2)</span></span>;<span class="comment">//接上 共拷贝len2个</span></span><br><span class="line"></span><br><span class="line">s.substr(pos,n);<span class="comment">// 返回一个string 包含s中从pos开始的n个字符的拷贝</span></span><br><span class="line">s.insert(s.size(),<span class="number">5</span>,<span class="string">'!'</span>);<span class="comment">//从s末尾插入5个!</span></span><br><span class="line">s.erase(s.size()<span class="number">-5</span> ,<span class="number">5</span>);<span class="comment">//从s删除最后5个字符</span></span><br><span class="line">s.append(<span class="string">"adbc"</span>);<span class="comment">//在末尾追加adbc</span></span><br><span class="line">s.replace(<span class="number">11</span>,<span class="number">3</span>,<span class="string">"adc"</span>);<span class="comment">//从位置11开始删除3个字符并插入abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索操作 返回string::size_type 下标类型 string::npos表示搜索失败初始值-1</span></span><br><span class="line">s.find(args);<span class="comment">//查找s中args第一次出现的位置</span></span><br><span class="line">s.rfind(args);<span class="comment">//查找s中args最后一次一次出现的位置</span></span><br><span class="line">s.find_first_of(args);<span class="comment">//查找s中args中任何一个字符第一次出现的位置</span></span><br><span class="line">s.find_last_of(args);<span class="comment">//查找s中args中任何一个字符最后一次出现的位置</span></span><br><span class="line">s.find_first_not_of(args);<span class="comment">//查找s中第一个不在args中的字符</span></span><br><span class="line">s.find_last_not_of(args);<span class="comment">//查找s中最后一个不在args中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//compare比较函数 类似于c中strcmp函数</span></span><br><span class="line">s.compare(s2);<span class="comment">//根据等于 大于 小于 分别返回0 正数 负数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数值转换</span></span><br><span class="line"><span class="keyword">int</span> i= <span class="number">42</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(i);<span class="comment">//将整数i转换成字符串类型</span></span><br><span class="line"><span class="keyword">double</span> d = stod(s); <span class="comment">//把字符串s转换成double类型</span></span><br><span class="line">stoi(s,p,b);<span class="comment">//p是size_t指针用来保存s中第一个非数值字符的下标 默认为0即不保存下标</span></span><br><span class="line">stol(s,p,b);</span><br><span class="line">stoul(s,p,b);</span><br><span class="line">stoll(s,p,b);</span><br><span class="line">stoull(s,p,b);</span><br><span class="line">stof(s,p);</span><br><span class="line">stod(s,p);</span><br><span class="line">stold(s,p);</span><br></pre></td></tr></table></figure>
<p>容器适配器 标准库定义了三个顺序容器的适配器 stack queue priority_queue 适配器是一种机制</p>
<p>可使用除array forword_list之外的容器来构造stack 例如<code>stack&lt;int&gt; stk(deq)</code> stack常用的函数有pop push emplace top , stack是基于queue实现的</p>
<p>queue队列适配器是默认基于deque实现的 而priority_queue默认基于vector实现 但也可以基于deque实现 常用的函数有pop front back top push emplace</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的常用标准库 包括IO库和顺序容器&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（三）</title>
    <link href="http://luyaoming.com/2021/05/10/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/10/Primer-cpp-第五版读书笔记（三）/</id>
    <published>2021-05-10T09:47:55.000Z</published>
    <updated>2021-06-24T10:22:52.221Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的函数和类基础</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<h2 id="六，函数"><a href="#六，函数" class="headerlink" title="六，函数"></a>六，函数</h2><p>熟悉c的程序员常常会使用指针类型的形参访问函数外部的对象 在c++语言中 建议使用引用类型的形参代替指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">  *p = <span class="number">0</span>;<span class="comment">//改变了指针p所指对象的值</span></span><br><span class="line">  p = <span class="number">0</span>;<span class="comment">//只改变了p的局部拷贝 实参未被改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">reset(&amp;i);<span class="comment">//传递指针地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<p>传递引用形参代替指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">42</span>;</span><br><span class="line">reset(j);<span class="comment">// 传递引用 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<p>如果函数无需改变引用形参的值 最好将其声明为常量引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">  return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数形参数量未知 且类型相同时 可以使用initializer_list类型的形参 他是一种标准库类型 用于表示某种特定类型的数组 他的类型定义在同名的头文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst; <span class="comment">//默认初始化，T类型元素的空列表</span></span><br><span class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst&#123;a,b,c...&#125;;<span class="comment">//列表中的元素都是const</span></span><br><span class="line">lst.size();</span><br><span class="line">lst.begin();<span class="comment">//返回指向lst中的首元素的指针</span></span><br><span class="line">lst.end();</span><br></pre></td></tr></table></figure>
<p>省略型形参应该仅仅用于c和c++通用的类型，特别需要注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝 省略符形参只能出现在形参列表中的最后一个位置</p>
<p>函数不要返回局部对象的引用或指针 局部的引用在函数执行结束后内存将被释放掉 return将指向不再可用的内存空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> ret;</span><br><span class="line">  <span class="keyword">if</span>(!ret.empty())&#123;</span><br><span class="line">    return ret;<span class="comment">//错误 返回局部的对象的引用</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    return <span class="string">"something!"</span><span class="comment">//错误 这是一个布局临时变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数main可以没有return语句 编译器将隐式插入return 0;</p>
<p>因为数组不能被拷贝 所以函数不能返回数组 但是可以返回数组的指针和引用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">typedef int arrT[10];//arrT是一个类型别名 他表示的类型是含有10个整数的数组</span><br><span class="line">using arrT = int[10];//等价于上面的类型定义</span><br><span class="line">arrT *func(int i);//func是一个返回指向含有10个整数的数组的指针</span><br><span class="line"></span><br><span class="line">int arr[10]//arr是一个含有10个整数的数组</span><br><span class="line">int *p1[10]//p1是一个含有10个指针的数组</span><br><span class="line">int (*p2)[10] = &amp;arr;//p2是一个指针 他指向含有10个整数的数组</span><br><span class="line"></span><br><span class="line">int (*func(int i))[10];//返回数组指针的函数声明</span><br><span class="line">auto func(int i) -&gt; int(*)[10];//尾置返回类型 另一种方式返回数组指针</span><br></pre></td></tr></table></figure>
<p>const_cast 可以在常量引用和非常量引用之间自由转换</p>
<p>形参是常量引用还是非常量引用会影响函数的重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;<span class="comment">//新函数 作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;<span class="comment">//新函数 作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>
<p>c++允许函数内声明函数 当在内层作用域中声明了名字 他将隐藏外层作用域中声明的同名实体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;<span class="comment">//正确 重载print函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> read = <span class="literal">false</span>;<span class="comment">//新作用域 隐藏了外层的read</span></span><br><span class="line">  <span class="built_in">string</span> s = read();<span class="comment">//错误 read名字已经被重载从bool变量了 所以无法识别是函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//新作用域 声明并重载了一个新的print函数</span></span><br><span class="line">  print(<span class="string">"value1"</span>);<span class="comment">//错误 print函数已经被上面的函数重载掉 原来传递string引用的函数被隐藏掉了 </span></span><br><span class="line">  print(ival);<span class="comment">//正确 当前print(int)可见</span></span><br><span class="line">  print(<span class="number">3.14</span>);<span class="comment">//正确 但是调用的是print(int) print(double)被隐藏掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明函数时 可以提供参数默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>,sz wid = <span class="number">80</span>,<span class="keyword">char</span> backgrnd = <span class="string">' '</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>要注意 一旦某个形参被赋予了默认值 其他形参也必须有默认值</p>
<p>内联函数 在函数声明前加上inline修饰符 用于优化规模较小 流程直接 频繁调用的函数 可以避免函数调用的开销</p>
<p>constexpr函数 值用于常量表达式的函数 特点是返回值和形参都是字面值类型 constexpr函数被隐式地指定为内联函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;return <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br></pre></td></tr></table></figure>
<p>c++中也包含调试用的语句 断言assert 和 NDEBUG</p>
<p>assert是预处理宏 assert(expr)返回以一个bool值 条件为假则终止程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ cc -D NDEBUG main.cc <span class="comment">// 使用NDEBUG选项编译 相当于编译时就写了#define NDEBUG</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[] size_t size)</span></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">  	<span class="comment">//__func__是编译器定义的一个局部静态变量 用于存放函数的名字</span></span><br><span class="line">  	<span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">":array size is "</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了__func__外 c++编译器还定义了4个用于程序调试有用的名字</span></span><br><span class="line">__FILE__ <span class="comment">//存放文件名的字符串字面值</span></span><br><span class="line">__LINE__ <span class="comment">//存放当前行号的整型字面值</span></span><br><span class="line">__TIME__ <span class="comment">//存放文件编译时间的字符串字面值</span></span><br><span class="line">__DATE__ <span class="comment">//存放文件编译日期的字符串字面值</span></span><br></pre></td></tr></table></figure>
<p>函数指针</p>
<p>函数指针指的是指向函数的指针 是一个指针 而非函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">//声明一个指向该函数的指针</span></span><br><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"><span class="comment">//赋值 要有上面的声明 才能有这个赋值操作</span></span><br><span class="line">pf = lengthCompare; </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">pf = &amp;lengthCompare;</span><br><span class="line"><span class="comment">//使用时 下面三者等价</span></span><br><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>,<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>,<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(<span class="string">"hello"</span>,<span class="string">"world!"</span>);</span><br></pre></td></tr></table></figure>
<p>函数的形参可以定义成函数的指针 看起来是函数类型 实际上当作指针使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">void useBigger(const string &amp;s1,const string &amp;s2,bool pf(const string&amp; , const string&amp;));</span><br><span class="line"></span><br><span class="line">//有了上面的声明后 使用时直接传递函数名字 会自动将函数转换成指向函数的指针</span><br><span class="line">useBigger(s1,s2,lengthCompare);</span><br><span class="line"></span><br><span class="line">//使用上面的方式声明函数指针比较麻烦 使用typedef和decltype得到简化</span><br><span class="line">typedef bool(*FuncP) (const string&amp;,const string &amp;);</span><br><span class="line">typedef decltype(lengthCompare) *FuncP2</span><br><span class="line">  </span><br><span class="line">//使用上面声明的函数指针声明新的函数</span><br><span class="line">void useBigger(const string&amp; ,const string&amp;,FuncP);</span><br><span class="line">void useBigger(const string&amp; ,const string&amp;,FuncP2);</span><br></pre></td></tr></table></figure>
<p>要想一个函数返回函数指针 可以使用using关键字</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">using pf = int(*)(int*,int);//声明pf是一个函数指针</span><br><span class="line">pf f1(int);//f1函数返回了一个函数指针pf</span><br><span class="line"></span><br><span class="line">//也可以拼接上面两个语句成一句</span><br><span class="line">int (*f1(int))(int*,int);</span><br><span class="line">//也可以使用尾置返回类型的方式声明</span><br><span class="line">auto f1(int) -&gt; int(*)(int*,int);</span><br></pre></td></tr></table></figure>
<h2 id="七，类"><a href="#七，类" class="headerlink" title="七，类"></a>七，类</h2><p>定义一个返回this对象的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">  units_sold += rhs.units_sold;<span class="comment">// 把rhs的成员加到this对象的成员上</span></span><br><span class="line">  revenue += rhs.revenue;</span><br><span class="line">  return *<span class="keyword">this</span>; <span class="comment">//返回调用用该函数的对象 实际上需要返回Sales_data&amp;引用类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++的构造函数大体与java一样 没有返回类型 可以重载 不能声明成const 编译器为类定义默认的构造函数</p>
<p>有时候编译器不能生成默认构造函数 其中一个原因是 类中包含的成员的类型 没有默认构造函数</p>
<p>在c++新标准中 如果我们需要默认的行为 可以通过在参数列表后面写上 = default来要求编译器生成构造函数</p>
<p>构造函数初始值列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s)&#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">					bookNo(s), units_sold(n),revenue(p*n) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面其中<code>bookNo(s), units_sold(n),revenue(p*n)</code>就是代表构造函数初始值列表 对类成员函数进行初始化  如果没有对units_sold 和revenue进行显式初始化 他将以合成默认构造函数相同的方式隐式初始化 例如这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s):bookNo(s),units_sold(<span class="number">0</span>),revenue(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数不应该轻易覆盖掉类内的初始值 除非新赋的值与原值不同 如果你不能使用类内初始值 则所有构造函数都应该显式地初始化每个内置类型的成员</p>
<p>与其他函数一样 构造函数也允许在类外定义  定义时需要加上命名空间Sale_data::</p>
<p>使用class或者struct都可以用来定义类 他们的区别在 默认的访问权限 定义在第一个访问说明符之前的成员是public的 使用struct 定义在第一个访问说明符之前的成员是private的 使用class</p>
<p>与java不同的是 c++中 类可以允许其他类或者函数访问他的非公有成员 方法是令其他类或者函数成为他的友元friend 使用friend关键字 如上面描述的在第一个访问说明符之前的成员默认是private</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_data&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;,<span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;,Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::osteam&amp;,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  		Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">  		Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>:<span class="built_in">string</span> &amp;s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">  							bookNo(s),units_sold(n),revenue(p*n) &#123;&#125;</span><br><span class="line">  		Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s):bookNo(s)&#123;&#125;</span><br><span class="line">  		Sales_data(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">  		<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;return bookNo;&#125;</span><br><span class="line">  		<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  		<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">  		<span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外的Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;,<span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;,Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::osteam&amp;,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般来说 最好在类定义开始或者结束前的位置集中声明友元</p>
<p>const成员函数 表明这个函数不会对这个类对象的数据成员作任何改变 在设计类的时候 一个原则就是 对于不改变数据成员的成员函数都要在后面加 const 而对于改变数据成员的成员函数不能加 const 所以 const 关键字对成员函数的行为作了更加明确的限定：</p>
<p>1）有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内） 只能读取数据成员 不能改变数据成员 没有 const 修饰的成员函数 对数据成员则是可读可写的</p>
<p>2）除此之外 在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数 而不能调用非const修饰的函数 非常量对象既可以调用const成员函数也可以调用非const成员函数</p>
<p>值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Name &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">   			 <span class="keyword">char</span> *m_sName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    		m_sName = s.c_str();      <span class="comment">// 错误！不能修改m_sName;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) </span><br><span class="line">   			m_sName[i] = s[i];    <span class="comment">// 不好的风格，但不是错误的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const成员函数可以被对应的具有相同形参列表的非const成员函数重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">			<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">			<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="keyword">const</span></span>;<span class="comment">//常量特性不一样 允许重载</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Screen cs;Screen cc2; </span><br><span class="line">  <span class="keyword">char</span> ch = cs.get(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 调用const成员函数  </span></span><br><span class="line">  ch = cs2.get(<span class="number">0</span>, <span class="number">0</span>);     <span class="comment">// 调用非const成员函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变数据成员mutable</p>
<p>上面的const成员函数阻止我们修改成员变量 但是使用mutable修饰符可以突破</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;<span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Screen::some_member() <span class="keyword">const</span>&#123;</span><br><span class="line">  ++access_ctr;<span class="comment">//使用mutable修饰符突破了限值 他就是可变数据成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个const成员函数如果以引用的形式返回*this 那么他的返回类型将是常量引用</p>
<p>委托构造函数</p>
<p>有点类似于java的调用重载构造函数来初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Slaes_data&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  		Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s,<span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):</span><br><span class="line">  						bookNo(s),units_sold(cnt),revenue(cnt*price)&#123;&#125;</span><br><span class="line">  		Sales_data():Sales_data(<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  		Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s):Sales_data(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  		Sales_data(<span class="built_in">std</span>::istream &amp;is):Sales_data()&#123;read(is,*<span class="keyword">this</span>)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只有第一个是使用实参来构造 其他都是委托构造函数 调用其他重载的构造函数</p>
<p>隐式的类类型转换 如果构造函数只接受一个实参 则他实际上定义了转换为此类类型的隐式转换机制 例如上面的代码将接收string和istream转换成Sales_data类型 那么在使用到Sales_data的地方 可以直接使用string和istream代替Sales_data</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book=<span class="string">"9-99999-99-9"</span>;</span><br><span class="line">item.combine(null_book);<span class="comment">//combine函数本身是期待接受一个Sales_data的实参 但是由于存在只传递一个string的构造函数 所以隐式地调用了该构造函数来调用该方法</span></span><br><span class="line"></span><br><span class="line">item.combine(<span class="string">"9-99999-99-9"</span>);<span class="comment">//但是这种方式错误 隐式转换只能是同时间使用一种转换规则 这里是连续使用了两种 1是把"9-99999-99-9"转换成string 2是string转换成Sales_data</span></span><br><span class="line"></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"9-99999-99-9"</span>));<span class="comment">//正确</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"9-99999-99-9"</span>));<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>使用explicit关键字可以阻止或抑制上述的隐式转换类型 这样的构造函数叫显式构造函数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//构造函数</span><br><span class="line">explicit Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;</span><br><span class="line">explicit Sales_data(std::istream&amp;);</span><br><span class="line"></span><br><span class="line">item.combine(null_book);//错误 传递string的构造函数是explicit的</span><br><span class="line">item.combine(cin);//错误 传递istream的构造函数是explicit的</span><br><span class="line">item.combine(Sales_data(null_book));//正确 这是显式调用构造</span><br><span class="line">item.combine(static_cast&lt;Sales_data&gt;(cin));//正确 static_cast可以使用explicit的构造函数</span><br></pre></td></tr></table></figure>
<p>聚合类</p>
<p>这种类格式比较简单 用户可以直接访问他的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Data&#123;</span><br><span class="line">  <span class="keyword">int</span> ival;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他所有成员都是public的 他没有定义任何构造函数 没有类内初始值 没有基类</p>
<p>调用时可以直接这样<code>Data val1 = {0,&quot;sss&quot;}</code> 顺序必须要与声明的顺序一致</p>
<p>类的静态成员 static</p>
<p>与java类似 静态成员属于类 而不属于类对象 可以是public的也可以是private的 静态方法只能包含静态成员变量 不包含this指针 静态成员函数不能声明为const的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Account&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  		<span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;amount+= amount * interestRate;&#125;</span><br><span class="line">  		<span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;return interestRate;&#125;</span><br><span class="line">  		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  		<span class="built_in">std</span>::<span class="built_in">string</span> owner;</span><br><span class="line">  		<span class="keyword">double</span> amount;</span><br><span class="line">  		<span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">  		<span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用作用域运算符可以直接访问静态成员<code>double r = Account::rate();</code></p>
<p>当然也可以直接使用对象来调用静态函数<code>Account ac1; r = ac1.rate();</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的函数和类基础&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（二）</title>
    <link href="http://luyaoming.com/2021/05/08/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/08/Primer-cpp-第五版读书笔记（二）/</id>
    <published>2021-05-08T02:21:21.000Z</published>
    <updated>2021-06-17T04:01:14.188Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的字符串向量和数组 表达式和语句</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<p>## </p>
<h2 id="三，字符串、-向量和数组"><a href="#三，字符串、-向量和数组" class="headerlink" title="三，字符串、 向量和数组"></a>三，字符串、 向量和数组</h2><p>前面讲到使用库函数时 c++需要标明命名空间 </p>
<p>利用using关键字 可以一次声明后 后面的使用中不再标明命名空间 类似于java的import</p>
<p>格式为<code>using namespace::name;</code> 例如声明之前我们经常用到的输入输出cin</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; i;<span class="comment">//正确</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i;<span class="comment">//错误 未声明cout 还不能这么用</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;<span class="comment">//正确</span></span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using关键字不仅可以命名类型别名 也充当声明命名空间变量作用</p>
<p>注意 头文件中不应该包含using 关键字 因为头文件被多个文件引用 使用using可能会导致始料未及的名字冲突</p>
<p>定义和初始化string对象</p>
<p>初始化string对象的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1; <span class="comment">//使用= 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;<span class="comment">//使用() 直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"value"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(<span class="number">3</span>,<span class="string">'c'</span>)</span> <span class="comment">//s5的值为字符串ccc</span></span></span><br></pre></td></tr></table></figure>
<p>string的常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">os &lt;&lt; s <span class="comment">//把s写到输出流os中 返回os</span></span><br><span class="line">is &gt;&gt; s <span class="comment">//从is中读取字符串赋给s 字符串以空白分隔 返回is</span></span><br><span class="line">getline(is , s) <span class="comment">//从is中读取一行赋值给s 返回is</span></span><br><span class="line">s.empty() <span class="comment">//判断s是否为空</span></span><br><span class="line">s.size() <span class="comment">//返回s中字符个数</span></span><br><span class="line">s[n] <span class="comment">//返回s中第n个字符的引用 n从0开始</span></span><br><span class="line">s1+s2 <span class="comment">//拼接字符串</span></span><br><span class="line">s1=s2 <span class="comment">//替换字符串</span></span><br><span class="line">s1==s2 <span class="comment">//判断字符串的字符是否完全一样 则相等</span></span><br><span class="line">s1!=s2 <span class="comment">//判断不等 对字母大小写敏感</span></span><br><span class="line">&lt; ,&gt; , &lt;=, &gt;= <span class="comment">//比较字符串 利用字符在字典中顺序 对大小写敏感</span></span><br></pre></td></tr></table></figure>
<p>string的size函数返回size_type类型 这个类型在string中定义了 很明显他是一个无符号的类型 使用string::size_type来 标记这个类型 主要不要使用size函数的返回值直接与int类型的值进行运算 因为前者属于无符号类型 直接与带符号类型的值运算 会让带符号类型的负值转换成一个比较大的无符号值参与运算 最终得到意料之外的结果</p>
<p>使用+进行拼接字符串时 注意<code>string s =&quot;hello &quot;+&quot;world!&quot;</code>的方式是错误的 不能直接将两个字符串字面值相加 为了兼容c 字符串字面值和string对象是不同的类型 +运算符允许字符串字面值和string对象相加 <code>string s = &quot;hello &quot;+s1</code> 这样是合法的</p>
<p>cctype头文件中声明了以下函数可以单独处理string对象中的字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isalnum</span>(c)</span><br><span class="line"><span class="built_in">isalpha</span>(c)</span><br><span class="line"><span class="built_in">iscntrl</span>(c) <span class="comment">//是否是控制字符</span></span><br><span class="line"><span class="built_in">isdigit</span>(c) <span class="comment">//是否是数字</span></span><br><span class="line"><span class="built_in">isgraph</span>(c) <span class="comment">//是否不是空格并可打印</span></span><br><span class="line"><span class="built_in">islower</span>(c) </span><br><span class="line"><span class="built_in">isprint</span>(c)</span><br><span class="line"><span class="built_in">ispunct</span>(c) <span class="comment">//是否标点</span></span><br><span class="line"><span class="built_in">isspace</span>(c)</span><br><span class="line"><span class="built_in">isupper</span>(c)</span><br><span class="line"><span class="built_in">isxdigit</span>(c) <span class="comment">//是否十六进制数字</span></span><br><span class="line"><span class="built_in">tolower</span>(c) <span class="comment">//输出小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c) <span class="comment">//输出大写</span></span><br></pre></td></tr></table></figure>
<p>使用for循环处理字符串的值 例如小写转大写 并输出到cout</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"Hello world!"</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s1)&#123;</span><br><span class="line">      c = <span class="built_in">toupper</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>容器vector是模板而非类型</p>
<p>在使用vector之前 先要引入vector标准库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;<span class="built_in">vector</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>初始化vector集合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(ivec) ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; article = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>,<span class="string">"c"</span>);<span class="comment">//</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>,<span class="number">-1</span>); <span class="comment">//10个int类型的元素 每个都被初始化-1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(<span class="number">10</span>); <span class="comment">//初始化10个元素的vector 元素的初始值默认都为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3&#123;<span class="number">10</span>&#125;;<span class="comment">//初始化有一个元素10的vector</span></span><br></pre></td></tr></table></figure>
<p>vector使用push_back函数添加元素</p>
<p>注意不能使用for循环改变容器本身的大小 包括增加或删除元素 应该使用迭代器</p>
<p>下面罗列下vector的主要函数和运算符 与string相类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">v.empty();</span><br><span class="line">v.size();</span><br><span class="line">v.push_back(t);</span><br><span class="line">v[n]</span><br><span class="line">v1 == v2</span><br><span class="line">v1 = &#123;a,b,c&#125;</span><br><span class="line">v1 = v2</span><br><span class="line">v1 != v2</span><br><span class="line">&lt;, &lt;=, &gt;,&gt;=</span><br></pre></td></tr></table></figure>
<p>vector的 下标从0开始 也是相应的size_type类型 vector是有序的 通过下标可以直接访问里面的元素 注意 下标运算符只能用作访问已经存在的元素 不能用于添加元素</p>
<p>迭代器 string和vector都可以使用迭代器 下面是迭代器常用的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*iter  <span class="comment">//返回迭代器iter所指元素的引用</span></span><br><span class="line">iter-&gt;mem <span class="comment">//解引用iter并获取该元素的名为mem的成员等价于(*iter).mem</span></span><br><span class="line">++iter  <span class="comment">//令iter指向容器中的下一个元素</span></span><br><span class="line">--iter <span class="comment">//令iter指向容器中的上一个元素</span></span><br><span class="line">iter1 == iter2 <span class="comment">//判断两个迭代器是否相等</span></span><br></pre></td></tr></table></figure>
<p>下面的代码修改字符串的首个字母为大写字母</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.begin()!=s.end())&#123; <span class="comment">//确保s非空</span></span><br><span class="line">  <span class="keyword">auto</span> it = s.begin();</span><br><span class="line">  *it = <span class="built_in">toupper</span>(*it); <span class="comment">//通过迭代器修改首个字母为大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数cbegin和cend 与函数begin和end功能类似 不同的是cbegin的返回值是const_iterator 常量迭代器</p>
<p>迭代器结合解引用和成员访问操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v&#123;<span class="string">"hello"</span>,<span class="string">"world"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = v.begin();<span class="comment">//it作为指向第一个元素的迭代器</span></span><br><span class="line">(*it).isempty(); <span class="comment">//检查迭代器所指字符串是否为空字符串 括号必不可少</span></span><br></pre></td></tr></table></figure>
<p>为了简化以上写法 定义了箭头运算符-&gt;来把解引用和访问结合在一起 也就是说使用it-&gt;item 和(*it).item表达的意思一样</p>
<p>除了使用++iter –iter方式来进行迭代器运算外 还可以使用iter +n 使迭代器往前挪n步 两个迭代器相减可以得到他们的距离</p>
<p>数组</p>
<p>数组与vector相类似都是集合 但是数组的大小确定不变 不能随意增加元素 相对于vector 数组的运行性能更好 同时损失了一些灵活性</p>
<p>定义数组必须制定数组的类型 不允许使用auto关键字来推断类型 不存在引用的数组 因为数组的元素都是对象 引用不是对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//正确 虽然未指定数组的维度 但是可以推断出是3</span></span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//正确 等价于a2[5] = &#123;1，2，3，0，0&#125;；</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//错误 超出范围</span></span><br><span class="line"><span class="keyword">int</span> a4[] = a;<span class="comment">//错误 不允许对数组进行拷贝或使用另一个数组初始化</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs是含有10个整形指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=a;<span class="comment">//错误 不存在引用元素的数组</span></span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">10</span>] = &amp;a;<span class="comment">//正确 pa是一个指针 他指向了一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;ra)[<span class="number">10</span>] = a;<span class="comment">//正确 ra是一个引用 他引用了一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<p>解读以上复杂类型修饰符时 遵循从内到外 从右到左的顺序方式</p>
<p>指针和数组 </p>
<p>数组的名字在表达式中会直接转化成第一个元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"!"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">string</span> *p2 = nums; <span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<p>数组也是迭代器 接上面的代码 p2++ 表示p2指向下一个元素nums[1] begin和end函数同样适用于数组 由于数组不是类类型 所以这两个函数不属于成员函数 他们属于标准库函数 定义在iterator头文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = begin(a);<span class="comment">//beg是指向a的第一个元素的指针</span></span><br><span class="line"><span class="keyword">int</span> *last = end(a);<span class="comment">//last是指向a的尾部元素的下一个位置的指针</span></span><br><span class="line"><span class="keyword">auto</span> n = end(a) - beg(a);<span class="comment">// n是一种ptrdff_t的标准库类型 可能为负值</span></span><br><span class="line"><span class="keyword">int</span> last2 = *(a+<span class="number">1</span>);<span class="comment">//正确 得到的结果是a[1] = 2</span></span><br><span class="line"><span class="keyword">int</span> last3 = *a+<span class="number">1</span>;<span class="comment">//正确 得到的结果是a[0]+4 = 1+4 = 5</span></span><br></pre></td></tr></table></figure>
<p>数组的下标运算符所用的索引值不是无符号类型 这点与vector和string不一样 即允许负数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">2</span>]; <span class="comment">//p指针指向a的第三个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];<span class="comment">//p指针往后退两步 k表示a[0]的元素</span></span><br></pre></td></tr></table></figure>
<p>允许使用数组初始化vector集合 但是不允许使用vector初始化数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(begin(a),end(a));<span class="comment">//使用数组的首尾指针来初始化vector集合</span></span><br></pre></td></tr></table></figure>
<p>建议：现代的c++程序应当尽量使用vector和迭代器 避免使用内置数组和指针 尽量使用string 避免使用c风格的基于数组的字符串</p>
<p>多维数组</p>
<p>严格来说 c++没有多维数组 通常所说的多维数组其实是数组的数组 </p>
<p>当一个数组的元素仍然是数组时通常使用两个维度来定义它：一个维度表示数组本身的大小 另外一个维度代表元素的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] <span class="comment">//大小为3的数组 每个元素含有4个整数</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] <span class="comment">//大小为10的数组 每个元素有20个数组 这些数组里又有30个元素</span></span><br></pre></td></tr></table></figure>
<p>初始化多维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] =&#123;</span><br><span class="line">  &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">  &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;<span class="comment">//逐个初始化每行每列的元素</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;<span class="comment">//初始化每行的首元素 未列出的元素执行默认值初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;<span class="comment">//仅初始化了第一行的元素 其他元素初始化为0</span></span><br></pre></td></tr></table></figure>
<p>使用for循环遍历多维数组元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用行数和列数初始化二维数组</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span> , colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i &lt; rowCnt;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>;j&lt;colCnt;j++)&#123;</span><br><span class="line">    a[i][j] = i * colCnt + j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用范围for语句遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : a)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> col : row)&#123;</span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="comment">//注意 row前面是转化成引用 如果直接使用row 将会在下个for循环中转换成数组首元素</span></span><br></pre></td></tr></table></figure>
<h2 id="四，表达式"><a href="#四，表达式" class="headerlink" title="四，表达式"></a>四，表达式</h2><p>成员访问运算符</p>
<p>点运算符和箭头运算符都可以用来访问成员 点运算符获取类对象的一个成员 箭头运算符与点运算符有关 表达式ptr-&gt;mem 等价于  (*ptr).mem 解引用运算符优先级低于点运算符 所以指针前的括号必不可缺</p>
<p>sizeof</p>
<p>sizeof运算符返回一个表达式或一个类型名字所占的字节数 可以使用下面两种方式</p>
<p>sizeof(type)</p>
<p>sizeof expr</p>
<p>sizeof并不会实际计算对象的值 sizeof *p 是正确的 就算p没有被赋值 也能知道p指针的大小</p>
<p>隐式类型转换 都是小类型往大类型转化 如double + int  那么结果会先将int转为double再运算</p>
<p>强制类型转换 static_cast</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j);<span class="comment">//一般大数向小数转换 不计较精度损失</span></span><br><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p); <span class="comment">//将void*转换会初始的指针类型</span></span><br></pre></td></tr></table></figure>
<p>常量类型转换为非常量类型 const_cast 常常用于函数重载的上下文中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pr;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pr);<span class="comment">//去掉底层const</span></span><br></pre></td></tr></table></figure>
<p>两个冒号的::的运算符优先级最高 属于左结合律</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::name <span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">class</span>::name <span class="comment">//类作用域</span></span><br><span class="line"><span class="keyword">namespace</span>::name<span class="comment">// 命名空间作用域</span></span><br></pre></td></tr></table></figure>
<h2 id="五，语句"><a href="#五，语句" class="headerlink" title="五，语句"></a>五，语句</h2><p>c++中的while for do while语句 if switch条件分支结构  continue语句 break语句 goto语句 try catch异常捕捉 throw语句 return语句 与java一样 可以无缝转换理解</p>
<p>略</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的字符串向量和数组 表达式和语句&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Primer cpp 第五版读书笔记（一）</title>
    <link href="http://luyaoming.com/2021/05/06/Primer-cpp-%E7%AC%AC%E4%BA%94%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/05/06/Primer-cpp-第五版读书笔记（一）/</id>
    <published>2021-05-06T01:20:22.000Z</published>
    <updated>2021-06-17T04:01:57.315Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录c++的由来和基本类型的使用</p>
<a id="more"></a>
<blockquote>
<p>Primer c++ 第五版 <br>原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo <br>翻译：王刚 杨巨峰 <br>– –读书笔记 by asii</p>
</blockquote>
<h2 id="一，引子"><a href="#一，引子" class="headerlink" title="一，引子"></a>一，引子</h2><p>十几年来编程语言的竞争 除却实现质量之外 基本上是比拼抽象的设计</p>
<p>c语言之所以四十年长盛不衰 根本在于他对于现代计算机提供了一个底层的高级抽象：凡是比他低的抽象都过于简陋 凡是比他高的抽象都可以用c语言构造出来</p>
<p>c++语言成功的根本原因在c的基础上提供一些高级的抽象机制 如果要走下去与硬件对话 c++成为除c之外唯一有效率的选择</p>
<p>c++可支持多种编程风格：c风格 基于对象 面向对象和泛型 微软的基于组件</p>
<p>c++11对于c++98来说 是一次本质的跃升</p>
<p>每个具体的领域 只需要读4 5本书就够入门了 要掌握c++11 可以读以下4本书</p>
<p>《c++标准程序库》《Effective C++》《Linux多线程服务端编程》 本作</p>
<h2 id="二，开始"><a href="#二，开始" class="headerlink" title="二，开始"></a>二，开始</h2><p>unix环境下使用GNU编译器简单编译个c++文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -o prog1 prog1.cc</span><br></pre></td></tr></table></figure>
<p>c++使用标准库iosteam来处理输入输出 共4个io对象 cin cout cerr clog</p>
<p>下面程序简单描述输入两个数并输出他们的和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two numbers:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of"</span> &lt;&lt; v1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std是指命名空间  cin cout endl这些是对象名称 必须命名在命名空间内 命名空间是为了避免名字定义冲突而来  :: 是作用域运算符</p>
<p>切勿混用带符号类型和无符号类型 当带符号类型取值为负时会出现异常结果 因为带符号类型会自动转换成无符号类型参与运算 例如一个a*b的表达式 当a = -1 ，b = 1时，当两者都为带符号int时 可以达到-1 但是当b为 unsigned int时 得到的结果不会是-1 结果视当前机器上int所占位数而定</p>
<p>列表初始化 c++11标准下 可使用下面的方式来初始化一个int值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与java一样 c++允许非显示地初始化一个变量 例如int sold;  或 sample item; 但与java不同的是：编译器不会指定其默认值 即值为未定义 是一个不确定的值 其值由类确定 这种方式在编写代码时不会报错 但是如果没有赋值而直接使用将会引发不确定的效果 这一点让我们想起c中在使用一个变量时需要先对其进行声明 而声明时是不需要赋值的 未申请内存空间的 c++中声明一个变量使用extern关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i 而非定义i</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">// 声明并且定义i</span></span><br></pre></td></tr></table></figure>
<p>变量能且能被定义一次 但是可以被多次声明 变量的定义必须出现在且只能出现在同一个文件中 而其他用到该变量的文件必须对其进行声明 却绝对不能重复定义</p>
<p>如果函数有可能用到某个全局变量 则不宜再定义一个同名的局部变量</p>
<p>当在函数内部想强制引用外部定义的全部变量时 可以使用::变量名来表示</p>
<p>c++中引用 左值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refi = i;<span class="comment">//正确 refi引用指向i 即是变量i的另一个名字</span></span><br><span class="line"><span class="keyword">int</span> &amp;refi;<span class="comment">//报错 引用必须被初始化</span></span><br></pre></td></tr></table></figure>
<p>定义引用时 程序把引用和他的初始化值绑定在一起 而不是将初始化值拷贝给引用</p>
<p>引用即别名 并非对象 他只是一个已经存在的对象所起的另外一个名字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">refi = <span class="number">2</span>；<span class="comment">//正确 把2赋值给refi指向的对象 此处即把值赋给了i</span></span><br><span class="line"><span class="keyword">int</span> j = refi;<span class="comment">//正确 与执行j = i执行结果一样</span></span><br></pre></td></tr></table></figure>
<p>为引用赋值 实际是将值赋给了与引用绑定的对象上 获取引用的值 实际是获取了与引用绑定的对象的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refj = refi;<span class="comment">//正确 refj绑定到了与refi绑定的对象上，实际是绑定到i上</span></span><br><span class="line"><span class="keyword">int</span> i = refi;<span class="comment">//正确 i被重新初始化成refi的值</span></span><br></pre></td></tr></table></figure>
<p>将引用作为初始值 实际是以引用绑定的对象作为初始值 </p>
<p>因为引用本身不是一个对象 所以不能定义引用的引用</p>
<p>引用标记符定义时必须以&amp;开头 引用不能与字面值绑定在一起</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refi = <span class="number">10</span>; <span class="comment">//错误 引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.2</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;refj = d; <span class="comment">//错误 引用类型的初始值必须与对象类型一致</span></span><br></pre></td></tr></table></figure>
<p>c++中指针 复合类型</p>
<p>指针实现了对其他对象的间接访问 指针和引用有很多不同点 指针本身就是一个对象 允许对指针赋值和拷贝 而且可以在指针的生命周期内先后指向几个不同的对象 指针无需再定义时赋初始值 这时候他的值并不确定 使用 *d来表示一个指针  d为变量名</p>
<p>指针存放某个对象的地址 要想获取地址 需要使用取值运算符&amp;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;<span class="comment">//声明并初始化了指针p 存放了i的地址 p就是指向i的指针</span></span><br><span class="line"><span class="keyword">int</span> *q = p;<span class="comment">//正确 </span></span><br><span class="line"><span class="keyword">double</span> *m = p; <span class="comment">//错误 类型不匹配</span></span><br><span class="line">m = &amp;i；<span class="comment">//错误 类型不匹配</span></span><br></pre></td></tr></table></figure>
<p>指针值有以下4种状态：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针 意味着指针没有指向任何对象</li>
<li>无效指针 也就是上述情况外的其他值</li>
</ol>
<p>试图拷贝或以其他方式访问无效指针的值将会引发错误 这点与试图使用未初始化的变量是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">//其中*是解引用符 输出1</span></span><br><span class="line">*p = <span class="number">0</span>;<span class="comment">//正确 改变指针指向的变量的值 将i的值改为0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<p>注意 解引用符号仅适用于那些确定了指向某个对象的有效指针</p>
<p>像&amp;和*这样的符号 既能作为表达式里的运算符也能作为声明的一部分组成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">//&amp;紧接着类型名出现是声明的一部分 r是一个引用</span></span><br><span class="line"><span class="keyword">int</span> *p;<span class="comment">// 其中*紧接着类型名出现是声明的一部分 p是一个指针</span></span><br><span class="line">p = &amp;i;<span class="comment">//这里&amp;是一个取值运算符</span></span><br><span class="line">*p = i;<span class="comment">//非声明 这是一个表达式 所以*表示解引用符</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = *p; <span class="comment">//&amp;是声明的一部分 r2是引用 *是表达式里的一部分表示解引用符</span></span><br></pre></td></tr></table></figure>
<p>空指针nullptr</p>
<p>空指针不指向任何对象 在试图使用一个指针之前代码应该先检查他是否为空</p>
<p>以下几种方式可以生成空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">//等价于int *p = 0；</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">//直接将p2初始化为字面值 常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">//需要首先#include cstdlib  是一个预编译变量等价于int *p3=0</span></span><br></pre></td></tr></table></figure>
<p>在c++11新标准下 最好使用nullptr 避免使用NULL </p>
<p>把变量直接赋值给指针是错误的操作 即使变量的值恰好是0也不行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = i; <span class="comment">//错误 不能把变量直接赋值给指针 但可以使用 *p = i;</span></span><br></pre></td></tr></table></figure>
<p>赋值和指针</p>
<p>引用和指针最大的不同点是 引用不是对象 一旦定义了引用 他就无法再绑定到另外的对象上 之后每次访问都是最初绑定的那个对象 但是指针没有这个限制 他可以随时改变指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>; <span class="comment">//p被初始化 没有指向空指针 没有指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;i;<span class="comment">// 指向i 保存了i的地址</span></span><br><span class="line"><span class="keyword">int</span> *p3; <span class="comment">//指针指向未定义 p3值无法确定</span></span><br><span class="line">p3 = p2;<span class="comment">// p3指向的对象和p2指向的对象是同一个 指针之间可以直接相互赋值</span></span><br><span class="line">p2 = <span class="number">0</span>; <span class="comment">// p2不再指向任何对象 成为空指针</span></span><br></pre></td></tr></table></figure>
<p>有时候 无法搞清楚一条赋值语句到底是改变了指针的值还是改变了指针指向对象的值 最好的办法是记住：赋值永远改变的是符号左侧的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = &amp;i; <span class="comment">//改变的是p的值 p指向了i变量所在的地址 指针地址改变</span></span><br><span class="line">*p = <span class="number">0</span>;<span class="comment">//改变的是p指向的值 指针p的指向并没有改变 即指针地址未改变</span></span><br></pre></td></tr></table></figure>
<p>void*指针</p>
<p>void*指针是一种特殊的指针变量 可用于存放任意对象的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *p = &amp;obj;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj;<span class="comment">//obj可以是任意类型的对象</span></span><br><span class="line">pv = p; <span class="comment">//pv可以存放任意类型的指针</span></span><br></pre></td></tr></table></figure>
<p>关于指针 <code>int* p 和 int *p</code> 两种写法都可以 一般习惯于后者的写法</p>
<p>指向指针的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;p; <span class="comment">//ppi就是指向int型指针的指针</span></span><br></pre></td></tr></table></figure>
<p>引用并非对象 所以不能使用指针指向引用 但是指针是对象 所以存在指向指针的引用</p>
<p>面对一条复杂的指针或引用的声明语句时 从右往左阅读有助于弄清楚他的真实含义</p>
<p>指向指针的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是一个队指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; <span class="comment">//r引用了一个指针 给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i 也就是p指向的对象 将i的值改为0</span></span><br></pre></td></tr></table></figure>
<p>在方法传递参数时 可以传递值 引用和指针 要注意c++是值传递的 传递的值被拷贝成局部变量在方法内参与运算 退出方法后实际上不会改变具体的值 而传递指针和引用时 实际上传递的是地址 在方法内参与运算时会改变指向地址的实际的值 地址是不会变的但是他指向的值可以改变 按实际需求使用三种方式传递</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>,b =<span class="number">20</span>;</span><br><span class="line"><span class="comment">//按值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按指针传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出20 10 交换成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出20 10 交换成功</span></span><br></pre></td></tr></table></figure>
<p>使用哪种方式传递 需要按照实际需求 只需要记住一些规则：</p>
<ol>
<li>引用需要初始化 指针和值可以没有初始化</li>
<li>引用经过初始化后不能成为另一个对象的引用 指针可以随意改变指向</li>
<li>引用不存在空引用 指针可以为空指针 应用时需要检查 引用更安全</li>
</ol>
<p>const限定符</p>
<p>使用const声明的变量 值不能被改变 所以声明时需要同时定义值 类似于java的final</p>
<p>在对const声明的变量进行定义时 允许使用变量而非常量表达式来定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br></pre></td></tr></table></figure>
<p>第一次接触const时肯定还有一个疑问 既然可以把一个非常量变量赋值给const变量 那么当非常量变量的值改变时 const变量的值是否改变 下面的试验给出答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> r = i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  i = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果输出 1 1 2 证明const变量还是未改变值之前的常量值1</p>
<p>我们像将const的变量只在一个文件中定义 而在多个文件中声明并使用他 使用extern关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;<span class="comment">//在file1.h头文件中声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize = fcn();<span class="comment">// 运行时初始化 在file1.cc中定义并初始化了一个常量 给常量能被其他文件访问 与头文件中声明的是同一个</span></span><br></pre></td></tr></table></figure>
<p>常量的引用不能被用作修改他绑定的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;<span class="comment">//正确 引用和对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">2</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<p>不能把一个const常量赋值给一个非const的引用 相反 允许把一个非常量对象赋值给常量引用</p>
<p>指针和const</p>
<p>指向常量的指针不能用于改变其指向对象的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//错误 ptr是一个普通指针 不能指向常量值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;<span class="comment">//正确 cptr是一个指向常量的指针 记住他不是常量指针</span></span><br><span class="line">*cptr = <span class="number">1.0</span>;<span class="comment">//错误 不能给*cptr赋新的值</span></span><br></pre></td></tr></table></figure>
<p>与引用一样 不能把一个const常量赋值给一个非const的指针 相反 允许把一个非常量对象赋值给常量指针</p>
<p>const指针</p>
<p>常量指针使用 *const表示 说明指针是一个常量 不变的是指针本身的值而非指向的那个值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNum;<span class="comment">//curErr将一直指向errNum curErr是常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<p>解疑1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">double</span> i = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;</span><br><span class="line"><span class="comment">//    *cptr = 6.6;//错误 不能改变cptr指向的变量pi的值  因为pi本身是常量</span></span><br><span class="line">    cptr = &amp;i;<span class="comment">//正确 可以改变cptr指向新的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *cptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//输出1.1</span></span><br></pre></td></tr></table></figure>
<p>cptr是一个指向常量的指针 记住他不是常量指针 常量指针使用 *const标记 cptr允许改变指向新的地址 但是不能改变cptr指向的变量的值</p>
<p>解疑2</p>
<p>上文有一个表达是中包含两个const 如 <code>const double *const pip = &amp;pi;</code></p>
<p>这两个const是有区别的 靠右的叫顶层const 靠左的叫底层const 在执行对象拷贝时两者存在区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i; <span class="comment">//不能改变p1的值 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>; <span class="comment">//不能改变ci的值 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci; <span class="comment">//运行改变p2的值(即改变p2的指向) 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;<span class="comment">//靠右的叫顶层const 靠左的叫底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;<span class="comment">//用于声明引用的const都是底层const</span></span><br><span class="line">i = ci;<span class="comment">//正确 ci是顶层const 对此操作无影响</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确 p2 p3指向的对象类型相同 都是底层const</span></span><br><span class="line"><span class="keyword">int</span> *p = p3;<span class="comment">//错误 p3包含底层const的定义 而p没有</span></span><br><span class="line">p2 = &amp;i; <span class="comment">//正确 int* 能转换成const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci;<span class="comment">//错误 普通的引用r不能绑定到int常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">//正确 const的引用可以绑定到普通int上</span></span><br></pre></td></tr></table></figure>
<p>常量表达式 constexpr</p>
<p>是指值不会改变并且在编译过程中就能得到计算结果的表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">20</span>;<span class="comment">//是</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = i + <span class="number">1</span> ;<span class="comment">//是</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;<span class="comment">//不是</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = get_size(); <span class="comment">//不是</span></span><br></pre></td></tr></table></figure>
<p>c++11规定 允许将变量声明为constexpr类型以便编译器来验证变量值是否是一个常量表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size()；<span class="comment">//只有当size函数是一个constexpr函数时才是一个正确的声明 通常这种函数比较简单 在编译时就能产生结果</span></span><br></pre></td></tr></table></figure>
<p>一般来说 如果认定一个变量是常量表达式 就把他声明为constexpr类型</p>
<p>类型别名</p>
<p>使用两种方式来定义类型别名 一个是关键字typedef 一个是关键字using</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages是doubel的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>
<p>定义一个指针别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;<span class="comment">//ps是一个指针 他的对象是指向char的常量指针</span></span><br></pre></td></tr></table></figure>
<p>注意不要理解成下面的方式 直接把pstring 替换成char *</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;<span class="comment">//是对const pstring cstr = 0 的错误理解</span></span><br></pre></td></tr></table></figure>
<p>这两者声明的含义完全不同 <code>const pstring cstr = 0</code>是一个指向char的常量指针 而改写后的<code>const char *cstr = 0;</code>则是一个指向const char的指针 该指针允许改变它的指向 常量指针不可以改变指向</p>
<p>auto类型说明符</p>
<p>auto类型说明符是让编译器替我们分析表达式所属的类型 例如<code>auto item=v1+v2</code></p>
<p>如果v1 v2是double类型 那么可以自动推断出item类型为double 如果v1 v2是sale_item对象类型那么推断出item类型为sale_item类型</p>
<p>一条语句中可以声明多个变量 但需要注意所有变量的初始基本类型都必须一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//正确 i为整形 p为整形指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误 sz为整形 pi为浮点型 类型不一致</span></span><br></pre></td></tr></table></figure>
<p>decltype类型指示符</p>
<p>decltype用作选择并返回操作数的数据类型 期间不会使用表达式的值初始化变量</p>
<p><code>decltyp(f()) sum = x;</code> 表示sum类型就是函数f的返回类型 编译器并不实际调用函数f 而是当调用发生时f的返回类型就是sum的返回类型</p>
<p>当使用decltype和引用时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp; ,y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误 z是引用 必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;<span class="comment">// 正确加分的结果是int 因此b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//错误 c是int&amp; 必须初始化</span></span><br></pre></td></tr></table></figure>
<p>注意 使用decltype时 变量名上可以加括号如<code>decltype((i))</code> 此时他的类型与不加括号前的类型会有不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">9</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误 d是int&amp; 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">//正确 e是一个未初始化的int</span></span><br></pre></td></tr></table></figure>
<p>切记 decltype((变量名)) 的结果永远是引用 而decltype(var) 的结果只有当var本身是引用类型时才是引用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录c++的由来和基本类型的使用&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://luyaoming.com/categories/C/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://luyaoming.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>使用selenium自动填充网页表单.md</title>
    <link href="http://luyaoming.com/2021/04/24/%E4%BD%BF%E7%94%A8selenium%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E7%BD%91%E9%A1%B5%E8%A1%A8%E5%8D%95/"/>
    <id>http://luyaoming.com/2021/04/24/使用selenium自动填充网页表单/</id>
    <published>2021-04-24T05:35:54.000Z</published>
    <updated>2021-06-15T01:08:34.809Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍使用selenium这个工具库基于python和java来实现自动填写表单的功能</p>
<a id="more"></a>
<p>下面是引用百度百科对selenium的介绍：</p>
<p>Selenium [1] 是一个用于Web应用程序测试的<a href="https://baike.baidu.com/item/工具/81891" target="_blank" rel="external">工具</a>。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括<a href="https://baike.baidu.com/item/IE/69103" target="_blank" rel="external">IE</a>（7, 8, 9, 10, 11），<a href="https://baike.baidu.com/item/Mozilla Firefox/3504923" target="_blank" rel="external">Mozilla Firefox</a>，<a href="https://baike.baidu.com/item/Safari/597" target="_blank" rel="external">Safari</a>，<a href="https://baike.baidu.com/item/Google/86964" target="_blank" rel="external">Google</a> <a href="https://baike.baidu.com/item/Chrome/5633839" target="_blank" rel="external">Chrome</a>，<a href="https://baike.baidu.com/item/Opera/25140" target="_blank" rel="external">Opera</a>，Edge等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成<a href="https://baike.baidu.com/item/ .Net/156737" target="_blank" rel="external"> .Net</a>、<a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="external">Java</a>、<a href="https://baike.baidu.com/item/Perl/851577" target="_blank" rel="external">Perl</a>等不同语言的测试脚本。</p>
<p>下面主要介绍使用java和python两种方式来调用脚本测试网页</p>
<p>方法一：python+selenium+chrome</p>
<p>先pip安装selenium</p>
<p><code>pip3 install selenium</code></p>
<p>下载需要基于浏览器测试的工具 如这里使用chrome浏览器测试 所以下载chromedriver</p>
<p>要注意需要下载与chrome版本对应的driver版本 我的chrome浏览器版本是89</p>
<p>对应下载driver的地址是<br><a href="https://chromedriver.storage.googleapis.com/index.html?path=89.0.4389.23/" target="_blank" rel="external">https://chromedriver.storage.googleapis.com/index.html?path=89.0.4389.23/</a></p>
<p>下载完成后把chromedriver文件改成可执行文件 并在放到PATH目录下</p>
<p><code>chmod a+x chromedriver</code></p>
<p><code>cp ~/Downloads/chromedriver /usr/local/bin/</code></p>
<p>使用以下python代码进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前台开启浏览器模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openChrome</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 加启动配置</span></span><br><span class="line">    option = webdriver.ChromeOptions()</span><br><span class="line">    option.add_argument(<span class="string">'disable-infobars'</span>)</span><br><span class="line">    <span class="comment"># 打开chrome浏览器</span></span><br><span class="line">    driver = webdriver.Chrome(options=option)</span><br><span class="line">    <span class="keyword">return</span> driver</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无需启动浏览器模式</span></span><br><span class="line">    <span class="comment"># def openChromBack():</span></span><br><span class="line">    <span class="comment">#     return webdriver.Remote(command_executor="[http://localhost:4567/wd/hub](http://localhost:4567/wd/hub "</span></span><br><span class="line">    <span class="comment">#     selenium</span></span><br><span class="line">    <span class="comment">#     本地测试地址</span></span><br><span class="line">    <span class="comment">#     ")", desired_capabilities = DesiredCapabilities.HTMLUNIT)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openChromeBack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> webdriver.Remote(command_executor=</span><br><span class="line">                            <span class="string">"[http://localhost:4567/wd/hub](http://localhost:4567/wd/hub "</span><span class="string">")"</span>,</span><br><span class="line">                           desired_capabilities=DesiredCapabilities.HTMLUNIT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operationAuth</span><span class="params">(driver)</span>:</span></span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    driver.get(url)</span><br><span class="line">    <span class="comment"># 找到输入框并输入查询内容</span></span><br><span class="line">    elem = driver.find_element_by_id(<span class="string">"kw"</span>)</span><br><span class="line">    elem.send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">    <span class="comment"># 提交表单</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"//*[@id='su']"</span>).click()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'查询操作完毕！'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法主入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 加启动配置</span></span><br><span class="line">    driver = openChrome()</span><br><span class="line">    operationAuth(driver)</span><br></pre></td></tr></table></figure>
<p>方法二：java+selenium+chrome </p>
<p>在安装了jdk1.8的环境下 不需要再配置环境变量</p>
<p>直接创建maven项目 引入selenium库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写java测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"webdriver.chrome.driver"</span>,<span class="string">"/usr/local/bin/chromedriver"</span>);</span><br><span class="line">        ChromeOptions chromeOptions = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        chromeOptions.addArguments(<span class="string">"--headless"</span>);</span><br><span class="line">        ChromeDriver chromeDriver = <span class="keyword">new</span> ChromeDriver();</span><br><span class="line">        <span class="comment">//后台静默模式启动浏览器</span></span><br><span class="line"><span class="comment">//        ChromeDriver chromeDriver = new ChromeDriver(chromeOptions);</span></span><br><span class="line">        chromeDriver.manage().timeouts().implicitlyWait(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        String url = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">        chromeDriver.get(url);</span><br><span class="line">        WebElement element = chromeDriver.findElementById(<span class="string">"kw"</span>);</span><br><span class="line">        element.sendKeys(<span class="string">"炉石传说最强卡组"</span>);</span><br><span class="line">        chromeDriver.findElementByXPath(<span class="string">"//*[@id='su']"</span>).click();</span><br><span class="line">        System.out.println(<span class="string">"搜索完毕！"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里加了个选项 可以在后台静默地启动浏览器 不会打开浏览器新窗口 非常方便</p>
<p>有关其他更多设置项 可以直接查看官网</p>
<p><a href="http://www.selenium.org.cn/1598.html" target="_blank" rel="external">http://www.selenium.org.cn/1598.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍使用selenium这个工具库基于python和java来实现自动填写表单的功能&lt;/p&gt;
    
    </summary>
    
    
      <category term="网页" scheme="http://luyaoming.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
      <category term="selenium" scheme="http://luyaoming.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>c语言程序设计现代方法-读书笔记（三）</title>
    <link href="http://luyaoming.com/2021/04/14/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://luyaoming.com/2021/04/14/c语言程序设计现代方法-读书笔记（三）/</id>
    <published>2021-04-14T07:49:09.000Z</published>
    <updated>2021-06-15T01:08:34.797Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍c语言的输入输出，错误处理和其他标准库函数</p>
<a id="more"></a>
<blockquote>
<p>c语言程序设计现代方法 <br>原著：K.N.King <br>翻译：吕秀峰 <br>– –读书笔记 by asii <a href="c语言程序设计现代方法-读书笔记（三）.md">c语言程序设计现代方法-读书笔记（三）.md</a> </p>
</blockquote>
<p>#</p>
<p>###输入/输出标准库</p>
<p>c语言中流的访问是通过文件指针来实现的 可以在程序中有下列形式的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp1, *fp2;</span><br></pre></td></tr></table></figure>
<p><studio.h>提供了三种标准流，是备用的。我们无法打开或关闭，分别是：</studio.h></p>
<p>stdin 标准输入 键盘</p>
<p>stdout 标准输出 屏幕</p>
<p>stderr 标准错误 屏幕</p>
<p>类似于UNIX和DOS操作系统的命令行操作 c语法可以提供将输入输出重定向 例如</p>
<p>demo &gt; out.dat 将原来输出到stdout屏幕的demo数据 写入到out.dat文件中</p>
<p>demo &lt; in.dat &gt; out.dat 输出重定向和输入重定向可以合并使用</p>
<p><stdio.h>支持两种类型的文件：文本文件和二进制文件</stdio.h></p>
<p>例如我们写的c的源代码就是存储在文本文件中 而编译出来的c程序是存储在二进制文件中 二进制文件可以节省很大的存储空间</p>
<p>读写文件时需要区分是文本文件还是二进制文件 例如不能把二进制文件写入到文本文件中 因为可能会丢失二进制文件的结束字符 当无法确认是哪种形式的文件时 把文件设定为二进制文件是安全的做法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">fp = fopen(<span class="string">"in.dat"</span>,<span class="string">"r"</span>)</span><br></pre></td></tr></table></figure>
<p>fopen函数返回一个文件指针 程序通常把指针存储在变量中 永远不要假设可以打开文件 所以需要测试fopen函数的返回值</p>
<p>关于文本文件的模式有r w  a  r+ w+ a+</p>
<p>关于二进制文件的模式有rb wb ab r+b a+b</p>
<p>对一个文件进行读和写之间的转换 需要有定位函数 和 fflush函数</p>
<p>下面一段程序代码展示常用的打开与关闭文件的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="string">"example.dat"</span></span></span><br><span class="line">main()&#123;</span><br><span class="line">  FILE *fp</span><br><span class="line">    fp = fopen(FILE_NAME,<span class="string">"r"</span>)</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"can not open %s\n"</span>,FILE_NAME)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FILURE)</span><br><span class="line">    &#125;</span><br><span class="line">  	...</span><br><span class="line">    fclose(fp)</span><br><span class="line">    return <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓冲：写入流的数据实际是存储在内存的缓冲区中的</p>
<p>可以使用fflush函数清洗缓存区 例如fflush(fp) 或者 fflush(NULL) 可有改变缓冲区的写法setvbuf(steam ,buffer,_IOFBF,n) 记得修改缓存区需要在执行其他在steam操作之前</p>
<p>remove(“foo”)删除foo文件</p>
<p>rename(“foo”,”bar”)修改foo文件的文件名为bar 如果文件已经打开 无法改名</p>
<p>fprint和printf函数输出流写可变的数据项，并且用格式串来控制输出额形式</p>
<p>printf(“total:%d\n”,total); 写入到stdout</p>
<p>fprint(fp,”total:%d\n”,total) 写入到fp</p>
<p>scanf(“%d%d”,&amp;I,&amp;J); 从stdin中读入</p>
<p>fscanf(fp,”%d%d”,&amp;I,&amp;J); 从fp流中读入  这两个常用作模式匹配</p>
<p>scanf函数返回错误时有可能遇到这三种情况1文件末尾 2错误 3匹配失败</p>
<p>每个流会对应两个指示器 错误指示器和文件末尾指示器 当流上的操作失败时就会设置某个指示器 一旦设置指示器 就会保持这种状态知道clearerr函数清除指示器为止</p>
<p>feof函数和ferror函数来判断一个流的指示器是遇到文件末尾还是输入错误,当遇到错误时会返回EOF</p>
<p>fputc函数和putc函数是putchar函数向任意流写字符的更通用的版本 有时候会用作宏来实现如 #define putchar(c) putc *((c),stdout)</p>
<p>fgetc函数和getc函数用作从流中读取一个字符 用作宏时表示为#define getchar() getc(stdin)  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历字符直到文件的结尾</span></span><br><span class="line"><span class="keyword">while</span>((ch = getc(fp)) != EOF)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制文件 fcopy f1.c f2.c</p>
<p>puts函数 fput函数 与putc函数和fputc函数大体相似 只是操作的对象换成是一行字符串</p>
<p>gets函数 fgets函数的操作对象也是一行字符串 gets函数逐个读取字符 在遇到首个换行符后停止操作 并且丢弃此换行符 或者已经读入sizeof(str)-1个字符是结束操作 </p>
<p>上面是介绍文本文件的输入输出函数 那么对于二进制文件 则使用fread函数和fwrite函数</p>
<p>sprintf函数和sscanf函数允许对字符串作为读流/写数据 他们与printf和fprintf很类似 不同是sprintf函数把输出写入到字符数组而不是流中</p>
<p>文件的定位</p>
<p>这个功能产生的需求是：如果文件包含一系列记录 我们希望直接跳到特殊的记录处 并继续对其进行读入或更新 相关的函数fseek 系统有定义三种宏 分别可以跳转到文件的开头 当前位置和结尾 最适合于二进制流 以字节计数进行移动</p>
<p>####ctype.h  字符处理</p>
<p>字符测试函数</p>
<p>isalnum(c) c是否是字母或数字</p>
<p>isalpha(c) c是否是字母</p>
<p>iscntrl(c) c是否是控制字符</p>
<p>isdigit(c) c是否是十进制数字</p>
<p>islower(c) c是否是小写字母</p>
<p>ispunct(c) c是否是标定符号</p>
<p>isspace(c) c是否是空白字符 包含换页符``\f 换行符 \n 回车符 \r 横向制表符\t 纵向制表符\v</p>
<p>isupper(c) c是否是大写字母</p>
<p>isxdigit(c) c是否是十六进制数字</p>
<h3 id="string-h-字符串处理"><a href="#string-h-字符串处理" class="headerlink" title="string.h 字符串处理"></a>string.h 字符串处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*复制*/</span></span><br><span class="line"><span class="keyword">char</span> source[] = &#123;<span class="string">'h'</span>,<span class="string">'o'</span>,<span class="string">'t'</span>,<span class="string">'\0'</span>,<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'a'</span>&#125;</span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dest, source, <span class="number">4</span>); <span class="comment">/*h,o,t,\0 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest,source); <span class="comment">/* h,o,t 复制以空字符结尾之前的字符*/</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest,source,<span class="number">7</span>)<span class="comment">/* h,o,t,\0,\0,\0,\0 追加空字符直至满足n=7*/</span></span><br><span class="line"><span class="comment">/*拼接*/</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = <span class="string">"tea"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str,<span class="string">"bag"</span>); <span class="comment">/* str现在包含字符串teabag 函数返回第一个参数指针*/</span></span><br><span class="line"><span class="built_in">strncat</span>(str,<span class="string">"bag"</span>,<span class="number">2</span>) <span class="comment">/* 得到指向字符串teaba的指针 保证字符串始终以\0结尾 */</span></span><br><span class="line"><span class="comment">/*比较*/</span></span><br><span class="line"><span class="keyword">char</span> s1[] = &#123;<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'g'</span>,<span class="string">'\0'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'r'</span>&#125;</span><br><span class="line"><span class="keyword">char</span> s2[] = &#123;<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'g'</span>,<span class="string">'\0'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'t'</span>&#125;</span><br><span class="line"><span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>) <span class="comment">/*输出0 比较前三个字符*/</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1,s2)  <span class="comment">/*输出0 遇到空字符串结束比较了*/</span></span><br><span class="line"><span class="built_in">strncmp</span>(s1,s2,<span class="number">4</span>) <span class="comment">/*输出0 结合上面两个函数 当比较的字符数达到n个或其中任意一个字符是空字符就停止比较*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*搜索*/</span></span><br><span class="line"><span class="keyword">char</span> *,str[] = <span class="string">"Form follows function"</span>;</span><br><span class="line">p = <span class="built_in">strchr</span>(str,<span class="string">'f'</span>) <span class="comment">/*finds first 'f' 函数返回一个指针指向第一个f*/</span></span><br><span class="line">p = <span class="built_in">memchr</span>(str,<span class="string">'f'</span>,<span class="number">3</span>);<span class="comment">/*搜索指定字符数n后停止而不是直到空字符*/</span></span><br><span class="line">p = <span class="built_in">strpbrk</span>(str,<span class="string">"mn"</span>);<span class="comment">/*finds first 'm' or 'n'*/</span></span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line">len = <span class="built_in">strspn</span>(str,<span class="string">"morF"</span>);<span class="comment">/*len = 4返回字符串中第一个不属于给定字符集中的字符下标*/</span></span><br><span class="line">len = <span class="built_in">strcspn</span>(str,<span class="string">"morF"</span>);<span class="comment">/*len =0返回第一个属于给定字符集中的字符下标*/</span></span><br><span class="line">p = <span class="built_in">strstr</span>(str,<span class="string">"fun"</span>);<span class="comment">/*指向字符f 函数返回指向在字符串中找到的第一处匹配字符串的指针 如果找不到返回空指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他*/</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));<span class="comment">/*将数组全部初始化为0 返回他的第一个参数（指针）*/</span></span><br><span class="line"><span class="built_in">strlen</span>(a) <span class="comment">/*返回字符串的长度 不包含字符串末尾的空字符*/</span></span><br></pre></td></tr></table></figure>
<p>###错误处理</p>
<p>c中也有断言 assert</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i]</span><br><span class="line">  assert(i&gt;=<span class="number">0</span> &amp;&amp; i &lt; n)</span><br><span class="line">  a[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果i的值小于0或大于等于n 则程序终止 不再执行后面的赋值</p>
<p>断言会引入额外的检测 会增加程序的运行时间 </p>
<p>要禁止断言只需要在包含<assert.h>之前定义宏NDEBUG即可</assert.h></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一旦程序又有错误发生 去掉NDEBUG宏即可重新启动断言</p>
<p>注意断言尽量精简 不要与其他表达式写在一起 下面是不推荐的写法</p>
<p>assert((p = malloc(n+1) != null)) 一旦定义了NDEBUG malloc将不会执行</p>
<p>使用errno来判断程序是否运行错误 例如在调用函数之后检查errno的值如果不为0代表调用过程中有错误发生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*运行前要记得先清零*/</span></span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">if</span>(errno != <span class="number">0</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>
<p>出错后 errno可能是下面的两种值 EDMO ：定义域错误 ERANGE : 取值范围错误</p>
<p>perror(“sqr error”) 输出一个字符串到stderr</p>
<p>signal(SIGINT,handler) signal函数调用对SIGINT信号安装一个处理函数hander，一旦程序在执行过程中出现SIGINT信号，handler函数就会自动被调用</p>
<p>也有预定义的信号错误处理函数 都定义在signal.h的宏中</p>
<p>SIG_DFL 按默认方式处理信号</p>
<p>SIG_IGN 忽略该信号</p>
<p>也有情况是安装错误处理函数时就发生错误 此时可以使用SIG_ERR检测到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(signal(SIGINT,handler) == SIG_ERR)&#123;</span><br><span class="line">  <span class="comment">/* error, can not install hander for SIGINT*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号处理完后 除非处理函数重新被安装 否则该信号不会被同一个处理函数调用</p>
<p> 可使用raise函数触发信号raise(SIGABRT) 返回值可以用来测试调用是否成功 0代表成功</p>
<p>goto一般只能在同一函数内调用 但是<setjmp.h>中的setjmp和longjmp函数则允许不同函数之间的跳转并且不需要返回 经常用在错误处理</setjmp.h></p>
<p>###stdlib.h 通用的实用工具</p>
<p>新函数strtod strtol stroul 替代了旧函数atof atoi atol  用作把含有字符格式的数字字符串转换成他的等价数值 </p>
<p>strtod string转换成double</p>
<p>strtol string转换成long int</p>
<p>stroul string转换成unsign long int</p>
<p>伪随机序列生成函数</p>
<p>int rand(void)   ;</p>
<p>void stand(unsigned int seed);</p>
<p>atexit(cleanup);  函数允许用户注册一个临近程序终止时要调用的函数cleanup</p>
<p>abort函数也是让程序终止 但是是异常终止也不能调用注册函数 属于一种不成功的终止</p>
<p>c调用外部环境</p>
<p>system(“ls &gt;myfile”) 在unix系统执行命令</p>
<p>system(“dir &gt;myfile”)在dos系统执行命令</p>
<p>bsearch函数用于有序数组的搜索 qsort可用于任何数组</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍c语言的输入输出，错误处理和其他标准库函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c语言" scheme="http://luyaoming.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>了解Android测试工具</title>
    <link href="http://luyaoming.com/2019/05/07/%E4%BA%86%E8%A7%A3Android%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://luyaoming.com/2019/05/07/了解Android测试工具/</id>
    <published>2019-05-07T09:05:45.000Z</published>
    <updated>2021-06-15T01:08:34.806Z</updated>
    
    <content type="html"><![CDATA[<p>总结下日常用到的Android软件测试工具 包括白盒和黑盒的</p>
<a id="more"></a>
<h1 id="1-uiautomatorviewer"><a href="#1-uiautomatorviewer" class="headerlink" title="1. uiautomatorviewer"></a>1. uiautomatorviewer</h1><p>一个包含创建测试、执行自动化测试的工具 </p>
<p>Android SDK Tools：API 21 版本或者21以上版本;</p>
<p>Android SDK Platform：API 16 版本或者16以上版本</p>
<p>查看ui控件位置的二进制文件在sdk/tools/bin/uiautomatorviewer 双击即可打开 windows的话会是bat文件吧</p>
<p>通过该二进制文件找到控件的id后 可以创建对应的UiObject 然后操控控件的点击 拖拽 滚动等功能 如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过id来创建出UiSelector 对象</span></span><br><span class="line">UiSelector =  <span class="keyword">new</span> UiSelector().resourceId(<span class="string">"com.tencent.mobileqq:id/conversation_head"</span>);</span><br><span class="line"><span class="comment">// 通过UiSelector 对象    创建出 UiObject  对象    </span></span><br><span class="line">UiObject switcher = <span class="keyword">new</span> UiObject(uiSelector );        </span><br><span class="line"><span class="comment">// 判断该控件是否存在</span></span><br><span class="line"><span class="keyword">if</span> (switcher.exists())</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//点击该控件  </span></span><br><span class="line">    switcher.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java的实现方式 需要继承UiAutomatorTestCase类 该类在uiautomator.jar中包含 生成build.xml后用ant工具进行编译最后生成一个 工程名.jar包 推到设备 /data/local/tmp 目录下 在adb shell 中执行： uiautomator runtest 工程名.jar -c 包名.类名 该方式每次改动后都需要编译和生成jar包 稍微麻烦 但是可以直接在设备下运行 如一些微信抢红包的小工具就可以通过这种方式实现 下面介绍python的方式来实现</p>
<p>python的实现方式 先通过pip安装uiautomator库 pip install uiautomator 然后就可以创建py文件写测试代码啦 最后将py文件加上执行权限 直接终端运行python3 xxx.py 即可 代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> uiautomator <span class="keyword">import</span> device <span class="keyword">as</span> d </span><br><span class="line"><span class="comment">#几种方式创建Device</span></span><br><span class="line"><span class="comment">#d = Device('014E05DE0F02000E')</span></span><br><span class="line"><span class="comment">#d = Device('014E05DE0F02000E', adb_server_host='192.168.1.68', adb_server_port=5037)</span></span><br><span class="line">d = Device()</span><br><span class="line"><span class="comment">#屏幕点亮</span></span><br><span class="line">d.screen.on() </span><br><span class="line">d(text=<span class="string">"Clock"</span>).click()</span><br><span class="line"><span class="comment"># press home key</span></span><br><span class="line">d.press.home()</span><br><span class="line"><span class="comment"># press back key</span></span><br><span class="line">d.press.back()</span><br><span class="line"><span class="comment"># click (x, y) on screen</span></span><br><span class="line">d.click(x, y)</span><br><span class="line"><span class="comment"># long click (x, y) on screen</span></span><br><span class="line">d.long_click(x, y)</span><br><span class="line"><span class="comment"># swipe from (sx, sy) to (ex, ey)</span></span><br><span class="line">d.swipe(sx, sy, ex, ey)</span><br><span class="line"><span class="comment"># drag from (sx, sy) to (ex, ey)</span></span><br><span class="line">d.drag(sx, sy, ex, ey)</span><br><span class="line"><span class="comment"># take screenshot and save to local file "home.png", can not work until Android 4.2.</span></span><br><span class="line">d.screenshot(<span class="string">"home.png"</span>)</span><br><span class="line"><span class="comment"># wait for current window to idle</span></span><br><span class="line">d.wait.idle()</span><br><span class="line"><span class="comment"># wait until window update event occurs</span></span><br><span class="line">d.wait.update()</span><br></pre></td></tr></table></figure>
<p>python版本的uiautomator的来自于民间作者<em>xiaocong</em>做的wrapper 下面贴一下他的github项目地址<br><a href="https://github.com/xiaocong/uiautomator" target="_blank" rel="external">https://github.com/xiaocong/uiautomator</a><br>更多api可以在他的项目下找到</p>
<h1 id="2-Monkey"><a href="#2-Monkey" class="headerlink" title="2.Monkey"></a>2.Monkey</h1><p>使用方式很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// -vvv表示级别为详细 数字400表示运行的次数 --pct-touch表示点击事件占百分之50 -s 表示seed为1234 想重现使用同样的seed即可 最后执行结果保存到本地txt文件</span><br><span class="line">adb shell monkey -vvv -p com.tencent.mobileqq 400 --pct-touch 50 -s 1234 &gt; ~/monkey.txt</span><br><span class="line"></span><br><span class="line">更多扩展</span><br><span class="line">--pct-appswitch &lt;percent&gt; 在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法</span><br><span class="line">--pct-anyevent &lt;percent&gt;   它包含了所有其它类型的事件，如：按键、其它不常用的设备按钮等等</span><br><span class="line">--throttle &lt;milliseconds&gt; 用于指定用户操作（即事件）间的时延，单位是毫秒</span><br><span class="line">--ignore-crashes 忽略crash </span><br><span class="line">--ignore-timeouts 忽略anr</span><br><span class="line">--ignore-security-exceptions 忽略许可认证</span><br><span class="line">-help 更多指令 参考help引导</span><br><span class="line"></span><br><span class="line">最后搜索日志 一般搜索以下关键字即可 anr crash die exception</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下日常用到的Android软件测试工具 包括白盒和黑盒的&lt;/p&gt;
    
    </summary>
    
      <category term="test" scheme="http://luyaoming.com/categories/test/"/>
    
    
      <category term="Android" scheme="http://luyaoming.com/tags/Android/"/>
    
      <category term="测试工具" scheme="http://luyaoming.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>追风筝的人-读书笔记</title>
    <link href="http://luyaoming.com/2017/10/22/%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://luyaoming.com/2017/10/22/追风筝的人-读书笔记/</id>
    <published>2017-10-22T01:07:56.000Z</published>
    <updated>2021-06-15T01:08:34.838Z</updated>
    
    <content type="html"><![CDATA[<p>这本书很薄 不过也花了3天才看完</p>
<blockquote>
<p>追风筝的人  原著：（美）卡勒德·胡赛尼  读书笔记 by asii</p>
</blockquote>
<p>故事讲的是一个阿富汗男孩阿米尔和他的既是仆人也是兄弟的人故事 这个仆人叫哈桑 他其实也是阿米尔同父异母的兄弟 但是阿米尔一直不知道 哈桑 和阿米尔喜欢放风筝 阿米尔是一个性格懦弱的男孩 被孩子欺负的时候 都是哈桑出面挡箭牌 有此遇到一个混混老大和他的两个跟班 哈桑和阿米尔被逼到走投无路 哈桑用弹弓指着混混老大 最后混混放走他们 阿米尔一直期待得到他的老爸 那位威武有力 刚正不苛的大男人的肯定 但他老爸一直觉得他儿子懦弱 柔弱 同时他对他老爸对待哈桑的关照表示妒忌 但是阿米尔和哈桑一直保持着很好的友谊</p>
<p>阿米尔在哈桑的帮助下赢得了那次风筝比赛 哈桑是个追风筝的能手 在那里的风俗是追到最后掉落的风筝是一件值得骄傲的事情 哈桑追到了那只蓝色风筝 但是被之前那个混混老大拦住了 混混老大要挟他要抢走风筝 哈桑之前跟阿米尔说过“为你 千千万万遍”宁死不屈 最后哈桑被那个混混老大爆菊了 还流了血 这一切都被在街角的阿米尔看在眼里 但懦弱的阿米尔并没有勇气去救他兄弟 </p>
<p>就这样 哈桑和阿米尔之间产生芥蒂 阿米尔担心自己看到这经过而不去帮忙的事被哈桑发现 一直躲避哈桑 哈桑极力想挽回他们的友谊 但是被阿米尔的这种“不知道如何面对哈桑”的纠结心情拒绝了 到最后甚至想赶走啊里和哈桑 还曾经不经意跟他老爸提过 但他老爸愤怒地呵斥了阿米尔说阿里是他一起长大的兄弟</p>
<p>阿米尔在自己的生日礼物里挑了那块他老爸送他的手表和一些钱贼赃嫁祸了阿里和哈桑 哈桑其实是知道是阿米尔要嫁祸他的 因为他看得出来阿米尔一直在躲避他 其实也是想他走 在老爸问哈桑是不是哈桑偷的时候 哈桑说了是 那是他最后一次给阿米尔做挡箭牌 阿米尔也知道了其实哈桑知道阿米尔当时是没有出来救他的  最后阿里为了维护自己的和他儿子的尊严 在一个雨天离开了  阿米尔如愿以偿 但是不时也会想起他和哈桑度过的开心的日子 也会积累这些内疚</p>
<p>阿富汗发生政变 老爸和阿米尔辗转到了美国生存 阿米儿在那里毕业并且娶到了以前阿富汗一个将军的女儿  后来老爸积劳成疾死了 阿米尔回阿富汗接到了哈桑的儿子 那时候哈桑已经死了 怎么死的不知道 最后他们几个去放风筝 阿米尔想起了他和哈桑以前放风筝的日子 切断了对手的风筝后 对哈桑的儿子说 “为你 千千万万遍” 估计是他想让自己的内疚来弥补哈桑的儿子吧 阿米尔一直保守着秘密 那个哈桑和阿米尔的秘密   全书完</p>
<p>2017年8月31日</p>
<p>后来翻百度和知乎查一下 发觉自己阅读的是阉割版 没有了阿米尔回去救哈桑儿子的故事情节 但总体上不影响故事情节 这是一个关于犯错和自我救赎的故事 阿米尔的老爸跟阿里的老婆生下了哈桑 他偷走了哈桑的父爱 他偷走对阿米尔童年的关爱 他偷走了阿里的老婆  他在书里的那个正面形象何尝不是一种自我救赎呢 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书很薄 不过也花了3天才看完&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;追风筝的人  原著：（美）卡勒德·胡赛尼  读书笔记 by asii&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;故事讲的是一个阿富汗男孩阿米尔和他的既是仆人也是兄弟的人故事 这个仆人叫哈桑 他其实也是
    
    </summary>
    
      <category term="novel" scheme="http://luyaoming.com/categories/novel/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="追风筝的人" scheme="http://luyaoming.com/tags/%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>死了七次的男人-读书笔记</title>
    <link href="http://luyaoming.com/2017/10/22/%E6%AD%BB%E4%BA%86%E4%B8%83%E6%AC%A1%E7%9A%84%E7%94%B7%E4%BA%BA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://luyaoming.com/2017/10/22/死了七次的男人-读书笔记/</id>
    <published>2017-10-22T01:06:46.000Z</published>
    <updated>2021-06-15T01:08:34.821Z</updated>
    
    <content type="html"><![CDATA[<p>因为对这名字的猎奇心理而读的一本书 作者说这是一种科幻推理小说 建立在一个作者幻想的世界观下 然后进行推理的一种小说 小说题材新颖 尽管有相关的电影或电视题材 但是读书过程中通过作者的文笔可以感受到剧情的波澜起伏 引人入胜 有推理兴趣的同学都可以一读</p>
<a id="more"></a>
<blockquote>
<p>死了七次的男人 原著：西泽保彦 读书笔记 by asii</p>
</blockquote>
<p>书的主人公具有一种特殊的体质 当某一天跌入时空黑洞 他可以循环9次 但是只以最后一次为最终定稿 说是体质而不是异能 是因为这种情况不是他能控制的 在他报考高等学府考试的当天正好跌入了时空黑洞 所以让他以满分的成绩入学了 但是毕竟不是他能控制的 后面的考试 如果刚好跌入时空黑洞还好 如果没跌入 他的成绩就很差 导致了整体他在班级内的成绩在倒数 而在日常生活中 小q（主人公）他是一个淡泊名利 上进心不是很强的人 因为伴随着这样的体质 像已经看破了世界规律 使他的心理年龄不少于30岁 而肉体上他只是个高一生 </p>
<p>前面都是介绍小q的背景 作者是建立在这个大前提下的推理小说 下面开始讲正在的故事情节</p>
<p>书里死了七次的男人不是小q 而是他的爷爷 他的爷爷以前是个厨师 后来酗酒 加上后来他妻子死了 他就酗酒更凶了 他家有三个女儿  大女儿一共有三个儿子 分别是富士高 世史夫 小q  而二女儿有两个女儿 分别是舞和榴奈 小女儿是胡乃留 膝下无子女 爷爷因为在妻子死后一直无尽到夫妻的责任 所以大女儿和二女儿都分别考上了大学然后出嫁了 远离了这个家 剩下胡乃留 差点逼疯了她 后来爷爷和胡乃留准备死之前买了彩票竟然中奖了 然后爷爷觉得这是天没有让他死 必定是否极泰来 所以开始做起厨师 经营的店还开了很多分店 后来还建立了一间大公司 变得有钱起来了 大女儿和二女儿 这些年他们的丈夫被离职在家借酒消愁了 具体原因是后来小q在爷爷的日志中找到的 为了投靠爷爷 这些年来爷爷都在过年的时候 元旦开始 叫他的女儿回来一起拜年 并且立下新的遗嘱 这年打算找一个作为胡乃留阿姨的养子或者养女 并且继承爷爷大公司的部分财产 家道中落的两个家庭都抓紧机会回来投靠爷爷 然而爷爷因为怨恨当年两个女儿对他和胡乃留阿姨的抛弃 都对他们的摇尾乞怜嗤之以鼻 但没有对他的孙子或孙女有半分怨恨 </p>
<p>这个新年 爷爷要求他们都身穿不同颜色的运动服进行拜年 在进行宴会的时候 小q举杯祝酒 到晚上11点多左右就有点醉了 回楼顶睡觉 隔天起床的时候听见胡乃留和居子太太和爷爷在讨论因为没有红色纸而没有定下继承人的问题 其实爷爷是想折叠不同的纸鹤 用抓阄的方式 选定继承人的 这选定继承人的方式真的太随性了 小q继续去厨房吃早餐 然后见到爷爷带着酒过来 爷爷后来邀请小q去顶楼喝酒 小q饮到烂醉 一直睡到下午 然后坐车离开爷爷家 然后小q在睡梦中醒来 发现是在爷爷家 发现自己是掉进了时空黑洞 小q认为是1月2日掉进了时空黑洞 将会一直循环1月2日的事情</p>
<p>在第二轮小q认为的1月2日时 爷爷竟然意外地死了 小q认识到他是这些事件中的唯一变量 他的一举一动将会影响到整个事件的发生 在第二轮中他发现是本来有着隐藏的情侣关系的榴奈和富士高杀死了爷爷 所以在第三轮的时候 他决定拖着他们两个不让他们接近爷爷 然而 二女儿靠近了楼顶的爷爷 杀人事件再次发生 第四轮他决定将榴奈和富士高的事告诉舞 结果舞把爷爷杀死了 后来小q将各人叫过来开年会 杀人事件还是发生 无论小q如何阻止不让人接近爷爷 爷爷都会死 到后来才明白 爷爷其实是饮酒过多而死的 他没有死的那次其实是小q帮他分担了酒量 在其中一轮小q拿到了那些爷爷的日记并发现了很多爷爷的秘密 是他令两位女儿的丈夫失业的从而让他的女儿对他摇尾乞怜的 小q在其中一轮中向继承人之一（非家族内）的友理小姐表白了 后来在某轮中又发现友理说她有喜欢的人了 小q决定将这些事封锁在不曾发生的“历史”里 最后小q利用爷爷的秘密让爷爷不再饮酒 避免了死亡事件的发生 最终主角达到了他的目的 但是在这其中还存在这谜团 </p>
<p>最后友理小姐帮忙揭开了谜团 原来小q循环的不是1月2日 而是1月3日 并且有一天是他死了 所以他向友理小姐表白的事情是真实发生了 所以才会被她约出来 后来富士高竟然和榴奈分开了 继承人的事情变成没有定论了 全书完</p>
<p>总体来讲 这是一部轻小说 最后的逆转的确有点意思 但是又有些牵强的味道 读者根本不会猜到就算小q死了 循环还会继续发生这样的逻辑 更不会认为爷爷在1月2日和1月3日第一轮早上说出关于折纸的同样的话 但是总体来说作者的确做到了让人欲罢不能 是一本好书 值得一读</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为对这名字的猎奇心理而读的一本书 作者说这是一种科幻推理小说 建立在一个作者幻想的世界观下 然后进行推理的一种小说 小说题材新颖 尽管有相关的电影或电视题材 但是读书过程中通过作者的文笔可以感受到剧情的波澜起伏 引人入胜 有推理兴趣的同学都可以一读&lt;/p&gt;
    
    </summary>
    
      <category term="novel" scheme="http://luyaoming.com/categories/novel/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="死了七次的男人" scheme="http://luyaoming.com/tags/%E6%AD%BB%E4%BA%86%E4%B8%83%E6%AC%A1%E7%9A%84%E7%94%B7%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>运动记录10月份</title>
    <link href="http://luyaoming.com/2017/10/11/%E8%BF%90%E5%8A%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://luyaoming.com/2017/10/11/运动记录/</id>
    <published>2017-10-11T03:10:25.000Z</published>
    <updated>2021-06-16T01:30:35.994Z</updated>
    
    <content type="html"><![CDATA[<p>我想要一个好的身体 但是不是说说了事 打算写个记录贴监督下自己  记录日常的运动 </p>
<a id="more"></a>
<blockquote>
<p>只要有恒心 铁杵磨成针</p>
</blockquote>
<p>2017年10月11日</p>
<p>感受：跑的过程有点想呕吐的感觉 可能长期没运动的原因 起初先快步走 然后慢跑 然后在同一路段重复来回 设立短期目标 运动完后脚裸以上小腿有疼痛迹象 怀疑是热身运动没做够的后果  但是小腹明显感觉轻松 不再有鼓腹的感觉</p>
<p>明天继续 务必运动前做好热身 减少身体伤害</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171011.jpg" alt="20171011快步走和慢跑"></p>
<p>2017年10月12日</p>
<p>感受：小腿看来是慢慢适应这种运动状态了 第一天疼痛感强烈 第二天继续锻炼 已经不怎么疼了 今天的天气很舒服啊 有点凉风 选择了我昨天来回跑的路段 半走半跑 keep住啊！</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171012日.jpg" alt="keep2017年10月12日"></p>
<p>2017年10月13日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/%E8%BF%90%E5%8A%A820171013.jpg" alt="运动201710月13日"></p>
<p>感受：天气开始变凉 慢慢有点感觉 继续keep</p>
<p>2017年10月14日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/%E8%BF%90%E5%8A%A820171014.jpg" alt="2017年10月14日"></p>
<p>感受：今天的运动量稍微大啊 刚开始小腿大腿比较酸痛 跑了几个来回后 腿开始适应 习惯跑步的时候思考一些东西 使自己忘记了疲劳 明天是周日 也要keep住啊！ </p>
<p>10月18日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/20171018.jpg" alt></p>
<p>10月20日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171020.jpg" alt></p>
<p>10月23日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171023.jpg" alt></p>
<p>感受：今天开始 全程没有再停下来 现在基本上不会喘气 只是脚有点疼 但是坚持下来后 跑完整个人感觉很爽 明天继续</p>
<p>2017年10月25日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171025.jpg" alt></p>
<p>感受：全程没有停下来 右脚有点小疼 自从上星期去跟啊叔去完公园后 感觉右脚有点疼 双臂也有点疼 不应该一次性做过多剧烈运动 伤身体 以后注意</p>
<p>2017年10月31日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171031.jpg" alt></p>
<p>感受：用了一个小时运动 跑到后面基本上不觉得累了 呼吸也很顺畅 第一次在微信运动里拿了第一名 高兴了一会 右脚脚裸附近关节有些许疼痛感 注意热身</p>
<p>2017年11月3日</p>
<p><img src="http://quqnn25zc.bkt.gdipper.com/img/20171103.jpg" alt></p>
<p>感受：隔了两天没运动 感觉浑身不自在 这次也是跑了一个小时 基本没停过 感觉跑完很爽 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想要一个好的身体 但是不是说说了事 打算写个记录贴监督下自己  记录日常的运动 &lt;/p&gt;
    
    </summary>
    
      <category term="Sport" scheme="http://luyaoming.com/categories/Sport/"/>
    
    
      <category term="运动" scheme="http://luyaoming.com/tags/%E8%BF%90%E5%8A%A8/"/>
    
      <category term="记录" scheme="http://luyaoming.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>鬼吹灯-读书笔记</title>
    <link href="http://luyaoming.com/2017/10/08/%E9%AC%BC%E5%90%B9%E7%81%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://luyaoming.com/2017/10/08/鬼吹灯-读书笔记/</id>
    <published>2017-10-08T08:21:49.000Z</published>
    <updated>2021-06-15T01:08:34.839Z</updated>
    
    <content type="html"><![CDATA[<p>上学的时候 看过几部武侠小说 发觉自己都忘记了内容 看起电视的时候 叔叔和婶婶都回忆起故事情节 我却哑口无言 所以打算写点笔记 记下来看过的故事 情节也好 心得也好 好记性不如烂笔头 </p>
<a id="more"></a>
<blockquote>
<p>鬼吹灯 <br>原著：天下霸唱 <br>— — 读书笔记 by asii</p>
</blockquote>
<h2 id="精绝古城"><a href="#精绝古城" class="headerlink" title="精绝古城"></a>精绝古城</h2><p>胡八一的书《十六字阴阳风水秘术》从他祖父那辈得来 还是个残缺版 他祖父生前是个纨绔子弟 抽鸦片 卖了所有东西 抽鸦片 买个白纸当老婆 白纸变女鬼 祖父没钱用去挖掘坟墓 被女鬼挖了心肝 女鬼要他带人来给他吃心肝 途中遇到个道士 道士帮他消灭了女鬼 道士死前把这本《十六字阴阳风水秘术》传给了祖父 后来这书传到了胡八一手上 然后开始讲胡八一 在当兵的时候 胡八一和他的战友就遇到过火瓢虫 九层妖塔和霸王蝾螈   胡八一当兵的时候 在对战越南战役的时候 越南兵用妇女假装孕妇携带炸弹来做人肉炸弹 杀死了不少胡八一的战友 胡八一愤怒之下射杀俘虏 幸好没有上军事法庭 被撤职了  后来回到老家 见到了好友胖子王凯旋 两人和燕子进的第一个墓就遇到了大粽子 红吼 后来发现了日本的关东军地下要塞 还遇到了草原大地赖 他们打不死红吼 让大地赖和红毛互相残杀 最后拿走了两块玉 给大金牙帮忙卖了 大金牙介绍胡八一去沙漠探险队当领队 开始认识Shirley杨 找了个活地图 安力满 带着陈教授和他的一些学生开始去沙漠寻找精绝古城 两次被白骆驼救 找到了遗址 黑蛇杀人 胡八一破解石阵 找到了密道 找到了水源 找到了个大眼玉可惜被胡八一摔了 遇到了尸香魔芋 迷惑学生自相残杀 见到了很多黑蛇 最后五人逃进了密室 密室有图 预言家语言了进来5个人 然后4个人 其中一个打开二层石匣 暗示他们之中有魔鬼 绑了Shirley 真真假假 原来被尸香魔芋迷惑他们自相残杀 最后靠尸骨的食指指了一条明路 逃生</p>
<h2 id="龙岭迷窟"><a href="#龙岭迷窟" class="headerlink" title="龙岭迷窟"></a>龙岭迷窟</h2><p>由一只古老的鞋子做引子 这次是胡八一 胖子 大金牙三人的冒险 找到了鱼骨庙 鱼骨庙下面就是墓 他们找到了洞穴的虚位 要爬着进去 发现里面是唐代的墓穴 有唐代的壁画 但是又有西周的大脸鼎 后来不小心进入了悬魂梯 最后三人排成一排 避开了月牙的提示 才出得来 大金牙被人脸蜘蛛拖走了 胡八一和胖子救他 脱光了衣服 烧死蜘蛛 偶遇到稀有的闻香玉 巧克力味 没有淘到名器  就带着这玉出去了 然后开始说雪莉杨的前人鹧鸪哨 原来是搬山道人 为了找雮尘珠拜一个皈依佛教的人为师 该人之前是摸金校尉 进入了一个墓穴 带着一个途中遇到的神父 最后了尘师傅死了 鹧鸪哨没了只手臂 掏出来一块甲骨文的石头 胡八一和胖子身上长了红色的眼睛 追问了另一个教授 教授什么都不肯说 最后带着雪梨杨再去找他 期间认识了个算命瞎子 原来是个卸岭力士 他去过云南虫窟 没进去之前就被毒雾弄瞎了眼睛 但是倒出了一个描绘着云南虫窟的地图 根据那位教授提供的猜测 那个雮尘珠应该就在这里面 于是开始到云南的旅程</p>
<h2 id="云南虫谷"><a href="#云南虫谷" class="headerlink" title="云南虫谷"></a>云南虫谷</h2><p>这故事比较长 也是我认为一路看下来写得最精彩的一部 下面开始回忆 胡八一和雪莉杨和王胖子根据算命瞎子给的地图来到了云南 目标是献王墓 坐车去的期间在途中遇到个石人俑 破了 里面装满了恶心的虫子 然后他们乔装成博物馆抓蝴蝶的 来到了彩云客栈过一夜就出发 做了个竹筏就出发 一路上见到很多倒挂的石人俑 不知道触发了什么开关石人俑一个个掉进了水里 里面很多虫子会游泳追着他们的竹筏 遇到了青麟大蛇 这大蛇吃这些虫子 吃完后还要袭击他们的竹筏 胡八一他们的装备不好啊 差点打不过这凶猛的大蛇  后来出现了一堆刀齿蝰鱼 这鱼牙齿异常锋利 他们没有眼睛 哪里有血就去哪里 这大蛇被胡八一他们弄出了血 于是被这些吃人鱼围殴 吃人鱼搞点了大蛇后又来进攻竹筏 幸好他们找到了上岸的地方 到目前为止还没找到献王墓的入口 就一连受到了几波攻击 上岸后快到夜晚了 找到了两棵大树的地方过夜 三人约定轮流睡觉 忽然间从大树上传来了鬼信号 于是上树查看究竟 上面有一架飞机残骸 树下面还有个水晶棺 棺材里面还有个大祭司 红色肉线依靠吸附丢下来的生物的生命养分提供给水晶棺内的大祭司 三人在树上还受到了大鸟的攻击 他们把大祭司的身体拔出来还拿了里面的名器 次日出发寻找献王墓入口 找到入口后看见里面的蜻蜓虫子 蟾蜍都很大只 再遇到了很多漂浮的女尸 这女尸也是用身体养虫子 给带着面具的霍氏不死虫当零食 霍氏不死虫战斗力强大 将虫子的尸毒转化为毒瘴大雾封锁盗墓者进来 后来还是被王胖子用炸药炸死了 其实它只是暂时行动不了 霍氏不死虫吐出了一个箱子有三格 最后一格是一只蓝色三脚青蛙 其实是一个影响飞行航线的陨石 没有了霍氏不死虫吐出来的红色气体 那些女尸身上的胎儿开始脱落形成怪婴 三人慌忙逃脱 胡八一掉进了深潭 里面有飞机残骸 进入凌云宫殿 进去后发现非常华丽的装修 他们撬开一个煮尸鼎后听到诡异的笑声 发现红色衣服传过来的 胡八一让胖子去烧衣服 胖子贪心摸到了一块玉还舔了一下 被蛊附身 胡八一冒着被水银淹没的危险在墙壁里找到了玉函 胖子被蛊迷惑想吃尸体 被胡八一发现被挑出舌头肉刺 后来发现献王墓的墓道入口就在潭里 终于到了了献王墓的主墓室 里面三口棺材 其中一个还吊在空中 这三个棺材里装的都是献王的影骨 是他的前世骨头 后来发现了献王的老婆 尸体里还有飞蛾 飞蛾有毒 三人最后找到了最后的墓室 这墓室就是万年太岁化成的 里面有很多人手在不断拉人进去（脑补下） 胡八一找到了献王的棺材 割下了包含雮尘珠的献王人头 开始跑路 太岁发生尸洞效应 开始吞噬一切 三人逃出来一直被尸洞追着 雪莉杨还中了尸毒 幸好中途找到了个植物解毒 痋人（怪婴）与尸洞大战 痋人都被吸进去了 胡八一毁掉那个三脚青蛙 搭着霍氏不死虫的顺风车走出来 这尸洞一直追着献王的人头 胡八一几次想把人头还他了 最后把尸洞引到谷口 用“青龙顿笔”的风水毁了尸洞 三人终于得救 接着开始回忆胡八一当兵时候的支线剧情</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学的时候 看过几部武侠小说 发觉自己都忘记了内容 看起电视的时候 叔叔和婶婶都回忆起故事情节 我却哑口无言 所以打算写点笔记 记下来看过的故事 情节也好 心得也好 好记性不如烂笔头 &lt;/p&gt;
    
    </summary>
    
      <category term="novel" scheme="http://luyaoming.com/categories/novel/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="鬼吹灯" scheme="http://luyaoming.com/tags/%E9%AC%BC%E5%90%B9%E7%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全-读书笔记（二）</title>
    <link href="http://luyaoming.com/2017/02/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://luyaoming.com/2017/02/24/Linux命令行大全-读书笔记（二）/</id>
    <published>2017-02-24T13:07:47.000Z</published>
    <updated>2021-06-15T01:08:34.779Z</updated>
    
    <content type="html"><![CDATA[<p>配置与环境 主要涉及一些环境变量 vi操作 定制提示符 常见任务和主要工具</p>
<a id="more"></a>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>printenv 可以可以检查环境变量<br>printenv | less 可以输出到less中</p>
<p>set 显示shell变量 环境变量 以及任何已经定义的shell函数<br>set | less 查看</p>
<p>shell会话有两种类型 login和non-login的<br>login shell的启动文件有这些：/etc/profile  ~/.bash_profile  ~/.bash_login ~/.profile<br>non-login shell的启动文件有这些：/etc/bash.bashrc  ~/.bashrc</p>
<p>.bash_profile 一般会先读取用户的配置文件 ~/.bashrc 环境变量在PATH中 使用冒号:分隔开<br>最后export PATH</p>
<p>修改完环境变量后 可以不关闭shell窗口 直接 source .bashrc 读取一下生效</p>
<h2 id="使用vi"><a href="#使用vi" class="headerlink" title="使用vi"></a>使用vi</h2><p>i 就是insert的缩写 插入模式 </p>
<p> l h j k 这4个是移动光标命令 数字0移动到行首</p>
<p>o 字母o插入空白行 在当前行的上方  大写O插入空白行 在当前行的下方</p>
<p>x 删除当前字符 dd 删除当前行 5dd 删除当前行和以下的4行</p>
<p>u 撤销操作</p>
<p>yy 复制当前行 5yy复制当行行和以下的4行 yG复制当前行到文件末尾</p>
<p>fa 查找当前行的a字符</p>
<p>/neeee  斜杠搜索整个文件neeee字符的存在</p>
<p>:%s/Line/liss/g  搜索整个文件Line字符串 并且替换成liss 直到文件结尾 g后面加c 可以结合用户确认</p>
<p>vi file1 file2 打开多个文件 :n 切换下个文件 :N切换上个文件</p>
<p>:r tes1.txt 可以当前行插入tes1.txt的文件内容 </p>
<p>:w 保存文件 在命令模式下 大写ZZ可以保存并退出</p>
<h2 id="定制提示符"><a href="#定制提示符" class="headerlink" title="定制提示符"></a>定制提示符</h2><p>修改提示符  我们平时见到的 用户名@主机名：路径$ 可以被修改<br>例如先保存PS1的提示符 ps1_old=”$PS1” ps1=”\A \h |$ “ 提示符会变成 分钟 主机名 $<br>恢复修改过的提示符PS1=”ps1_old”</p>
<p>可以把PS1保存到.bashrc中 export PS1</p>
<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>主流软件包主要有两种.deb 和.rpm<br>.deb: 有Debian、 Ubuntu、 Xandros等<br>.rpm: 有Fedora 、CenOS 、Red Hat </p>
<p>目前我在使用Ubuntu系统 所以需要安装的是.deb的软件包</p>
<p>使用高级工具会自动安装依赖 sudo apt-get update 从库源中安装软件依赖 还有apt-get install emac</p>
<p>package_name 指软件包的实际名称 package_file 指软件包的文件名</p>
<p>如果是从网上下载的软件包 可以使用低级工具安装 此时不会安装依赖包 dpkg - -install packagefile.deb<br>或者rpm -i package_file.rpm</p>
<p>卸载软件包可以高级也可以用低级 如apt-get remove package_name 或者yum erase package_name</p>
<p>更新软件包 可以让系统一条命令更新从库源中获取到的所有更新包 apt-get update;apt-get upgrade</p>
<p>dpkg - -list 可以列出已经安装的软件包  dpkg - -status package_name 查看安装情况 apt-cache show package_name 查看已经安装的的软件包信息 dpkg - -search file_name 查看具体某个文件由哪个软件包安装得到</p>
<h2 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h2><p>less /etc/fstab 文件内容列出系统启动时挂载的设备 信息包含设备名 挂载节点 文件系统类型 等</p>
<p>sudo mount /dev/sdb1 /mnt/flash 将‘/dev/sdb1’文件设备挂载到‘/mnt/flash’目录下</p>
<p>mount 查看已经挂载的文件系统列表 on前面的设备名 on后面跟着的是挂载节点<br>如果要改这个挂载节点即文件的路径位置 要怎么改呢 要先卸载设备使用umount 设备名称<br>这个操作需要先获取超级用户sudo su -  然后cd到想要挂载节点的路径下 调用mount -t 设备类型 设备名 . 即可 调用ls即可查看挂载的设备文件内容 如果此时调动umount卸载会提示busy 需要先把工作目录切换到其他地方再调用 就ok了</p>
<p>sudo tail -f /var/log/messages 如果使用的系统不可以自动挂载设备 那么查看这个文件的最后几行可以查看到设备的文件名</p>
<p>sudo fdisk /dev/sdb 磁盘分区命令 输入m查看更多命令</p>
<p>sudo mkfs -t ext3 /dev/sdb1 为/dev/sdb1设备创建新的文件系统 格式为ext3<br>可配合格式化使用 如sudo fdformat /dev/fd0 格式化/dev/fd0这个设备 然后再创建新的文件系统 sudo mkfs -t vfat /dev/fd0</p>
<p>sudo fsck /dev/sdb1 检测设备问题 </p>
<p>dd命令可用于设备间转移数据 例如 dd if=/dev/sdb of=/dev/sdc  将sdb的文件内容转移到sdc设备 又或者转移到电脑 dd if=/dev/sdb of=flash.img 如果你要从一个光盘中创建一个iso镜像 可以这样dd if=/dev/cdrom of=ubuntu.iso </p>
<p>enisoimage命令允许我们从一个文件夹创建成一个iso镜像文件 如genisoimage -o cd-rom.iso -R -J  ~/cd-rom-file  就是把~/cd-rom-file这个文件夹以及包含的内容提取成cd-rom.iso 镜像 其中-R -J命令指在linux和window中可以使用较长文件名  这时我们已经可以把iso存在于一个光盘中  接着 就可以把该镜像文件挂载到硬盘的文件目录下 mount -t iso9660 -o loop cd-rom.iso /mnt/iso_image  但不需要时可以随时umount</p>
<p>wodim dev=/dev/cdrw blank=fast 擦除cd-rom 擦除类型为fast类型<br>wodim dev=/dev/cdrw image.iso 把/dev/cdrw文件目录写入到iso镜像文件中</p>
<p>md5sum image.iso 得到一个16位的字符串 校验iso镜像文件的完整性</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>ping baidu.com 向网络主机发送IMCP ECHO_REQUEST 数据包 验证网络是否接收正常 防火墙经常用来阻止IMCP通信 用ctrl+C来停止ping</p>
<p>traceroute baidu.com 跟踪网络数据包的传输路径 会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表</p>
<p>netstat -ie 检查网络数据</p>
<p>ftp fileserver_name  连接文件服务器 lftp 更好的ftp（支持下载重连 后台进程）</p>
<p>wget url   非交互式网络下载工具</p>
<p>ssh  remote-sys  安全登录远程计算机</p>
<p>scp remote-sys:document.txt .   使用ssh加密隧道进行网络间文件复制 不过不是本地系统的用户 需要在remote-sys前加用户名@    sftp则为安全的ftp版本 使用的不是ftp服务器而是ssh服务器</p>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>locate<br>较简单的方式查找文件 以寻找指定路径名与给定字符串相匹配的文件 例如查找bin路径下zip开头的文件 如 locate bin/zip<br>注意在macOs中 如果提示数据库没生成 需要输入<br><code>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist</code><br><code>sudo /usr/libexec/locate.updatedb</code></p>
<p>find<br>find可以根据文件的属性 在既定的目录（及其子目录）中查找 最简单的用户如 find ~<br>可以把标准形式输出的结果作为其他程序的输入 如 find ~ | wc -l<br>find 有test选项 action选项和options选项 先说test选项 使用-type可以指定文件类型 如find ~ -type f | wc -l<br>find支持的文件类型有b 块设备文件 c 字符设备文件 d 目录 f 普通文件 l 符号链接<br>可以查找所有符合<em>.jpg 通配符格式以及大小超过1mb的普通文件<br>`find ~ -type f -name “</em>.jpg” -size +1M | wc -l`<br>size支持的计量单位有b 512字节的块 c 字节 w两个字节的字 k M G<br>列出find命令常用的test参数</p>
<table>
<thead>
<tr>
<th style="text-align:left">test参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-cmin n</td>
<td style="text-align:left">匹配n分钟前改变状态内容或属性的文件或目录 不到 -n 超过 +n</td>
</tr>
<tr>
<td style="text-align:left">-cnewer file</td>
<td style="text-align:left">匹配内容和属性的修改时间比文件file更晚的文件或目录</td>
</tr>
<tr>
<td style="text-align:left">-empty</td>
<td style="text-align:left">匹配空文件以及空目录</td>
</tr>
<tr>
<td style="text-align:left">-group name</td>
<td style="text-align:left">匹配属于name组的文件或者目录</td>
</tr>
<tr>
<td style="text-align:left">-iname pattern</td>
<td style="text-align:left">与-name test选项功能类似 只是不区分大小写</td>
</tr>
<tr>
<td style="text-align:left">-newer file</td>
<td style="text-align:left">匹配内容的修改时间比file文件更近的文件和目录 例如备份后修改了文件可以使用此命令</td>
</tr>
<tr>
<td style="text-align:left">-size n</td>
<td style="text-align:left">匹配n大小的文件 不到-n 超过+n</td>
</tr>
<tr>
<td style="text-align:left">-type c</td>
<td style="text-align:left">匹配c文件类型的文件</td>
</tr>
<tr>
<td style="text-align:left">-user name</td>
<td style="text-align:left">匹配属于name用户的文件或者目录</td>
</tr>
</tbody>
</table>
<p>find命令还支持逻辑操作符 如我需要查找那些访问权限不是0600的文件和访问权限不是0700的子目录<br><code>find ~ \( -type f -not -perm 0600 \ ) -or \( -type d -not -perm 0700 \)</code><br>其中\是转义字符 逻辑操作符包括 -and -or -not </p>
<p>action选项<br>test选项用来查找那些文件那么action就是用来对找到的文件进行处理的 例如 -delete -ls -print -quit<br>也可以使用用户自定义操作 格式为 -exec command {} ;  例如 使用-exec完成-delete操作 -exec rm ‘{}’’;’ 这里使用引号为了避免在shell里直接编译 使用+结尾可以只执行一次命令 如<br><code>find ~ -type f -name &#39;foo*&#39; -exec ls -l &#39;{}&#39; +</code><br>使用xargs可以达到相同的效果 他是把前面的搜索结果作为 后面的命令的参数 如<br><code>find ~ -type f -name &#39;foo*&#39; | xargs ls -l</code><br>使用-ok可以询问用户是否执行 算是后悔药前的提醒吧<br> <code>find ~ -type f -name &#39;*bak&#39; -ok -delete</code></p>
<p>option选项<br>option选项用于控制find命令的搜索范围 如 -depth -maxdepth levels  -mount</p>
<h2 id="备份与归档"><a href="#备份与归档" class="headerlink" title="备份与归档"></a>备份与归档</h2><p>gzip -文件压缩<br>最简单的用法就是gzip ~/test/foo.txt  而解压就是gunzip  ~/text/foo.txt   加入-r参数可以递归压缩 gzip -d 相当于gunzip<br>bzip2 -以牺牲压缩速度来换取高质量的数据压缩<br>bzip2 ~/test/foo.txt  解压 bunzip2 ~/test/foo.txt</p>
<p>tar -磁带归档工具<br>创建归档文件tar cf test.tar testdir   而查看tar文件有什么内容 tar tf test.tar</p>
<p>zip - 打包压缩工具<br>zip程序即是文件压缩工具也是文件归档工具 常用zip -r test.zip test  加了-r是为了递归压缩子目录内容 unzip ../test.zip</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>grep -文本搜索<br>grep命令通常的格式是 grep [options] regex [file…]<br> grep bzip dirlist<em>.txt  在指定文件集合中搜索包含bzip字符的行<br>正则表达式的元字符包含^ $ . [ ]  { } - ? </em> + ( ) | \<br>grep包含很多选项 -i 忽略大小写 -v不匹配 -c输出匹配数目 -l输出匹配项文件名 -n 在匹配行前面加上该行在文件内的行号<br>-h 进行多文件搜索时 抑制多文件输出</p>
<p>任意字符 . 点<br>点表示任意的单个字符 必定存在一个占位符 例如 grep -h ‘.zip’ dist*.txt 输出结果不会只包含zip的文件</p>
<p>锚<br>在正则表达式里插入符^表示开头 $表示结尾<br>例如 grep -h ‘^zip’ dist<em>.txt 表示查找以zip开头的匹配项 grep -h ‘^zip$’ dist</em>.zip 查找以zip为单独一行的匹配符</p>
<p>中括号表达式和字符类<br>中括号用于匹配括号内的表示字符集的单个字符 例如 grep [abc] 表示查找的字符串可以包含a或者b或者c中一个<br>插入符^在括号内开头表示否定 例如grep -h  ‘’[ ^ bg]zip’ dir<em>.txt  表示匹配不以b或者g结合zip的字符串<br>中括号内的-表示字符范围 例如grep -h ‘^ [ A-Za-z0-9 ]’ dir</em>.txt 表示匹配以字母或数字开头的字符串</p>
<p>? 匹配前面的元素0次或1次  * 匹配某元素多次或0次  + 匹配某元素一次或者多次  {n}指定重复出现n次</p>
<p>举例：电话号码的出现形式 (nnn)nnn-nnnn  和 nnn nnn-nnnn 中的一种 可以使用以下两种方式匹配<br>第一种： <code>^\(?[0-9][0-9][0-9]\)?  [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</code><br>第二种：<code>^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$</code><br>如果想验证上面正则表达式的有效性 可以使用如：<br><code>echo &quot;(555) 123-4567&quot; | grep -E ^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$</code>  如果有结果打印出来证明有效</p>
<p>vim和less都支持正则表达式 在底部输入 / 符号后开始输入正则表达式 匹配的内容会自动标注 zgrep命令可以对压缩文件进行搜索</p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>cat 进行文件之间的拼接 并且输出到标准输出<br>如： cat &gt; ff.txt  然后输入一段文字后 按ctrl+D 结束输入 那么输入的文字会输出到文件末尾<br>将两个文件合并成一个文件 如果两个都是字符串内容就直接进行拼接 cat foo1.txt foo2.txt &gt; foo3.txt<br>cat的一些选项<br>-n 对行编号 -s 禁止输出多个空白行  用法如 cat -ns foo.txt   也可以不加任何选项 使用cat foo.txt输出</p>
<p>sort 对文本进行排序 如sort &gt; foo.txt 将等下输入的内容进行排序并且输出到foo.txt文件内<br>sort 直接对一个文件进行排序 sort foo.txt<br>sort的选项 -f 排序时不区分大小写 -r 逆序排序  -n按字符串的长度排序而不是按字母表顺序<br>可以排序多个文件的内容并进行拼接 如sort foo1.txt foo2.txt foo3.txt &gt; foo4.txt<br>sort命令还可以配合du命令进行使用 du命令是用来显示文件或者目录所占的磁盘空间大小的命令<br>例如 du -ha ~/hexo | sort -nr | head 输出hexo目录下前10个按内容大小从大到小排序的文件名称和大小</p>
<p>uniq 通知或者省略重复的行 注意uniq只对排序好的行起作用 一般配合sort命令使用<br>如 sort -r foo.txt | uniq<br>uniq的选项 -c 输出重复行 并且前面加上出现的次数 -d只输出重复行而不包含单独行</p>
<p>comm 逐行比较两个已经排序的文件<br>如 comm 1.txt 2.txt   然后会输出三列内容 第一列表示第一个文件独有的行 第二列表示第二个文件独有的行 第三行表示两个文件所共有的行   可以使用选项省略这三列内容的哪些列 如 comm -12 1.txt 2.txt 省略第1 2列的内容 </p>
<p>tr 替换或者删除字符<br>如 cat foo.txt | tr a-z  A-Z  将foo.txt里的内容 小写转为大写<br>echo “dadadaaaa”  | tr aaaa bbbb 将字符串里的aaaa替换成bbbb<br>cat foo.txt | tr -d ‘da’ 将foo.txt里的内容删除da</p>
<p>sed 用于文本过滤和转换的流编辑器<br>如 echo ‘front’ | sed ‘s/front/back’ 输出为back 意义是将front转换成back 斜杠是分隔符也可以使用其他分隔符如下划线<br>可以指定只替换第几行 如 echo “front” | sed ‘1s_front_back’ 只替换第一行的front </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置与环境 主要涉及一些环境变量 vi操作 定制提示符 常见任务和主要工具&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://luyaoming.com/categories/Linux/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://luyaoming.com/tags/Linux/"/>
    
      <category term="shell" scheme="http://luyaoming.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全-读书笔记（一）</title>
    <link href="http://luyaoming.com/2017/02/15/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luyaoming.com/2017/02/15/Linux命令行大全-读书笔记（一）/</id>
    <published>2017-02-15T13:58:54.000Z</published>
    <updated>2021-06-15T01:08:34.777Z</updated>
    
    <content type="html"><![CDATA[<p>记录下自己学习加复习Linux命令行的过程</p>
<p>这部分笔记也记录在代码工具snippets中 奈何未开通分享功能 只保留在mac中 所以上传到此</p>
<a id="more"></a>
<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><p>有什么不懂可以 命令符号 –help查看如何使用 也可以help 命令</p>
<p>less 打开文本<br>less file</p>
<p>mv 移动或者重命名<br>mv file1 file2 </p>
<p>ls 列出文件列表<br>ls -l 文件列表详情<br>ls -F 文件格式（是否文件夹）<br>ls -t 按时间排序<br>ls -r 反向排序 （默认按字母 加上-t就是按时间反向排序）</p>
<p>cd 打开目录<br>cd dir<br>cd .. 父目录（相对路径）</p>
<p>mkdir 创建文件<br>mkdir dir1</p>
<p>cp 复制文件<br>cp file1 file2 dir</p>
<p>file 参看文件类型<br>file filename</p>
<p>ln 创建硬链接<br>ln file file-link 创建硬链接 （无法指向文件）<br>ln -s dir dir-link 创建符号链接 （可以指向文件）</p>
<p>type 参看命令的类型<br>type cd</p>
<p>which 显示可执行程序的位置<br>which ls</p>
<p>man 显示程序的手册页<br>man ls</p>
<p>apropos 显示合适的命令（按关键字搜索）<br>apropos sym</p>
<p>whatis 显示命令的重要描述<br>whatis ls</p>
<p>info 显示程序的info条目<br>info ls</p>
<p>alias 为命令添加别名 (直接输入alias 可以查看所有定义过的别名)<br>alias foo=’cd /usr; ls; cd -‘ </p>
<p>unalias 删除别名<br>unalias foo</p>
<p> 重定向符号 可以重定向标准输出和标准错误</p>
<p>ls -l /usr/bin &gt; ls-output.txt (把ls -l /usr/bin 命令执行的结果输出到该txt文本中)<br>执行ls命令失败会清空ls-output.txt的内容 相当于把空白覆盖到之前的内容<br>使用&gt; testClear.txt 重定向命令可以创建 testClear.txt文件或清空该文件的内容<br>使用ls -l /usr/bin &gt;&gt; ls-output.txt 注意&gt;&gt; 符号表示在ls-output.txt内容的末尾最佳内容而不是覆盖</p>
<p>2&gt; 标准错误重定向<br>ls -l /bin/usr 2&gt; ls-error.txt (把ls -l /bin/usr 命令执行错误时 错误信息输出到该txt文本中)<br>注意0代表标准输入文件 1代表标准输出文件 2代表标准错误文件</p>
<p>2&gt;&amp;1 重定向到同一个文件<br>ls -l /usr/bin &gt; ls-out.txt 2&gt;&amp;1 (把标准输出和标准错误到输出到ls-out.txt文件中)<br>或者ls -l /usr/bin &amp;&gt; ls-out.txt 也可以达到同样的效果</p>
<p>dev/null 位桶 接收输入但不对输入做任何处理</p>
<p>cat 标准输入重定向<br>cat ls-output.txt 显示txt文本内容<br>cat movie.mpeg.0* &gt; movie.mpeg 接收多个file并且合并成一个<br>cat &lt; ls-output.txt 把标准输入的源从键盘变成ls-output.txt文件</p>
<p>| 管道符号 把一个命令的标准输出 传送到 另一个命令的标准输入中<br>ls -l /usr/bin | less 把|前面的结果传送到less命令的标准输入中<br>（就是说把一个命令的结果通过分页(文本)形式显示）</p>
<p>管道过滤 sort<br>ls -l /usr /usr/bin | sort | less 把这两个目录执行一次排序后 通过分页方式显示出来<br>uniq 显示重复行或去除重复行<br>ls -l /usr /usr/bin | sort | uniq | less 使用uniq去除重复行 使用uniq -d 显示重复行</p>
<p>wc 打印行数 字数 字节数<br>wc ls-output.txt<br>wc 直接打此命令后return 会接收键盘标准输入 按ctrl+d结束输入<br>wc -l ls-output.txt 只显示行数</p>
<p>grep 搜索匹配字符的过滤<br>ls -l /bin /usr/bin | sort | uniq | grep bin | less  这段代码列出匹配包含“bin”字符的文件或文件夹<br>grep -i bin 选项可以忽略大小写</p>
<p>head / tail 过滤前10行或者后10行<br>head ls-output.txt<br>head -n 5 ls-output.txt 只输出前5行<br>tail -f /var/messages 使用-f可以持续监控这个文件 一旦添加新行 就显示在屏幕上 ctrl+c结束</p>
<p>tee 从标准输入读取数据 并同时输出到标准输出和文件中<br>ls -l /usr/bin | tee ls-output.txt | grep bin tee相当于一个T型管道 分流到tee中的文件 又继续向下传递下去</p>
<p>echo 输出一行文本<br>echo * 输出该目录下所有文件名<br>echo $((3+4)) 输出7 使用echo加表达式 这种叫算术扩展 只支持整数<br>echo fontstr{a,b,c}backstr 将打印三个字符串<br>echo {1..5} 将打印1到5个数字<br>echo {Z..A} 将打印Z到A倒序的字母<br>参数扩展用在shell脚本中比直接用在命令行中更为有用</p>
<p>$ (命令) 代替命令 把一个命令的输出作为另一个命令的输入<br>ls -l $(which cp) 把cp命令的路径作为ls的入参 输出cp的详细信息</p>
<p>使用双引号去除不想要的扩展 空格<br>ls -l “tes 1.txt” 例如tes 1.txt是一个带空格的文件名<br>ls -l “$((9+3)) $(cal) {1..6}” 双引号下算术扩展 参数扩展 命令替换 依然生效</p>
<p>使用单引号可以去除所有的扩展<br>echo -l ‘$(ls)’ 将只会输出$(ls)</p>
<p>反斜杠作为转义字符<br>echo “the pen is \$3.00” 可以成功输出$<br>echo -e “dada \ndada” \n是换行转义字符 加上参数e才可生效 -r回车 -t 制表</p>
<p>history<br>显示输入过的命令历史</p>
<p>几个常用的移动光标的快捷键<br>ctrl+A 移动光标到行首<br>ctrl+E 移动光标到行尾<br>ctrl+L 清屏并把光标移动到左上角 和clear相似</p>
<p>修改命令行文本快捷键<br>ctrl+D 删除光标处的字符<br>ctrl+K 剪切从光标开始到行尾的文本<br>ctrl+U 剪切从光标开始到行首的文本<br>ctrl+Y 把kill-ring缓冲区中的文本黏贴到光标位置<br>tab 自动补齐功能</p>
<p>history 查看命令的使用历史</p>
<p>文件属性 r (read) ：运行打开和读取  w(write): 允许写入和截短文件 x：允许文件当作程序来执行<br>使用ls -l test.txt 就可以看到文件属性 组成格式：文件类型 所有者权限 组权限 其他用户权限</p>
<p>chmod 更改文件模式 只有超级用户和文件所有者才有权更改</p>
<p>可以用8进制数字来表示文件的属性 例如文件模式rwx 二进制位111 8进制为7  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmode 600 foo.txt 表示把该txt文件的权限改为 rw- --- --- </span><br><span class="line">常用的二进制和8进制的映射是这几个：7(rwx) 6(rw-) 5(r-x) 4(r--) 0(---)</span><br></pre></td></tr></table></figure>
<p>用户权限 符号表示法：u表示user g表示群组 o表示其他人 a表示所有如果没有指定字符默认是a 而+表示增加一种权限 -表示删除权限 =表示只有指定权限可用 其他所有权限被删除<br>u+x 为文件所有者添加可执行权限<br>u-x 删除文件所有者的可执行权限<br>+x 为所有用户添加可执行权限 相当于a+x<br>o-rw 删除其他所有用户的读写权限<br>go=rw 除了文件所有者之外 设置所属群组和其他用户具有读写权限<br>u+x,go=rx  指定多种权限时 用 , 分割</p>
<p>umask 设置默认权限 例如 umask 0022 就是去除群组和其他用户的w权限 理解下mask就是遮盖的意思 0022实际是由三个二进制组成像这样 000 000 010 010 对应的是<code>--- rw- r-- r--</code></p>
<p>su 用另一个用户的身份来启动shell 可以用su -l 或者su - 启动 执行命令的格式是su -c ‘ls -l’<br> 默认是没有设置root密码的  sudo passwd root 来设置密码<br>sudo 不需要输入超级用户密码 不需要进入启动新的shell环境 命令不需要用单引号</p>
<p>chown 更改文件所有者和所属群组<br>sudo chown tony: ~tony/myfile.txt  把myfile.txt文件的文件所有者改为tony</p>
<p>chgrp 更改文件所属群组 与chown使用方式相似</p>
<p>passwd 更改用户密码<br>sudo passwd asii 可以指定更改asii用户的密码 直接passwd就是更改用户自己的密码</p>
<p>ps 当前所有进程的运行情况<br>ps x 显示所有进程</p>
<p>top 动态查看进程信息 相当于window的任务管理器</p>
<p>ctrl+c 终端进程 ctrl+z 暂停进程 </p>
<p>vim &amp; 在后台运行vim进程</p>
<p>jobs 查看作业中的进程</p>
<p>fg %1 把后台进程还原到前台<br>可以先jobs查看作业中的进程 然后bg %[作业编号] 把进程已到后台运行 也可以fg %1移动到前台进行<br>如果忘记使用&amp;来运行后台进程 那么可以先ctrl+z暂停当前进程 再bg %1让他运行于后台</p>
<p>kill 进程pid 中止进程 killall 进程名称 ：中止多个进程</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下自己学习加复习Linux命令行的过程&lt;/p&gt;
&lt;p&gt;这部分笔记也记录在代码工具snippets中 奈何未开通分享功能 只保留在mac中 所以上传到此&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://luyaoming.com/categories/Linux/"/>
    
    
      <category term="读书笔记" scheme="http://luyaoming.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://luyaoming.com/tags/Linux/"/>
    
      <category term="shell" scheme="http://luyaoming.com/tags/shell/"/>
    
  </entry>
  
</feed>
