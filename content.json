[{"title":"测试迁移hexo到另一台主机","date":"2021-06-15T01:14:45.000Z","path":"2021/06/15/测试迁移hexo到另一台主机/","text":"最近买了台新电脑 默认win10系统 为了开发方便 装了wsl2 捣鼓编译环境 之前在mac Os上写日记更新hexo 买了新电脑图新鲜 想使用windows继续更新 下面简单记录下迁移hexo到另一台电脑遇到的一些问题 安装和配置思路很简单：备份mac上的hexo文件到gitee 另一台电脑下载下来 然后通过npm 安装软件 顺便说说这样做得好处：上传数据而非u盘拷贝 是为了每次更新方便 不用u盘考来考去 gitee是国内的 比github快 且区分一个发布用 一个备份用比较清晰 把hexo备份到https://gitee.com/asii2020/myhexo 目录下 记得上传之前 把.gitignore文件的内容删除或注释掉 把所有文件先上传 换电脑 切换到新建的hexo目录下 git clone https://gitee.com/asii2020/myhexo 下面是在wsl2的环境下安装 重新执行sudo cnpm install –force 如果出现hexo-rederer-sass 安装失败 执行 sudo rm -rf node_moudles cnpm install –save node-sass cnpm install 接着测试 hexo new “测试迁移hexo到另一台主机” hexo g hexo d 插入图片最近发现七牛提供的图床服务不好使了 我之前写的文章里带图片都不显示了 发现原来现在他内部改革了 国内的域名需要备案才可以上传和浏览图像 我在16年搞建站的时候 没有这回事 很简单地就生成了图片链接了 之前的空间划分在华东 由于我的域名是godaddy申请的 属于美国地区 内容空间提供商是github也在美国 没办法在国内备案 没办法 只能在七牛上新建一个北美地区的空间 迁移华东的图片到北美的空间 使用他们提供的脚本 发现不同区域的不能迁移 还好站点的图片我有备份在上一台电脑上 只能重新上传了 这时候七牛给我分配了一个图片服务的测试地址quqnn25zc.bkt.gdipper.com 期间我一直纠结 是否继续使用七牛 因为他们提供的北美空间是有回收期限的 30天后自动回收 为应对这个机制 可以在七牛新建空间（同区域） 并且迁移内容到新的空间 然后替换博客内容的图片地址 具体操作看这个链接 []: https://segmentfault.com/a/1190000018196548 “七牛测试地址被回收了怎么办” 如果不使用图床 可以使用hexo-asset-image或者hexo-image-link等插件来插入图片 个人尝试了一下 发现不好使 图片依然不显示 下面介绍使用typora和picgo的方式插入图片的方法 首先 使用typora的文件–偏好设置–图像 设置如图所示 这里 上传服务我选择了picgo app 可以直接使用gui进行配置 然后进入格式-图像-插入图片时-上传图像 这样可以很方便在typora上右键插入图片或者复制粘贴粘贴板的图像到文章里都可以了 也不需要自己按照固定路径放置图片等操作 只要插入操作 就会触发上传了 相当无脑 我喜欢 有时候插入后 hexo d -g 没有显示图片立马出来 不用担心 只要确认七牛上传的地址能够在浏览器上load到图片就可以了 网页会稍后才生效 还有网站和图片部署在美国 也可能是导致图片出来慢的原因吧 测试插入图片","categories":[],"tags":[]},{"title":"Primer cpp 第五版读书笔记（六）","date":"2021-05-31T06:49:18.000Z","path":"2021/05/31/Primer-cpp-第五版读书笔记（六）/","text":"主要记录c++的动态内存 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii ##十二，动态内存 动态内存和智能指针 我们之前介绍了静态内存和栈内存 静态内存用来保存局部static对象 类static的数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象 分配在静态或栈内存中的对象由编译器自动创建和销毁 对于栈对象 仅在其定义的程序块运行时才存在 static对象在使用前被分配 在程序结束时销毁 在c++中 使用new分配空间并返回一个指向该对象的指针 使用delete来销毁对象并释放与之关联的内存 新的标准库采用智能指针来管理动态对象 类似于常规指针 重要的区别是负责自动释放所指向的对象 使用shared_ptr允许多个指针指向同一个对象 使用unique_ptr来独占所指向的对象 使用weak_ptr作为弱引用 指向shared_ptr所指向的对象 这些类型都定义在memory头文件中 //下面是shared_ptr和unique_ptr都支持的操作shared_ptr&lt;T&gt; sp // 空智能指针 可以指向类型为T的对象 使用if(sp)可以判断是否已经指向某个对象 使用*sp解引用sp 获得他所指对象unique_ptr&lt;T&gt; upp -&gt; mem // 等价于 (*p).memp.get() // 返回p中保存的指针 小心使用//shared_ptr独有的操作make_shared&lt;T&gt; args // 返回一个shared_ptr 指向一个动态分配的类型为T的对象 使用args初始化该对象shared_ptr&lt;T&gt; p(q) //p是shared_ptr q的拷贝 此操作会递增q的计数器 q中指针必须能转换成T*p = q // p和q都是shared_ptr 所保存的指针可以相互转换 此操作递减p的引用计数 递增q的引用计数 若p的引用计数为0 则其管理的原内存释放p.unique() // 若p.use_count()为1 返回true p.use_count() //返回与p共享对象的智能指针数量 可能很慢 用于调试 使用make_shared是最安全的分配和使用动态内存的方式shared_ptr&lt;int&gt; p3=make_shared&lt;int&gt;(42); 更简单地 使用auto来保存auto p6=make_shared&lt;vector&lt;string&gt;&gt;(); 当进行拷贝和赋值操作时 每个shared_ptr都会记录有多少个shared_ptr指向相同的对象 当拷贝一个shared_ptr时计数器会递增 一旦shared_ptr的计数器为0 他就会释放自己所管理的对象 举例 auto r = make_shared&lt;int&gt;(42);//r指向的int只有一个引用r = q;//给r赋值 他指向另一个地址 递增q指向的对象的引用计数 递减r原来指向的对象的引用计数 r原来指向的对象已经没有引用者 会自动释放","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"十步学习法","date":"2021-05-28T07:58:40.000Z","path":"2021/05/28/十步学习法/","text":"采摘自《软技能-代码之外的生存技能》 第一步：了解全局比如学习一门语言 应该了解下他的应用领域 支持平台 编译环境 语法树目录 对比其他语言的优势 提供学习的动力 有个大概的框架 需要有一个全局的认识 第二步：确定范围集中精力明确到底要学什么 在任何项目中 明确项目范围是至关重要的 唯有这样才能了解项目的全局 做好相应的准备 学习如是 不要试图全面掌握所有知识 可能你真正需要用到的就是全局里的20% 需要明确你要解决的问题在哪个学习的范围 选择一个专注而且聚焦的范围 潜心学习吧 范围务必大小适当 要符合自己的时间规划 示例： 定义初始的主题：学习c++ 再定义分解的子主题：学习c++的基础知识 学习如何创建一个简单的控制台程序 第三步：定义目标有了范围之后 目标其实很好定义 努力简明清晰地陈述 勾勒出你勤奋学习后的成功图像 并且明确其中具体的成功标准 从而更加充分地评估自己是否达成学习目标 好的成功标准应该是具体的 无二义性的 示例： 一个不好的目标：我学习了关于C++语言的基础知识 好的目标：我可以利用C++的基础知识写出一个小的应用程序 第四步：寻找资源不能只从一本书或一个人那里获取学习的资源 需要多方面的资源来整合 可以从下面这些方面去寻找资源： 图书 博客文章 在线视频 专家或者对此方面已经熟悉的人 播客 源代码 示例项目 在线文档 第五部：创建学习计划看书时 我们经常看到书的目录是层层递进的 创建自己的学习路径 把它看成是自己写书的大纲 还有一个好方法是 观察别人是如何教你感兴趣的主题的 第六步：筛选资源对拿到的资源进行筛选 利用最有价值的来实现自己的目标 没有必要把所有资源都利用一遍 因为肯定有重复的 就像买书时 只需要最能体现主题的3-4本即可 就像我学习c++ 共挑选了4本书 第七步：开始学习 浅尝辄止学习过程中通常犯的两类错误：1，在知道不多的情况下盲目开始 行动太快 2，行动之前准备太多 即行动过慢 需要在两者之间取得平衡 不要溺死在知识海洋中 要做一个懂得游泳的人 每次只使用一种泳姿 学会了再换另一种 第八步：动手操作 边玩边学没有什么比兴趣更能成为自己的老师 哎 就是玩 只有从中感受到乐趣了才会更加深入地去探索 多动手 不要只停留在耳朵和口 慢慢就会习惯了 印证了古语有云：无他 唯手熟尔 第九步：全面掌握 学以致用这一步的目标是找回好奇心 好驱动你的学习 回顾一些遗漏的知识 让自己在这个领域更加全面 并用在具体的地方 第十步：乐为人师 融汇贯通走出舒适区 将自己学到的知识教给别人 这是学习最高最有效率的方式 可以用多种方式教别人 例如写博客 分享会 从中把之前没明白的事情弄明白了 并且复习了之前的知识","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"学习方法","slug":"学习方法","permalink":"http://luyaoming.com/tags/学习方法/"}]},{"title":"Primer cpp 第五版读书笔记（五）","date":"2021-05-25T03:04:15.000Z","path":"2021/05/25/Primer-cpp-第五版读书笔记（五）/","text":"主要记录c++的泛型算法和关联容器 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii ## 十，泛型算法标准库并未为每个容器定义成员函数来实现一些算法操作 如查找特定元素 替换或删除一个特定值 重排元素顺序等 而是定义了一个泛型算法放在头文件algorithm 和numeric中 现在想来 排序 替换 查找 删除这些操作完全可以不依赖于特定的容器 他们是一些公共的操作 只需要提供迭代器 操作迭代器既可以达成目的 常用的算法有 求和 int sum = accumulate(vec.cbegin(),vec.cend(),0); 比较算法 auto e1 = equal(vec.cbegin(),vec.cend,list1.cbegin()); 这里vec可以是vector 而list1可以是list 写容器算法 fill(vec.begin(),vec.begin()+ vec.size()/2,10); 插入迭代器 fill_n(back_insert(vec),10,0); 拷贝算法 auto ret = copy(begin(a1),end(a1),a2); 从a1到a2的拷贝 ret指向拷贝到a2的尾元素之后的位置 替换算法 auto replace1 = replace_copy(ilst.begin(),ilst.end(),0,42); 将所有值为0的元素都改为42 按字典排序 sort(words.begin(),words.end*()); 消除重复项 auto end_unique =unique(words.begin(),words.end()); 删除重复项 words.erase(end_unique,words.end()) 上面的消除重复项并没有真正的删除重复的元素 只是放在序列的后面 而返回的end_unique指针指向最后一个不重复元素的后面 所以需要对容器进行删除操作才把重复项删除掉 除了可以按字典排序外 sort函数可以接收一个比较函数（谓词）来实现不同的排序方式 类似于java中的comparor比较器 bool isShorter(const string &amp;s1,const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125;sort(words.begin(),words.end(),isShorter);//传入比较函数 stable_sort函数可以保证相等元素的相对位置不变 是sort的升级版 对比sort 在排序后 sort是不保证相等元素会按之前的顺序排序 而stable_sort可以做到这一点 lambda表达式是一个可调用对象 表示一个可调用的代码单元 可以将其理解为一个未命名的内联函数 一个lambda表示的形式如[capturelist](parameter list) -&gt; return type { function body } 其中capturelist是一个lambda所在函数中定义的局部变量的列表 其他的望文生义 有时可以忽略参数列表和返回类型 但是必须包含局部变量列表和函数体auto f = [] {return 42}; 返回类型可以通过函数体推断出 这里是返回整数类型 使用lambda表达式来表示上面提到的isShorter函数 [](const string &amp;a,const &amp;b)&#123;return a.size() &lt; b.size();&#125;//再将isShorter函数添加到sort函数时sort(words.begin(),words.end(), [](const string &amp;a,const &amp;b) &#123;return a.size() &lt; b.size();&#125;); 使用for_each函数代替循环体打印例如 for_each(wc,word.end(),[](const string &amp;s){cout &lt;&lt; s &lt;&lt; &quot; &quot;;}); 在lambda表达式中如果要捕获引用 必须要保证在lambda执行时 绑定到迭代器 或指针 或引用的对象依然存在并且保证对象具有预期的值 因为在lambda创建到执行的过程中有可能代码会改变绑定的对象的值 //将words按字典排序并删除重复元素 使用os流输出大于sz长度的字符串 并以c隔开void biggies(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz, ostream &amp;os = cout,char c = ' ')&#123; sort(words.begin(),words.end()); auto end_unique = unique(words.begin(),words.end()); words.erase(end_unique,words.end()); //稳定重排 按字符串长度大小为基准重排 重复元素保持之前的字典排序 stable_sort(words.begin(),words.end(), [](const string &amp;a,const string &amp;b)&#123; return a.size() &lt; b.size(); &#125;); //找到长度大于等于sz的字符串的迭代器 auto wc = find_if(words.begin(),words.end(), [sz](const &amp;a)&#123; return a.size() &gt;= sz; &#125;); //计算距离 由于已经经过排序wc迭代器之后的元素长度必定都大于等于sz auto count = word.end() - wc; cout &lt;&lt; \"length = \" &lt;&lt; count &lt;&lt; endl; //打印这些长度大于等于sz的元素 for_each(wc,words.end(),[](const string &amp;s)&#123; cout &lt;&lt; s &lt;&lt; \" \"; &#125;); &#125; lambda表达式的破获列表[capturelist] 可以分为隐式捕获和 显式捕获 区别就是隐式捕获会隐藏变量名 让编译器自动推断我们使用哪些变量 其中使用 &amp; 表示捕获引用方式 =表示值捕获 捕获列表里的参数为局部变量 默认情况下 对于一个值被拷贝的变量 lambda不会改变其值 但是如果希望可以改变 使用mutable关键字auto f = [v1]()mutable{return ++v1;} 在我们使用lambda时他的函数体是一个单一的return语句 编译器可以推断出他的return类型所以可以忽略不写 但是如果将单一的return语句替换成if else语句 就需要使用尾置返回类型来表示了 transfrom(vi.begin(),vi.end(),vi.begin, [](int i)&#123;return i&lt;0 ? -i : i;&#125;);//正确 单一的return语句 编译器可以推断return类型 无需显式表示transfrom(vi.begin(),vi.end(),vi.begin, [](int i)&#123;if(i&lt;0)return -i;else return i;&#125;);//错误 编译器推断他将返回void 但他返回了int值 //如果一定要使用if else语句 那就需要显式定义返回类型 使用尾置返回类型transfrom(vi.begin(),vi.end(),vi.begin, [](int i) -&gt; int &#123;if(i&lt;0)return -i;else return i;&#125;);//正确 定义返回int 参数绑定 对于只用到一两个地方使用的简单操作 使用lambda表达式是最佳的 但是如果很多地方用到同样的lambda时 每次都要编写同样的lambda表示式明显不利于代码重写 此时我们想到使用函数来代替lambda表达式是最简单的 如果lambda表示式的捕获列表为空这非常方便做到 但是如果捕获列表不为空 就需要解决向形参传递参数的问题了 标准库bind函数应运而生 他可以解决向函数的参数传递带参数的函数问题 定义在头文件functional中 看做一个通用的函数适配器 可接受一个可调用对象 生成一个新的可调用对象来适应原对象的参数列表 形式auto newcallable = bind(callable,arg_list); 其中arg_list中包含参数如_n的参数 n为整数 表示传递给newcallable的参数的位置 _1表示newCallable的第一个参数 _2表示第二个参数 bool check_size(const string &amp;s,string::size_type sz)&#123; return s.size() &gt;= sz;&#125;auto check6 = bind(check_size,_1,6);//只有一个占位符 表示check6只接受单一参数 出现在arg_list中的第一个位置string s = \"hello\";bool b1 = check6(s);//check6(s)会调用check_size(s,6)auto wc = find_if(words.begin(),words.end(), [sz](const &amp;a)&#123; return a.size() &gt;= sz; &#125;);//使用bind替换find_if的lambda表达式auto wc = find_if(words.begin(),words.end(), bind(check_size,_1,sz));//正确auto wc = find_if(words.begin(),words.end(), check_size(words,sz));//错误 找不到sz//上面的参数_1是在placeholders命名空间中定义的 逐个引入有点麻烦 使用以下方式using namespace std::placeholders;//若arg_list不止一个参数 可包含多个占位符_1 _2auto g = bind(f,a,b,_2,c,_1);//上面的f函数使用了5个参数 其中三个已经可以定下来 剩下两个可通过g调用对象设置g(_1,_2) //将会映射成bind(f,a,b,_2,c,_1) 插入迭代器 使用back_inserter or front_inserter或 inserter来生成插入迭代器 使用插入迭代器赋值语句*it = val 相当于 it = c.insert(it,val);++it; iostream迭代器 标准库中定义了可以用于这些IO类型对象的迭代器包括istream_iterator 和 ostream_iterator 这些迭代器将他们对应的流当作一个特定类型的元素序列来处理 输入输出流迭代器只支持递增 不支持递减 istream_iterator&lt;int&gt; in(cin),eof;//初始化输入流迭代器 一个已经构造 一个空vector&lt;int&gt; vec(in,eof);//从迭代器范围构造veccout &lt;&lt; accmulate(in,eof,0) &lt;&lt; endl;//对流中的元素求和 比循环输入的值求和方便多了ostream_iterator&lt;int&gt; out_iter(cout,\" \");for(auto e : vec)&#123; *out_iter++ = e;//赋值语句实际上将元素写到cout&#125;//可以通过copy来打印vec的元素 比编写循环更加简单copy(vec.begin(),vec.end(),out_iter);cout &lt;&lt; endl; 算法形参模式 大多数算法具有以下4中形式之一 alg(beg,end,other args);alg(beg,end,dest,other args);alg(beg,end,beg2,oter args);alg(beg,end,beg2,end2,oter args); 注意 对于list和forward_list 应该优先使用成员函数版本的算法而不是通用算法 十一，关联容器下面列举c++标准库的8个关联容器 //按关键字有序保存元素map //关联数组 保存关键字 -值对set //只保存关键字的容器 multimap //关键字可重复的mapmultiset //关键字可重复的set//无序集合unordered_map //用哈希函数组织的mapunordered_set //unordered_multimap //哈希组织的map 关键字可以重复出现unordered_multiset // 要对容器的元素进行排序 那么就需要比较 就需要给出比较操作的定义 一般的基本类型不需要明确给出 但是自定义的类型就需要给出 pair类型 定义在utility头文件中 包含两个数据成员 是一个用来生成特定类型的模板 两个数据的类型可以不一样 初始化一个pair pair&lt;string,string&gt; author{&quot;james&quot;,&quot;laov&quot;}; 可以使用成员变量名first和second来访问他们 可以使用字段key_type value_type 访问map和pair的关键字类型和值类型 map的value_type 比较特殊 是pair //对map使用迭代器 map&lt;const string,size_t&gt; word_count&#123;&#123;\"xiao\",\"xiao\".size()&#125;&#125;;auto map_it = word_count.begin();cout &lt;&lt; map_it-&gt;first &lt;&lt; \" \" &lt;&lt; map_it-&gt;second;map_it-&gt;first = \"lu\";//错误 关键字为const++map_it-&gt;second;//正确 改变value的值自增 遍历map while(map_it != word_count.end())&#123; cout &lt;&lt; map_it-&gt;first &lt;&lt; \" : \"&lt;&lt; map_it-&gt;second &lt;&lt;endl; ++map_it;&#125; 向map添加元素 insert具有返回值 他的类型为pair","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"Primer cpp 第五版读书笔记（四）","date":"2021-05-21T00:18:18.000Z","path":"2021/05/21/Primer-cpp-第五版读书笔记（四）/","text":"主要记录c++的常用标准库 包括IO库和顺序容器 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii 八，IO库前面学到过的表示io的关键词有 istream ostream cin cout cerr &gt;&gt; &lt;&lt; getline 以上是操作char类型数据的io 另外还有操作文件的fstream 操作字符串的sstream 如果是操作宽字符wchar_t的 在对应流前面加w 例如宽字符版本的cin cout是wcin wcout 宽字符版本的类型和对象与其对应的普通char版本类型定义在同一个头文件中 例如头文件 fstream中定义了ifstream 和 wifsteam 类似于java c++中的io流也使用继承来实现不同流之间的差异 例如ifstream和istringstream继承自istream 我们如何使用cin的 也就同样的方式使用这些对象 不能使用复制的方式来传递或拷贝io对象 例如 ostream out1,out2;out1 = out2是错误的 正确的方式是使用引用的方式来传递或返回流 而且他们不能是const的 IO的条件状态 strm::iostate // strm是一种IO类型strm::badbit // 流已崩溃 不可恢复的读写操作strm::failbit // io操作失败strm::eofbit // 流到达文件结束strm::goodbit // 流未处于错误状态s.eof() // 若流处于eofbit置位 返回trues.fail() // 若流处于failbit or badbit状态 返回trues.good() // 若流处于有效状态 返回trues.clear() // 将流所有条件状态复位 返回voids.clear(flags) // 将flags标志位复位 返回voids.setstate(flags) //设置标志位s.rdstate() //读取当前标志位 判断一个输入流是否有效的最简单操作是while(cin &gt;&gt; word){...} 或者使用!fail() good或fail 是确定流的总体状态的正确方式 输出缓冲区 每个输出流都管理一个缓冲区 用来保存程序读写的数据 由于设备的写操作可能耗时 所以允许操作系统将多个输出操作组合成单一的的设备写操作来提升性能 下面这些方式可以让缓冲区刷新 即数据真正写到输出设备或文件中 程序正常结束 缓冲区满了 使用操作符endl flush ends显式刷新缓冲区 使用操作符unitbuf设置流的内部状态来清空缓冲区 默认cerr是设置unitbuf的 即立即刷新 一个输出流被关联到另一个流 当读写被关联的流时 关联的流的缓冲区会被刷新 注意 当程序发生崩溃时 输出缓冲区不会被刷新 他所输出的数据很可能停留在输出缓冲区中等待打印 所以我们需要确认那些你认为已经输出的数据确实已经刷新了 否则会花费大量时间在追踪代码为什么没有执行上 使用tie函数关联两个流 cin.tie(&amp;cout) 文件的输入输出 下面是文件流的常用方式 fstream fstrm;//未绑定文件fstream fstrm(s);//打开名为s的文件fstream fstrm(s,mode);//指定mode模式打开文件fstrm.open(s);//打开名为s的文件fstrm.close();//关闭文件fstrm.is_open();//文件是否已经打开//文件模式in 读方式out 写方式app 每次写操作都定位到文件末尾 追加ate 打开文件后立即定位到文件末尾trunc 截断文件binary 以二进制进行IO 注意 不指定模式 默认情况下 打开一个ofstream 文件内容会被丢弃 如果增加app模式 则不会情况 写的内容变成追加 使用istringstream 比如有一个需求 从文件中录入一些人员信息 然后组建成对象输出 文件内容如 //前面是人员名称 后面是电话号码(个人，家庭等电话号码)morgan 201341345 987434463drew 97674632lee 6735548 98265524 89366263 下面开始使用istringstream来对这些文本进行处理 //首先创建一个类来封装这些人员数据struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;//接下来使用一个方法将这些文本数据转换成对象集合vector&lt;PersonInfo&gt; parseData()&#123; string line,word; Vector&lt;PersonInfo&gt; people; while(getline(cin,line))&#123; //遍历每行字符串 赋值给line PersonInfo info;//每行对应一个对象 先声明类型 istringstream record(line);//创建istringstream对象record 使用line字符串直接构造该对象 record &gt;&gt; info.name;// istringstream的操作符&gt;&gt;来自于basic_isteam的操作符&gt;&gt; 用法同熟悉的cin&gt;&gt;都是遇到空格结束 意思从record字符串输入流读取下一个空格前的字符串保存到info.name中 while(record &gt;&gt; word)&#123;//如法炮制 读取名字后面的号码 传入info对象的vector中 info.phones.push_back(word);//顺序添加到末尾 &#125; people.push_back(info);//保存对象 &#125; return people;&#125; 使用ostringstream 分别输出有效和无效的电话号码 for(const auto &amp;entry: people)&#123; ostringsteam formatted,badNums; for(const auto &amp;nums:entry.phones)&#123; if(!valid(nums))&#123; badNums &lt;&lt; \" \" &lt;&lt; nums; &#125;else&#123; formatted &lt;&lt; \" \" &lt;&lt; format(nums); &#125; &#125; if(badNums.str().empty())&#123; os &lt;&lt; entry.name &lt;&lt; \" \" &lt;&lt; formatted.str() &lt;&lt; endl; &#125;else&#123; cerr &lt;&lt; \"input err:\" &lt;&lt;entry.name &lt;&lt; \"invalid nums \" &lt;&lt; badNums.str() &lt;&lt; endl; &#125;&#125; 九，顺序容器不同容器需要考虑以下的性能折中： 向容器添加或删除元素的代价 非顺序访问容器中元素的代价 下面列举顺序容器的类型和特点 vector 可变大小数组 支持快速随机访问 在尾部之外的位置插入或删除元素可能很慢 deque 双端队列 支持快速随机访问 在头部尾部插入或删除数据很快 list 双向链表 只支持双向顺序访问 在list中任何位置进行插入删除操作速度很快 forword_list 单向链表 只支持单向顺序访问 在链表任何位置进行插入删除操作速度很快 array 固定大小的数组 支持快速随机访问 不能添加或删除元素 string 与vector相似的容器 但专门用于保存字符 随机访问快 在尾部插入删除元素速度快 新标准的容器比旧版本的快得多 现代c++程序应该使用标准库容器 而非原始的数据结构如内置数组 在选择容器方面 有一些基本原则 其中一个是：除非你有很好的理由选择其他容器 否则应该使用vector 如果程序中既需要随机访问元素 又需要在容器中间插入元素 选择容器时 就要看取决于在list或forward_list 中访问元素与vector 或deque中插入/删除元素的相对性能 看哪一种操作作主导地位 是访问元素的操作更多还是插入删除的操作更多 必要时需要对容器的选择做测试工作 容器都定义为模板类 以便提供信息给编译器是特定的容器的类型 参考之前的vector 也有list 容器中包含容器也是常见的vector","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"Primer cpp 第五版读书笔记（三）","date":"2021-05-10T09:47:55.000Z","path":"2021/05/10/Primer-cpp-第五版读书笔记（三）/","text":"主要记录c++的函数和类基础 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii 六，函数熟悉c的程序员常常会使用指针类型的形参访问函数外部的对象 在c++语言中 建议使用引用类型的形参代替指针 void reset(int *p)&#123; *p = 0;//改变了指针p所指对象的值 p = 0;//只改变了p的局部拷贝 实参未被改变&#125;int i = 42;reset(&amp;i);//传递指针地址cout &lt;&lt; i &lt;&lt; endl; //输出0 传递引用形参代替指针 void reset(int &amp;i)&#123; i = 0;&#125;//调用时int j = 42;reset(j);// 传递引用 cout &lt;&lt; j &lt;&lt; endl;//输出0 如果函数无需改变引用形参的值 最好将其声明为常量引用 bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125; 当函数形参数量未知 且类型相同时 可以使用initializer_list类型的形参 他是一种标准库类型 用于表示某种特定类型的数组 他的类型定义在同名的头文件中 initializer_list&lt;T&gt; lst; //默认初始化，T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;//列表中的元素都是constlst.size();lst.begin();//返回指向lst中的首元素的指针lst.end(); 省略型形参应该仅仅用于c和c++通用的类型，特别需要注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝 省略符形参只能出现在形参列表中的最后一个位置 函数不要返回局部对象的引用或指针 局部的引用在函数执行结束后内存将被释放掉 return将指向不再可用的内存空间 const string &amp;manip()&#123; string ret; if(!ret.empty())&#123; return ret;//错误 返回局部的对象的引用 &#125;else&#123; return \"something!\"//错误 这是一个布局临时变量 &#125;&#125; 主函数main可以没有return语句 编译器将隐式插入return 0; 因为数组不能被拷贝 所以函数不能返回数组 但是可以返回数组的指针和引用 typedef int arrT[10];//arrT是一个类型别名 他表示的类型是含有10个整数的数组using arrT = int[10];//等价于上面的类型定义arrT *func(int i);//func是一个返回指向含有10个整数的数组的指针int arr[10]//arr是一个含有10个整数的数组int *p1[10]//p1是一个含有10个指针的数组int (*p2)[10] = &amp;arr;//p2是一个指针 他指向含有10个整数的数组int (*func(int i))[10];//返回数组指针的函数声明auto func(int i) -&gt; int(*)[10];//尾置返回类型 另一种方式返回数组指针 const_cast 可以在常量引用和非常量引用之间自由转换 形参是常量引用还是非常量引用会影响函数的重载 Record lookup(Account&amp;);Record lookup(const Account&amp;);//新函数 作用于常量引用Record lookup(Account*);Record lookup(const Account*);//新函数 作用于指向常量的指针 c++允许函数内声明函数 当在内层作用域中声明了名字 他将隐藏外层作用域中声明的同名实体 string read();void print(const string &amp;);void print(double);//正确 重载print函数void fooBar(int ival)&#123; bool read = false;//新作用域 隐藏了外层的read string s = read();//错误 read名字已经被重载从bool变量了 所以无法识别是函数 void print(int);//新作用域 声明并重载了一个新的print函数 print(\"value1\");//错误 print函数已经被上面的函数重载掉 原来传递string引用的函数被隐藏掉了 print(ival);//正确 当前print(int)可见 print(3.14);//正确 但是调用的是print(int) print(double)被隐藏掉了&#125; 声明函数时 可以提供参数默认值 typedef string::size_type sz;string screen(sz ht = 24,sz wid = 80,char backgrnd = ' ') 要注意 一旦某个形参被赋予了默认值 其他形参也必须有默认值 内联函数 在函数声明前加上inline修饰符 用于优化规模较小 流程直接 频繁调用的函数 可以避免函数调用的开销 constexpr函数 值用于常量表达式的函数 特点是返回值和形参都是字面值类型 constexpr函数被隐式地指定为内联函数 constexpr int new_sz()&#123;return 42;&#125;constexpr int foo = new_sz(); c++中也包含调试用的语句 断言assert 和 NDEBUG assert是预处理宏 assert(expr)返回以一个bool值 条件为假则终止程序 $ cc -D NDEBUG main.cc // 使用NDEBUG选项编译 相当于编译时就写了#define NDEBUG void print(const int a[] size_t size)&#123; #ifndef NDEBUG //__func__是编译器定义的一个局部静态变量 用于存放函数的名字 cerr &lt;&lt; __func__ &lt;&lt; \":array size is \" &lt;&lt; size &lt;&lt; endl;&#125;//除了__func__外 c++编译器还定义了4个用于程序调试有用的名字__FILE__ //存放文件名的字符串字面值__LINE__ //存放当前行号的整型字面值__TIME__ //存放文件编译时间的字符串字面值__DATE__ //存放文件编译日期的字符串字面值 函数指针 函数指针指的是指向函数的指针 是一个指针 而非函数 bool lengthCompare(const string &amp;, const string &amp;);//声明一个指向该函数的指针bool (*pf) (const string &amp;, const string &amp;);//赋值 要有上面的声明 才能有这个赋值操作pf = lengthCompare; //或者pf = &amp;lengthCompare;//使用时 下面三者等价bool b1 = pf(\"hello\",\"world!\");bool b2 = (*pf)(\"hello\",\"world!\");bool b3 = lengthCompare(\"hello\",\"world!\"); 函数的形参可以定义成函数的指针 看起来是函数类型 实际上当作指针使用 void useBigger(const string &amp;s1,const string &amp;s2,bool pf(const string&amp; , const string&amp;));//有了上面的声明后 使用时直接传递函数名字 会自动将函数转换成指向函数的指针useBigger(s1,s2,lengthCompare);//使用上面的方式声明函数指针比较麻烦 使用typedef和decltype得到简化typedef bool(*FuncP) (const string&amp;,const string &amp;);typedef decltype(lengthCompare) *FuncP2 //使用上面声明的函数指针声明新的函数void useBigger(const string&amp; ,const string&amp;,FuncP);void useBigger(const string&amp; ,const string&amp;,FuncP2); 要想一个函数返回函数指针 可以使用using关键字 using pf = int(*)(int*,int);//声明pf是一个函数指针pf f1(int);//f1函数返回了一个函数指针pf//也可以拼接上面两个语句成一句int (*f1(int))(int*,int);//也可以使用尾置返回类型的方式声明auto f1(int) -&gt; int(*)(int*,int); 七，类定义一个返回this对象的函数 Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold;// 把rhs的成员加到this对象的成员上 revenue += rhs.revenue; return *this; //返回调用用该函数的对象 实际上需要返回Sales_data&amp;引用类型&#125; c++的构造函数大体与java一样 没有返回类型 可以重载 不能声明成const 编译器为类定义默认的构造函数 有时候编译器不能生成默认构造函数 其中一个原因是 类中包含的成员的类型 没有默认构造函数 在c++新标准中 如果我们需要默认的行为 可以通过在参数列表后面写上 = default来要求编译器生成构造函数 构造函数初始值列表 Sales_data(const std::string &amp;s): bookNo(s)&#123;&#125;Sales_data(const std::string &amp;s, unsigned n,double p): bookNo(s), units_sold(n),revenue(p*n) &#123;&#125; 上面其中bookNo(s), units_sold(n),revenue(p*n)就是代表构造函数初始值列表 对类成员函数进行初始化 如果没有对units_sold 和revenue进行显式初始化 他将以合成默认构造函数相同的方式隐式初始化 例如这样 Sales_data(const std::string &amp;s):bookNo(s),units_sold(0),revenue(0)&#123;&#125; 构造函数不应该轻易覆盖掉类内的初始值 除非新赋的值与原值不同 如果你不能使用类内初始值 则所有构造函数都应该显式地初始化每个内置类型的成员 与其他函数一样 构造函数也允许在类外定义 定义时需要加上命名空间Sale_data:: 使用class或者struct都可以用来定义类 他们的区别在 默认的访问权限 定义在第一个访问说明符之前的成员是public的 使用struct 定义在第一个访问说明符之前的成员是private的 使用class 与java不同的是 c++中 类可以允许其他类或者函数访问他的非公有成员 方法是令其他类或者函数成为他的友元friend 使用friend关键字 如上面描述的在第一个访问说明符之前的成员默认是private class Sales_data&#123; friend Sales_data add(const Sales_data &amp;,const Sales_data &amp;); friend std::istream &amp;read(std::istream&amp;,Sales_data&amp;); friend std::ostream &amp;print(std::osteam&amp;,const Sales_data&amp;); public: Sales_data() = default; Sales_data(const std:string &amp;s,unsigned n,double p): bookNo(s),units_sold(n),revenue(p*n) &#123;&#125; Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(std::istream&amp;); std::string isbn() const &#123;return bookNo;&#125; Sales_data &amp;combine(const Sales_data&amp;); private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;//类外的Sales_data接口的非成员组成部分的声明Sales_data add(const Sales_data &amp;,const Sales_data &amp;);std::istream &amp;read(std::istream&amp;,Sales_data&amp;);std::ostream &amp;print(std::osteam&amp;,const Sales_data&amp;); 一般来说 最好在类定义开始或者结束前的位置集中声明友元 const成员函数 表明这个函数不会对这个类对象的数据成员作任何改变 在设计类的时候 一个原则就是 对于不改变数据成员的成员函数都要在后面加 const 而对于改变数据成员的成员函数不能加 const 所以 const 关键字对成员函数的行为作了更加明确的限定： 1）有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内） 只能读取数据成员 不能改变数据成员 没有 const 修饰的成员函数 对数据成员则是可读可写的 2）除此之外 在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数 而不能调用非const修饰的函数 非常量对象既可以调用const成员函数也可以调用非const成员函数 值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象 class Name &#123; public: void setName(const string &amp;s) const; private: char *m_sName;&#125;;void setName(const string &amp;s) const &#123; m_sName = s.c_str(); // 错误！不能修改m_sName; for (int i = 0; i &lt; s.size(); ++i) m_sName[i] = s[i]; // 不好的风格，但不是错误的&#125; const成员函数可以被对应的具有相同形参列表的非const成员函数重载 class Screen &#123; public: char get(int x,int y); char get(int x,int y) const;//常量特性不一样 允许重载&#125;;int main()&#123; const Screen cs;Screen cc2; char ch = cs.get(0, 0); // 调用const成员函数 ch = cs2.get(0, 0); // 调用非const成员函数 &#125; 可变数据成员mutable 上面的const成员函数阻止我们修改成员变量 但是使用mutable修饰符可以突破 class Screen&#123; public: void some_member() const; private: mutable size_t access_ctr;//即使在一个const对象内也能被修改&#125;void Screen::some_member() const&#123; ++access_ctr;//使用mutable修饰符突破了限值 他就是可变数据成员&#125; 一个const成员函数如果以引用的形式返回*this 那么他的返回类型将是常量引用 委托构造函数 有点类似于java的调用重载构造函数来初始化 class Slaes_data&#123; public: Sales_data(std::string s,unsigned cnt,double price): bookNo(s),units_sold(cnt),revenue(cnt*price)&#123;&#125; Sales_data():Sales_data(\"\",0,0)&#123;&#125; Sales_data(std::string s):Sales_data(s,0,0)&#123;&#125; Sales_data(std::istream &amp;is):Sales_data()&#123;read(is,*this)&#125;&#125;; 只有第一个是使用实参来构造 其他都是委托构造函数 调用其他重载的构造函数 隐式的类类型转换 如果构造函数只接受一个实参 则他实际上定义了转换为此类类型的隐式转换机制 例如上面的代码将接收string和istream转换成Sales_data类型 那么在使用到Sales_data的地方 可以直接使用string和istream代替Sales_data string null_book=\"9-99999-99-9\";item.combine(null_book);//combine函数本身是期待接受一个Sales_data的实参 但是由于存在只传递一个string的构造函数 所以隐式地调用了该构造函数来调用该方法item.combine(\"9-99999-99-9\");//但是这种方式错误 隐式转换只能是同时间使用一种转换规则 这里是连续使用了两种 1是把\"9-99999-99-9\"转换成string 2是string转换成Sales_dataitem.combine(string(\"9-99999-99-9\"));//正确item.combine(Sales_data(\"9-99999-99-9\"));//正确 使用explicit关键字可以阻止或抑制上述的隐式转换类型 这样的构造函数叫显式构造函数 //构造函数explicit Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;explicit Sales_data(std::istream&amp;);item.combine(null_book);//错误 传递string的构造函数是explicit的item.combine(cin);//错误 传递istream的构造函数是explicit的item.combine(Sales_data(null_book));//正确 这是显式调用构造item.combine(static_cast&lt;Sales_data&gt;(cin));//正确 static_cast可以使用explicit的构造函数 聚合类 这种类格式比较简单 用户可以直接访问他的成员 struct Data&#123; int ival; string s;&#125; 他所有成员都是public的 他没有定义任何构造函数 没有类内初始值 没有基类 调用时可以直接这样Data val1 = {0,&quot;sss&quot;} 顺序必须要与声明的顺序一致 类的静态成员 static 与java类似 静态成员属于类 而不属于类对象 可以是public的也可以是private的 静态方法只能包含静态成员变量 不包含this指针 静态成员函数不能声明为const的 class Account&#123; public: void calculate()&#123;amount+= amount * interestRate;&#125; static double rate()&#123;return interestRate;&#125; static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate();&#125; 使用作用域运算符可以直接访问静态成员double r = Account::rate(); 当然也可以直接使用对象来调用静态函数Account ac1; r = ac1.rate();","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"Primer cpp 第五版读书笔记（二）","date":"2021-05-08T02:21:21.000Z","path":"2021/05/08/Primer-cpp-第五版读书笔记（二）/","text":"主要记录c++的字符串向量和数组 表达式和语句 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii ## 三，字符串、 向量和数组前面讲到使用库函数时 c++需要标明命名空间 利用using关键字 可以一次声明后 后面的使用中不再标明命名空间 类似于java的import 格式为using namespace::name; 例如声明之前我们经常用到的输入输出cin #include &lt;iostream&gt;using std::cin;int main()&#123; int i; cin &gt;&gt; i;//正确 cout &lt;&lt; i;//错误 未声明cout 还不能这么用 std::cout &lt;&lt; i;//正确 return 0;&#125; using关键字不仅可以命名类型别名 也充当声明命名空间变量作用 注意 头文件中不应该包含using 关键字 因为头文件被多个文件引用 使用using可能会导致始料未及的名字冲突 定义和初始化string对象 初始化string对象的方式 string s1;string s2(s1);string s2 = s1; //使用= 拷贝初始化string s3(\"value\");//使用() 直接初始化string s4 = \"value\";string s5(3,'c') //s5的值为字符串ccc string的常用操作 os &lt;&lt; s //把s写到输出流os中 返回osis &gt;&gt; s //从is中读取字符串赋给s 字符串以空白分隔 返回isgetline(is , s) //从is中读取一行赋值给s 返回iss.empty() //判断s是否为空s.size() //返回s中字符个数s[n] //返回s中第n个字符的引用 n从0开始s1+s2 //拼接字符串s1=s2 //替换字符串s1==s2 //判断字符串的字符是否完全一样 则相等s1!=s2 //判断不等 对字母大小写敏感&lt; ,&gt; , &lt;=, &gt;= //比较字符串 利用字符在字典中顺序 对大小写敏感 string的size函数返回size_type类型 这个类型在string中定义了 很明显他是一个无符号的类型 使用string::size_type来 标记这个类型 主要不要使用size函数的返回值直接与int类型的值进行运算 因为前者属于无符号类型 直接与带符号类型的值运算 会让带符号类型的负值转换成一个比较大的无符号值参与运算 最终得到意料之外的结果 使用+进行拼接字符串时 注意string s =&quot;hello &quot;+&quot;world!&quot;的方式是错误的 不能直接将两个字符串字面值相加 为了兼容c 字符串字面值和string对象是不同的类型 +运算符允许字符串字面值和string对象相加 string s = &quot;hello &quot;+s1 这样是合法的 cctype头文件中声明了以下函数可以单独处理string对象中的字符 isalnum(c)isalpha(c)iscntrl(c) //是否是控制字符isdigit(c) //是否是数字isgraph(c) //是否不是空格并可打印islower(c) isprint(c)ispunct(c) //是否标点isspace(c)isupper(c)isxdigit(c) //是否十六进制数字tolower(c) //输出小写toupper(c) //输出大写 使用for循环处理字符串的值 例如小写转大写 并输出到cout string s1 = \"Hello world!\"; for(auto &amp;c : s1)&#123; c = toupper(c); &#125; cout &lt;&lt; s1 &lt;&lt; endl; 容器vector是模板而非类型 在使用vector之前 先要引入vector标准库 include &lt;vector&gt;using std::vector; 初始化vector集合 vector&lt;int&gt; ivec;vector&lt;int&gt; ivec2(ivec) ;vector&lt;string&gt; articles&#123;\"a\",\"b\",\"c\"&#125;;vector&lt;string&gt; article = &#123;\"a\",\"b\",\"c\"&#125;;vector&lt;string&gt; svec(10,\"c\");//vector&lt;int&gt; ivec(10,-1); //10个int类型的元素 每个都被初始化-1vector&lt;int&gt; ivec2(10); //初始化10个元素的vector 元素的初始值默认都为0vector&lt;int&gt; ivec3&#123;10&#125;;//初始化有一个元素10的vector vector使用push_back函数添加元素 注意不能使用for循环改变容器本身的大小 包括增加或删除元素 应该使用迭代器 下面罗列下vector的主要函数和运算符 与string相类似 vector&lt;int&gt; v&#123;1,2,3&#125;;v.empty();v.size();v.push_back(t);v[n]v1 == v2v1 = &#123;a,b,c&#125;v1 = v2v1 != v2&lt;, &lt;=, &gt;,&gt;= vector的 下标从0开始 也是相应的size_type类型 vector是有序的 通过下标可以直接访问里面的元素 注意 下标运算符只能用作访问已经存在的元素 不能用于添加元素 迭代器 string和vector都可以使用迭代器 下面是迭代器常用的操作 *iter //返回迭代器iter所指元素的引用iter-&gt;mem //解引用iter并获取该元素的名为mem的成员等价于(*iter).mem++iter //令iter指向容器中的下一个元素--iter //令iter指向容器中的上一个元素iter1 == iter2 //判断两个迭代器是否相等 下面的代码修改字符串的首个字母为大写字母 string s(\"some string\");if(s.begin()!=s.end())&#123; //确保s非空 auto it = s.begin(); *it = toupper(*it); //通过迭代器修改首个字母为大写&#125; 对于函数cbegin和cend 与函数begin和end功能类似 不同的是cbegin的返回值是const_iterator 常量迭代器 迭代器结合解引用和成员访问操作 vector&lt;string&gt; v&#123;\"hello\",\"world\"&#125;;auto it = v.begin();//it作为指向第一个元素的迭代器(*it).isempty(); //检查迭代器所指字符串是否为空字符串 括号必不可少 为了简化以上写法 定义了箭头运算符-&gt;来把解引用和访问结合在一起 也就是说使用it-&gt;item 和(*it).item表达的意思一样 除了使用++iter –iter方式来进行迭代器运算外 还可以使用iter +n 使迭代器往前挪n步 两个迭代器相减可以得到他们的距离 数组 数组与vector相类似都是集合 但是数组的大小确定不变 不能随意增加元素 相对于vector 数组的运行性能更好 同时损失了一些灵活性 定义数组必须制定数组的类型 不允许使用auto关键字来推断类型 不存在引用的数组 因为数组的元素都是对象 引用不是对象 int a[] = &#123;1,2,3&#125;;//正确 虽然未指定数组的维度 但是可以推断出是3int a2[5] = &#123;1,2,3&#125;;//正确 等价于a2[5] = &#123;1，2，3，0，0&#125;；int a3[2] = &#123;1,2,3&#125;;//错误 超出范围int a4[] = a;//错误 不允许对数组进行拷贝或使用另一个数组初始化int *ptrs[10];//ptrs是含有10个整形指针的数组int &amp;refs[10]=a;//错误 不存在引用元素的数组int (*pa)[10] = &amp;a;//正确 pa是一个指针 他指向了一个含有10个整数的数组int (&amp;ra)[10] = a;//正确 ra是一个引用 他引用了一个含有10个整数的数组 解读以上复杂类型修饰符时 遵循从内到外 从右到左的顺序方式 指针和数组 数组的名字在表达式中会直接转化成第一个元素 string nums[] = &#123;\"hello\",\"world\",\"!\"&#125;;string *p = &amp;nums[0];string *p2 = nums; //等价于p2 = &amp;nums[0] 数组也是迭代器 接上面的代码 p2++ 表示p2指向下一个元素nums[1] begin和end函数同样适用于数组 由于数组不是类类型 所以这两个函数不属于成员函数 他们属于标准库函数 定义在iterator头文件中 int a[] = &#123;1,2,3&#125;;int *beg = begin(a);//beg是指向a的第一个元素的指针int *last = end(a);//last是指向a的尾部元素的下一个位置的指针auto n = end(a) - beg(a);// n是一种ptrdff_t的标准库类型 可能为负值int last2 = *(a+1);//正确 得到的结果是a[1] = 2int last3 = *a+1;//正确 得到的结果是a[0]+4 = 1+4 = 5 数组的下标运算符所用的索引值不是无符号类型 这点与vector和string不一样 即允许负数 int a[] = &#123;1,2,3&#125;;int *p = &amp;a[2]; //p指针指向a的第三个元素int k = p[-2];//p指针往后退两步 k表示a[0]的元素 允许使用数组初始化vector集合 但是不允许使用vector初始化数组 int a = [1,2,3];vector&lt;int&gt; v(begin(a),end(a));//使用数组的首尾指针来初始化vector集合 建议：现代的c++程序应当尽量使用vector和迭代器 避免使用内置数组和指针 尽量使用string 避免使用c风格的基于数组的字符串 多维数组 严格来说 c++没有多维数组 通常所说的多维数组其实是数组的数组 当一个数组的元素仍然是数组时通常使用两个维度来定义它：一个维度表示数组本身的大小 另外一个维度代表元素的大小 int a[3][4] //大小为3的数组 每个元素含有4个整数int a[10][20][30] //大小为10的数组 每个元素有20个数组 这些数组里又有30个元素 初始化多维数组 int a[3][4] =&#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125;&#125;;//逐个初始化每行每列的元素int a[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;//初始化每行的首元素 未列出的元素执行默认值初始化int a[3][4] = &#123;0,3,6,9&#125;;//仅初始化了第一行的元素 其他元素初始化为0 使用for循环遍历多维数组元素 //使用行数和列数初始化二维数组constexpr size_t rowCnt = 3 , colCnt = 4;int a[rowCnt][colCnt];for(size_t i=0;i &lt; rowCnt;i++)&#123; for(size_t j=0;j&lt;colCnt;j++)&#123; a[i][j] = i * colCnt + j; &#125;&#125;//使用范围for语句遍历for(auto &amp;row : a) for(auto col : row)&#123; cout &lt;&lt; col &lt;&lt; endl;&#125;//注意 row前面是转化成引用 如果直接使用row 将会在下个for循环中转换成数组首元素 四，表达式成员访问运算符 点运算符和箭头运算符都可以用来访问成员 点运算符获取类对象的一个成员 箭头运算符与点运算符有关 表达式ptr-&gt;mem 等价于 (*ptr).mem 解引用运算符优先级低于点运算符 所以指针前的括号必不可缺 sizeof sizeof运算符返回一个表达式或一个类型名字所占的字节数 可以使用下面两种方式 sizeof(type) sizeof expr sizeof并不会实际计算对象的值 sizeof *p 是正确的 就算p没有被赋值 也能知道p指针的大小 隐式类型转换 都是小类型往大类型转化 如double + int 那么结果会先将int转为double再运算 强制类型转换 static_cast double slope = static_cast&lt;double&gt;(j);//一般大数向小数转换 不计较精度损失void *p = &amp;d;double *dp = static_cast&lt;double*&gt;(p); //将void*转换会初始的指针类型 常量类型转换为非常量类型 const_cast 常常用于函数重载的上下文中 const char *pr;char *p = const_cast&lt;char*&gt;(pr);//去掉底层const 两个冒号的::的运算符优先级最高 属于左结合律 ::name // 全局作用域class::name //类作用域namespace::name// 命名空间作用域 五，语句c++中的while for do while语句 if switch条件分支结构 continue语句 break语句 goto语句 try catch异常捕捉 throw语句 return语句 与java一样 可以无缝转换理解 略","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"Primer cpp 第五版读书笔记（一）","date":"2021-05-06T01:20:22.000Z","path":"2021/05/06/Primer-cpp-第五版读书笔记（一）/","text":"主要记录c++的由来和基本类型的使用 Primer c++ 第五版 原著：Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 翻译：王刚 杨巨峰 – –读书笔记 by asii 一，引子十几年来编程语言的竞争 除却实现质量之外 基本上是比拼抽象的设计 c语言之所以四十年长盛不衰 根本在于他对于现代计算机提供了一个底层的高级抽象：凡是比他低的抽象都过于简陋 凡是比他高的抽象都可以用c语言构造出来 c++语言成功的根本原因在c的基础上提供一些高级的抽象机制 如果要走下去与硬件对话 c++成为除c之外唯一有效率的选择 c++可支持多种编程风格：c风格 基于对象 面向对象和泛型 微软的基于组件 c++11对于c++98来说 是一次本质的跃升 每个具体的领域 只需要读4 5本书就够入门了 要掌握c++11 可以读以下4本书 《c++标准程序库》《Effective C++》《Linux多线程服务端编程》 本作 二，开始unix环境下使用GNU编译器简单编译个c++文件 $ g++ -o prog1 prog1.cc c++使用标准库iosteam来处理输入输出 共4个io对象 cin cout cerr clog 下面程序简单描述输入两个数并输出他们的和 #include &lt;iosteam&gt;int main()&#123; std::cout &lt;&lt; \"Enter two numbers:\" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; \"The sum of\" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \" is \" &lt;&lt; v1 + v2 &lt;&lt; std::endl; return 0;&#125; std是指命名空间 cin cout endl这些是对象名称 必须命名在命名空间内 命名空间是为了避免名字定义冲突而来 :: 是作用域运算符 切勿混用带符号类型和无符号类型 当带符号类型取值为负时会出现异常结果 因为带符号类型会自动转换成无符号类型参与运算 例如一个a*b的表达式 当a = -1 ，b = 1时，当两者都为带符号int时 可以达到-1 但是当b为 unsigned int时 得到的结果不会是-1 结果视当前机器上int所占位数而定 列表初始化 c++11标准下 可使用下面的方式来初始化一个int值 int sold = 0;int sold = &#123;0&#125;;int sold&#123;0&#125;;int sold(0); 与java一样 c++允许非显示地初始化一个变量 例如int sold; 或 sample item; 但与java不同的是：编译器不会指定其默认值 即值为未定义 是一个不确定的值 其值由类确定 这种方式在编写代码时不会报错 但是如果没有赋值而直接使用将会引发不确定的效果 这一点让我们想起c中在使用一个变量时需要先对其进行声明 而声明时是不需要赋值的 未申请内存空间的 c++中声明一个变量使用extern关键字 extern int i; // 声明i 而非定义iint i;// 声明并且定义i 变量能且能被定义一次 但是可以被多次声明 变量的定义必须出现在且只能出现在同一个文件中 而其他用到该变量的文件必须对其进行声明 却绝对不能重复定义 如果函数有可能用到某个全局变量 则不宜再定义一个同名的局部变量 当在函数内部想强制引用外部定义的全部变量时 可以使用::变量名来表示 c++中引用 左值引用 int i = 1;int &amp;refi = i;//正确 refi引用指向i 即是变量i的另一个名字int &amp;refi;//报错 引用必须被初始化 定义引用时 程序把引用和他的初始化值绑定在一起 而不是将初始化值拷贝给引用 引用即别名 并非对象 他只是一个已经存在的对象所起的另外一个名字 refi = 2；//正确 把2赋值给refi指向的对象 此处即把值赋给了iint j = refi;//正确 与执行j = i执行结果一样 为引用赋值 实际是将值赋给了与引用绑定的对象上 获取引用的值 实际是获取了与引用绑定的对象的值 int &amp;refj = refi;//正确 refj绑定到了与refi绑定的对象上，实际是绑定到i上int i = refi;//正确 i被重新初始化成refi的值 将引用作为初始值 实际是以引用绑定的对象作为初始值 因为引用本身不是一个对象 所以不能定义引用的引用 引用标记符定义时必须以&amp;开头 引用不能与字面值绑定在一起 int &amp;refi = 10; //错误 引用类型的初始值必须是一个对象double d = 1.2;//正确int &amp;refj = d; //错误 引用类型的初始值必须与对象类型一致 c++中指针 复合类型 指针实现了对其他对象的间接访问 指针和引用有很多不同点 指针本身就是一个对象 允许对指针赋值和拷贝 而且可以在指针的生命周期内先后指向几个不同的对象 指针无需再定义时赋初始值 这时候他的值并不确定 使用 *d来表示一个指针 d为变量名 指针存放某个对象的地址 要想获取地址 需要使用取值运算符&amp; int i = 9;int *p = &amp;i;//声明并初始化了指针p 存放了i的地址 p就是指向i的指针int *q = p;//正确 double *m = p; //错误 类型不匹配m = &amp;i；//错误 类型不匹配 指针值有以下4种状态： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 意味着指针没有指向任何对象 无效指针 也就是上述情况外的其他值 试图拷贝或以其他方式访问无效指针的值将会引发错误 这点与试图使用未初始化的变量是一样的 int i = 1;int *p = &amp;i;std::cout &lt;&lt; *p; //其中*是解引用符 输出1*p = 0;//正确 改变指针指向的变量的值 将i的值改为0std::cout &lt;&lt; *p; //输出0 注意 解引用符号仅适用于那些确定了指向某个对象的有效指针 像&amp;和*这样的符号 既能作为表达式里的运算符也能作为声明的一部分组成 int i = 1;int &amp;r = i; //&amp;紧接着类型名出现是声明的一部分 r是一个引用int *p;// 其中*紧接着类型名出现是声明的一部分 p是一个指针p = &amp;i;//这里&amp;是一个取值运算符*p = i;//非声明 这是一个表达式 所以*表示解引用符int &amp;r2 = *p; //&amp;是声明的一部分 r2是引用 *是表达式里的一部分表示解引用符 空指针nullptr 空指针不指向任何对象 在试图使用一个指针之前代码应该先检查他是否为空 以下几种方式可以生成空指针 int *p = nullptr; //等价于int *p = 0；int *p2 = 0; //直接将p2初始化为字面值 常量0int *p3 = NULL;//需要首先#include cstdlib 是一个预编译变量等价于int *p3=0 在c++11新标准下 最好使用nullptr 避免使用NULL 把变量直接赋值给指针是错误的操作 即使变量的值恰好是0也不行 int i = 0;int *p;p = i; //错误 不能把变量直接赋值给指针 但可以使用 *p = i; 赋值和指针 引用和指针最大的不同点是 引用不是对象 一旦定义了引用 他就无法再绑定到另外的对象上 之后每次访问都是最初绑定的那个对象 但是指针没有这个限制 他可以随时改变指向的对象 int i = 1;int *p = 0; //p被初始化 没有指向空指针 没有指向任何对象int *p2 = &amp;i;// 指向i 保存了i的地址int *p3; //指针指向未定义 p3值无法确定p3 = p2;// p3指向的对象和p2指向的对象是同一个 指针之间可以直接相互赋值p2 = 0; // p2不再指向任何对象 成为空指针 有时候 无法搞清楚一条赋值语句到底是改变了指针的值还是改变了指针指向对象的值 最好的办法是记住：赋值永远改变的是符号左侧的对象 p = &amp;i; //改变的是p的值 p指向了i变量所在的地址 指针地址改变*p = 0;//改变的是p指向的值 指针p的指向并没有改变 即指针地址未改变 void*指针 void*指针是一种特殊的指针变量 可用于存放任意对象的地址 double obj = 3.14, *p = &amp;obj;void *pv = &amp;obj;//obj可以是任意类型的对象pv = p; //pv可以存放任意类型的指针 关于指针 int* p 和 int *p 两种写法都可以 一般习惯于后者的写法 指向指针的指针 int i = 1024;int *p = &amp;i;int **ppi = &amp;p; //ppi就是指向int型指针的指针 引用并非对象 所以不能使用指针指向引用 但是指针是对象 所以存在指向指针的引用 面对一条复杂的指针或引用的声明语句时 从右往左阅读有助于弄清楚他的真实含义 指向指针的引用 int i = 1;int *p;int *&amp;r = p; //r是一个队指针p的引用r = &amp;i; //r引用了一个指针 给r赋值&amp;i就是令p指向i*r = 0; //解引用r得到i 也就是p指向的对象 将i的值改为0 在方法传递参数时 可以传递值 引用和指针 要注意c++是值传递的 传递的值被拷贝成局部变量在方法内参与运算 退出方法后实际上不会改变具体的值 而传递指针和引用时 实际上传递的是地址 在方法内参与运算时会改变指向地址的实际的值 地址是不会变的但是他指向的值可以改变 按实际需求使用三种方式传递 int a =10,b =20;//按值传递void swap(int a,int b)&#123; int t; t = a; a = b; b = t;&#125;swap(a,b);cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl;//输出10 20//按指针传递void swap(int *a,int *b)&#123; int t; t = *a; *a = *b; *b = t;&#125;swap(&amp;a,&amp;b);cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl;//输出20 10 交换成功//按引用传递void swap(int &amp;a,int &amp;b)&#123; int t; t = a; a = b; b = t;&#125;swap(a,b);cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl;//输出20 10 交换成功 使用哪种方式传递 需要按照实际需求 只需要记住一些规则： 引用需要初始化 指针和值可以没有初始化 引用经过初始化后不能成为另一个对象的引用 指针可以随意改变指向 引用不存在空引用 指针可以为空指针 应用时需要检查 引用更安全 const限定符 使用const声明的变量 值不能被改变 所以声明时需要同时定义值 类似于java的final 在对const声明的变量进行定义时 允许使用变量而非常量表达式来定义 int i = 1;const int ci = i;int j = ci; 第一次接触const时肯定还有一个疑问 既然可以把一个非常量变量赋值给const变量 那么当非常量变量的值改变时 const变量的值是否改变 下面的试验给出答案 int i = 1; const int r = i; std::cout &lt;&lt; r &lt;&lt; std::endl; i = 2; std::cout &lt;&lt; r &lt;&lt; std::endl; std::cout &lt;&lt; i &lt;&lt; std::endl; 结果输出 1 1 2 证明const变量还是未改变值之前的常量值1 我们像将const的变量只在一个文件中定义 而在多个文件中声明并使用他 使用extern关键字 extern const int bufsize;//在file1.h头文件中声明extern const int bufsize = fcn();// 运行时初始化 在file1.cc中定义并初始化了一个常量 给常量能被其他文件访问 与头文件中声明的是同一个 常量的引用不能被用作修改他绑定的对象上 const int ci = 1;const int &amp;r1 = ci;//正确 引用和对应的对象都是常量r1 = 2; //错误int &amp;r2 = ci; //错误试图让一个非常量引用指向一个常量对象 不能把一个const常量赋值给一个非const的引用 相反 允许把一个非常量对象赋值给常量引用 指针和const 指向常量的指针不能用于改变其指向对象的值 const double pi = 3.14;double *ptr = &amp;pi;//错误 ptr是一个普通指针 不能指向常量值const double *cptr = &amp;pi;//正确 cptr是一个指向常量的指针 记住他不是常量指针*cptr = 1.0;//错误 不能给*cptr赋新的值 与引用一样 不能把一个const常量赋值给一个非const的指针 相反 允许把一个非常量对象赋值给常量指针 const指针 常量指针使用 *const表示 说明指针是一个常量 不变的是指针本身的值而非指向的那个值 int errNum = 0;int *const curErr = &amp;errNum;//curErr将一直指向errNum curErr是常量指针const double pi = 3.14;const double *const pip = &amp;pi;//pip是一个指向常量对象的常量指针 解疑1 const double pi = 3.14; double i = 1.1; const double *cptr = &amp;pi;// *cptr = 6.6;//错误 不能改变cptr指向的变量pi的值 因为pi本身是常量 cptr = &amp;i;//正确 可以改变cptr指向新的地址 std::cout &lt;&lt; *cptr &lt;&lt; std::endl; //输出1.1 cptr是一个指向常量的指针 记住他不是常量指针 常量指针使用 *const标记 cptr允许改变指向新的地址 但是不能改变cptr指向的变量的值 解疑2 上文有一个表达是中包含两个const 如 const double *const pip = &amp;pi; 这两个const是有区别的 靠右的叫顶层const 靠左的叫底层const 在执行对象拷贝时两者存在区别 int i = 0;int *const p1 = &amp;i; //不能改变p1的值 顶层constconst int ci = 42; //不能改变ci的值 顶层constconst int *p2 = &amp;ci; //运行改变p2的值(即改变p2的指向) 底层constconst int *const p3 = p2;//靠右的叫顶层const 靠左的叫底层constconst int &amp;r = ci;//用于声明引用的const都是底层consti = ci;//正确 ci是顶层const 对此操作无影响p2 = p3;// 正确 p2 p3指向的对象类型相同 都是底层constint *p = p3;//错误 p3包含底层const的定义 而p没有p2 = &amp;i; //正确 int* 能转换成const int*int &amp;r = ci;//错误 普通的引用r不能绑定到int常量上const int &amp;r2 = i;//正确 const的引用可以绑定到普通int上 常量表达式 constexpr 是指值不会改变并且在编译过程中就能得到计算结果的表达式 const int i = 20;//是const int j = i + 1 ;//是int m = 1;//不是const int n = get_size(); //不是 c++11规定 允许将变量声明为constexpr类型以便编译器来验证变量值是否是一个常量表达式 constexpr int mf = 20;constexpr int limit = mf +1;constexpr int sz = size()；//只有当size函数是一个constexpr函数时才是一个正确的声明 通常这种函数比较简单 在编译时就能产生结果 一般来说 如果认定一个变量是常量表达式 就把他声明为constexpr类型 类型别名 使用两种方式来定义类型别名 一个是关键字typedef 一个是关键字using typedef double wages; //wages是doubel的同义词using SI = Sales_item; // SI是Sales_item的同义词 定义一个指针别名 typedef char *pstring;const pstring cstr = 0;//cstr是指向char的常量指针const pstring *ps;//ps是一个指针 他的对象是指向char的常量指针 注意不要理解成下面的方式 直接把pstring 替换成char * const char *cstr = 0;//是对const pstring cstr = 0 的错误理解 这两者声明的含义完全不同 const pstring cstr = 0是一个指向char的常量指针 而改写后的const char *cstr = 0;则是一个指向const char的指针 该指针允许改变它的指向 常量指针不可以改变指向 auto类型说明符 auto类型说明符是让编译器替我们分析表达式所属的类型 例如auto item=v1+v2 如果v1 v2是double类型 那么可以自动推断出item类型为double 如果v1 v2是sale_item对象类型那么推断出item类型为sale_item类型 一条语句中可以声明多个变量 但需要注意所有变量的初始基本类型都必须一样 auto i = 0, *p = &amp;i;//正确 i为整形 p为整形指针auto sz = 0, pi = 3.14;//错误 sz为整形 pi为浮点型 类型不一致 decltype类型指示符 decltype用作选择并返回操作数的数据类型 期间不会使用表达式的值初始化变量 decltyp(f()) sum = x; 表示sum类型就是函数f的返回类型 编译器并不实际调用函数f 而是当调用发生时f的返回类型就是sum的返回类型 当使用decltype和引用时 const int ci = 0, &amp;cj = ci;decltype(ci) x = 0;//x的类型是intdecltype(cj) y = x;//y的类型是const int&amp; ,y绑定到变量xdecltype(cj) z;//错误 z是引用 必须初始化int i = 42, *p = &amp;i, &amp;r = i;decltype(r+0) b;// 正确加分的结果是int 因此b是一个未初始化的intdecltype(*p) c;//错误 c是int&amp; 必须初始化 注意 使用decltype时 变量名上可以加括号如decltype((i)) 此时他的类型与不加括号前的类型会有不同 int i =9;decltype((i)) d; //错误 d是int&amp; 必须初始化decltype(i) e;//正确 e是一个未初始化的int 切记 decltype((变量名)) 的结果永远是引用 而decltype(var) 的结果只有当var本身是引用类型时才是引用","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"http://luyaoming.com/tags/c/"}]},{"title":"使用selenium自动填充网页表单.md","date":"2021-04-24T05:35:54.000Z","path":"2021/04/24/使用selenium自动填充网页表单/","text":"主要介绍使用selenium这个工具库基于python和java来实现自动填写表单的功能 下面是引用百度百科对selenium的介绍： Selenium [1] 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera，Edge等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。 下面主要介绍使用java和python两种方式来调用脚本测试网页 方法一：python+selenium+chrome 先pip安装selenium pip3 install selenium 下载需要基于浏览器测试的工具 如这里使用chrome浏览器测试 所以下载chromedriver 要注意需要下载与chrome版本对应的driver版本 我的chrome浏览器版本是89 对应下载driver的地址是https://chromedriver.storage.googleapis.com/index.html?path=89.0.4389.23/ 下载完成后把chromedriver文件改成可执行文件 并在放到PATH目录下 chmod a+x chromedriver cp ~/Downloads/chromedriver /usr/local/bin/ 使用以下python代码进行测试 # encoding=utf8from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesimport time# 前台开启浏览器模式def openChrome(): # 加启动配置 option = webdriver.ChromeOptions() option.add_argument('disable-infobars') # 打开chrome浏览器 driver = webdriver.Chrome(options=option) return driver # 无需启动浏览器模式 # def openChromBack(): # return webdriver.Remote(command_executor=\"[http://localhost:4567/wd/hub](http://localhost:4567/wd/hub \" # selenium # 本地测试地址 # \")\", desired_capabilities = DesiredCapabilities.HTMLUNIT)def openChromeBack(): return webdriver.Remote(command_executor= \"[http://localhost:4567/wd/hub](http://localhost:4567/wd/hub \"\")\", desired_capabilities=DesiredCapabilities.HTMLUNIT)# 授权操作def operationAuth(driver): url = \"http://www.baidu.com\" driver.get(url) # 找到输入框并输入查询内容 elem = driver.find_element_by_id(\"kw\") elem.send_keys(\"selenium\") # 提交表单 driver.find_element_by_xpath(\"//*[@id='su']\").click() print('查询操作完毕！')# 方法主入口if __name__ == '__main__': # 加启动配置 driver = openChrome() operationAuth(driver) 方法二：java+selenium+chrome 在安装了jdk1.8的环境下 不需要再配置环境变量 直接创建maven项目 引入selenium库 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写java测试代码 import org.openqa.selenium.WebElement;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.chrome.ChromeOptions;import java.util.concurrent.TimeUnit;public class TestHelloWorld &#123; public static void main(String[] args)&#123; System.setProperty(\"webdriver.chrome.driver\",\"/usr/local/bin/chromedriver\"); ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.addArguments(\"--headless\"); ChromeDriver chromeDriver = new ChromeDriver(); //后台静默模式启动浏览器// ChromeDriver chromeDriver = new ChromeDriver(chromeOptions); chromeDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); String url = \"http://www.baidu.com\"; chromeDriver.get(url); WebElement element = chromeDriver.findElementById(\"kw\"); element.sendKeys(\"炉石传说最强卡组\"); chromeDriver.findElementByXPath(\"//*[@id='su']\").click(); System.out.println(\"搜索完毕！\"); &#125;&#125; 注意这里加了个选项 可以在后台静默地启动浏览器 不会打开浏览器新窗口 非常方便 有关其他更多设置项 可以直接查看官网 http://www.selenium.org.cn/1598.html","categories":[],"tags":[{"name":"网页","slug":"网页","permalink":"http://luyaoming.com/tags/网页/"},{"name":"selenium","slug":"selenium","permalink":"http://luyaoming.com/tags/selenium/"}]},{"title":"c语言程序设计现代方法-读书笔记（三）","date":"2021-04-14T07:49:09.000Z","path":"2021/04/14/c语言程序设计现代方法-读书笔记（三）/","text":"主要介绍c语言的输入输出，错误处理和其他标准库函数 c语言程序设计现代方法 原著：K.N.King 翻译：吕秀峰 – –读书笔记 by asii c语言程序设计现代方法-读书笔记（三）.md # ###输入/输出标准库 c语言中流的访问是通过文件指针来实现的 可以在程序中有下列形式的声明 FILE *fp1, *fp2; 提供了三种标准流，是备用的。我们无法打开或关闭，分别是： stdin 标准输入 键盘 stdout 标准输出 屏幕 stderr 标准错误 屏幕 类似于UNIX和DOS操作系统的命令行操作 c语法可以提供将输入输出重定向 例如 demo &gt; out.dat 将原来输出到stdout屏幕的demo数据 写入到out.dat文件中 demo &lt; in.dat &gt; out.dat 输出重定向和输入重定向可以合并使用 支持两种类型的文件：文本文件和二进制文件 例如我们写的c的源代码就是存储在文本文件中 而编译出来的c程序是存储在二进制文件中 二进制文件可以节省很大的存储空间 读写文件时需要区分是文本文件还是二进制文件 例如不能把二进制文件写入到文本文件中 因为可能会丢失二进制文件的结束字符 当无法确认是哪种形式的文件时 把文件设定为二进制文件是安全的做法 FILE *fopen(const char *filename, const char *mode);fp = fopen(\"in.dat\",\"r\") fopen函数返回一个文件指针 程序通常把指针存储在变量中 永远不要假设可以打开文件 所以需要测试fopen函数的返回值 关于文本文件的模式有r w a r+ w+ a+ 关于二进制文件的模式有rb wb ab r+b a+b 对一个文件进行读和写之间的转换 需要有定位函数 和 fflush函数 下面一段程序代码展示常用的打开与关闭文件的操作 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILE_NAME \"example.dat\"main()&#123; FILE *fp fp = fopen(FILE_NAME,\"r\") if(fp == NULL)&#123; printf(\"can not open %s\\n\",FILE_NAME) exit(EXIT_FILURE) &#125; ... fclose(fp) return 0&#125; 缓冲：写入流的数据实际是存储在内存的缓冲区中的 可以使用fflush函数清洗缓存区 例如fflush(fp) 或者 fflush(NULL) 可有改变缓冲区的写法setvbuf(steam ,buffer,_IOFBF,n) 记得修改缓存区需要在执行其他在steam操作之前 remove(“foo”)删除foo文件 rename(“foo”,”bar”)修改foo文件的文件名为bar 如果文件已经打开 无法改名 fprint和printf函数输出流写可变的数据项，并且用格式串来控制输出额形式 printf(“total:%d\\n”,total); 写入到stdout fprint(fp,”total:%d\\n”,total) 写入到fp scanf(“%d%d”,&amp;I,&amp;J); 从stdin中读入 fscanf(fp,”%d%d”,&amp;I,&amp;J); 从fp流中读入 这两个常用作模式匹配 scanf函数返回错误时有可能遇到这三种情况1文件末尾 2错误 3匹配失败 每个流会对应两个指示器 错误指示器和文件末尾指示器 当流上的操作失败时就会设置某个指示器 一旦设置指示器 就会保持这种状态知道clearerr函数清除指示器为止 feof函数和ferror函数来判断一个流的指示器是遇到文件末尾还是输入错误,当遇到错误时会返回EOF fputc函数和putc函数是putchar函数向任意流写字符的更通用的版本 有时候会用作宏来实现如 #define putchar(c) putc *((c),stdout) fgetc函数和getc函数用作从流中读取一个字符 用作宏时表示为#define getchar() getc(stdin) //遍历字符直到文件的结尾while((ch = getc(fp)) != EOF)&#123; &#125; 复制文件 fcopy f1.c f2.c puts函数 fput函数 与putc函数和fputc函数大体相似 只是操作的对象换成是一行字符串 gets函数 fgets函数的操作对象也是一行字符串 gets函数逐个读取字符 在遇到首个换行符后停止操作 并且丢弃此换行符 或者已经读入sizeof(str)-1个字符是结束操作 上面是介绍文本文件的输入输出函数 那么对于二进制文件 则使用fread函数和fwrite函数 sprintf函数和sscanf函数允许对字符串作为读流/写数据 他们与printf和fprintf很类似 不同是sprintf函数把输出写入到字符数组而不是流中 文件的定位 这个功能产生的需求是：如果文件包含一系列记录 我们希望直接跳到特殊的记录处 并继续对其进行读入或更新 相关的函数fseek 系统有定义三种宏 分别可以跳转到文件的开头 当前位置和结尾 最适合于二进制流 以字节计数进行移动 ####ctype.h 字符处理 字符测试函数 isalnum(c) c是否是字母或数字 isalpha(c) c是否是字母 iscntrl(c) c是否是控制字符 isdigit(c) c是否是十进制数字 islower(c) c是否是小写字母 ispunct(c) c是否是标定符号 isspace(c) c是否是空白字符 包含换页符``\\f 换行符 \\n 回车符 \\r 横向制表符\\t 纵向制表符\\v isupper(c) c是否是大写字母 isxdigit(c) c是否是十六进制数字 string.h 字符串处理/*复制*/char source[] = &#123;'h','o','t','\\0','t','e','a'&#125;char dest[7];memcpy(dest, source, 4); /*h,o,t,\\0 */strcpy(dest,source); /* h,o,t 复制以空字符结尾之前的字符*/strncpy(dest,source,7)/* h,o,t,\\0,\\0,\\0,\\0 追加空字符直至满足n=7*//*拼接*/char str[7] = \"tea\";strcat(str,\"bag\"); /* str现在包含字符串teabag 函数返回第一个参数指针*/strncat(str,\"bag\",2) /* 得到指向字符串teaba的指针 保证字符串始终以\\0结尾 *//*比较*/char s1[] = &#123;'b','i','g','\\0','c','a','r'&#125;char s2[] = &#123;'b','i','g','\\0','c','a','t'&#125;memcmp(s1,s2,3) /*输出0 比较前三个字符*/strcmp(s1,s2) /*输出0 遇到空字符串结束比较了*/strncmp(s1,s2,4) /*输出0 结合上面两个函数 当比较的字符数达到n个或其中任意一个字符是空字符就停止比较*/ /*搜索*/char *,str[] = \"Form follows function\";p = strchr(str,'f') /*finds first 'f' 函数返回一个指针指向第一个f*/p = memchr(str,'f',3);/*搜索指定字符数n后停止而不是直到空字符*/p = strpbrk(str,\"mn\");/*finds first 'm' or 'n'*/size_t len;len = strspn(str,\"morF\");/*len = 4返回字符串中第一个不属于给定字符集中的字符下标*/len = strcspn(str,\"morF\");/*len =0返回第一个属于给定字符集中的字符下标*/p = strstr(str,\"fun\");/*指向字符f 函数返回指向在字符串中找到的第一处匹配字符串的指针 如果找不到返回空指针*//*其他*/memset(a,0,sizeof(a));/*将数组全部初始化为0 返回他的第一个参数（指针）*/strlen(a) /*返回字符串的长度 不包含字符串末尾的空字符*/ ###错误处理 c中也有断言 assert a[i] assert(i&gt;=0 &amp;&amp; i &lt; n) a[i] = 0 如果i的值小于0或大于等于n 则程序终止 不再执行后面的赋值 断言会引入额外的检测 会增加程序的运行时间 要禁止断言只需要在包含之前定义宏NDEBUG即可 #define NDEBUG#include &lt;assert.h&gt; 一旦程序又有错误发生 去掉NDEBUG宏即可重新启动断言 注意断言尽量精简 不要与其他表达式写在一起 下面是不推荐的写法 assert((p = malloc(n+1) != null)) 一旦定义了NDEBUG malloc将不会执行 使用errno来判断程序是否运行错误 例如在调用函数之后检查errno的值如果不为0代表调用过程中有错误发生 /*运行前要记得先清零*/errno = 0;y = sqrt(x);if(errno != 0)&#123; ... exit(EXIT_FAILURE);&#125;/**/ 出错后 errno可能是下面的两种值 EDMO ：定义域错误 ERANGE : 取值范围错误 perror(“sqr error”) 输出一个字符串到stderr signal(SIGINT,handler) signal函数调用对SIGINT信号安装一个处理函数hander，一旦程序在执行过程中出现SIGINT信号，handler函数就会自动被调用 也有预定义的信号错误处理函数 都定义在signal.h的宏中 SIG_DFL 按默认方式处理信号 SIG_IGN 忽略该信号 也有情况是安装错误处理函数时就发生错误 此时可以使用SIG_ERR检测到 if(signal(SIGINT,handler) == SIG_ERR)&#123; /* error, can not install hander for SIGINT*/&#125; 信号处理完后 除非处理函数重新被安装 否则该信号不会被同一个处理函数调用 可使用raise函数触发信号raise(SIGABRT) 返回值可以用来测试调用是否成功 0代表成功 goto一般只能在同一函数内调用 但是中的setjmp和longjmp函数则允许不同函数之间的跳转并且不需要返回 经常用在错误处理 ###stdlib.h 通用的实用工具 新函数strtod strtol stroul 替代了旧函数atof atoi atol 用作把含有字符格式的数字字符串转换成他的等价数值 strtod string转换成double strtol string转换成long int stroul string转换成unsign long int 伪随机序列生成函数 int rand(void) ; void stand(unsigned int seed); atexit(cleanup); 函数允许用户注册一个临近程序终止时要调用的函数cleanup abort函数也是让程序终止 但是是异常终止也不能调用注册函数 属于一种不成功的终止 c调用外部环境 system(“ls &gt;myfile”) 在unix系统执行命令 system(“dir &gt;myfile”)在dos系统执行命令 bsearch函数用于有序数组的搜索 qsort可用于任何数组","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c语言","slug":"c语言","permalink":"http://luyaoming.com/tags/c语言/"}]},{"title":"了解Android测试工具","date":"2019-05-07T09:05:45.000Z","path":"2019/05/07/了解Android测试工具/","text":"总结下日常用到的Android软件测试工具 包括白盒和黑盒的 1. uiautomatorviewer一个包含创建测试、执行自动化测试的工具 Android SDK Tools：API 21 版本或者21以上版本; Android SDK Platform：API 16 版本或者16以上版本 查看ui控件位置的二进制文件在sdk/tools/bin/uiautomatorviewer 双击即可打开 windows的话会是bat文件吧 通过该二进制文件找到控件的id后 可以创建对应的UiObject 然后操控控件的点击 拖拽 滚动等功能 如下代码 // 通过id来创建出UiSelector 对象UiSelector = new UiSelector().resourceId(\"com.tencent.mobileqq:id/conversation_head\");// 通过UiSelector 对象 创建出 UiObject 对象 UiObject switcher = new UiObject(uiSelector ); // 判断该控件是否存在if (switcher.exists())&#123; //点击该控件 switcher.click();&#125; java的实现方式 需要继承UiAutomatorTestCase类 该类在uiautomator.jar中包含 生成build.xml后用ant工具进行编译最后生成一个 工程名.jar包 推到设备 /data/local/tmp 目录下 在adb shell 中执行： uiautomator runtest 工程名.jar -c 包名.类名 该方式每次改动后都需要编译和生成jar包 稍微麻烦 但是可以直接在设备下运行 如一些微信抢红包的小工具就可以通过这种方式实现 下面介绍python的方式来实现 python的实现方式 先通过pip安装uiautomator库 pip install uiautomator 然后就可以创建py文件写测试代码啦 最后将py文件加上执行权限 直接终端运行python3 xxx.py 即可 代码如下 from uiautomator import device as d #几种方式创建Device#d = Device('014E05DE0F02000E')#d = Device('014E05DE0F02000E', adb_server_host='192.168.1.68', adb_server_port=5037)d = Device()#屏幕点亮d.screen.on() d(text=\"Clock\").click()# press home keyd.press.home()# press back keyd.press.back()# click (x, y) on screend.click(x, y)# long click (x, y) on screend.long_click(x, y)# swipe from (sx, sy) to (ex, ey)d.swipe(sx, sy, ex, ey)# drag from (sx, sy) to (ex, ey)d.drag(sx, sy, ex, ey)# take screenshot and save to local file \"home.png\", can not work until Android 4.2.d.screenshot(\"home.png\")# wait for current window to idled.wait.idle()# wait until window update event occursd.wait.update() python版本的uiautomator的来自于民间作者xiaocong做的wrapper 下面贴一下他的github项目地址https://github.com/xiaocong/uiautomator更多api可以在他的项目下找到 2.Monkey使用方式很简单 // -vvv表示级别为详细 数字400表示运行的次数 --pct-touch表示点击事件占百分之50 -s 表示seed为1234 想重现使用同样的seed即可 最后执行结果保存到本地txt文件adb shell monkey -vvv -p com.tencent.mobileqq 400 --pct-touch 50 -s 1234 &gt; ~/monkey.txt更多扩展--pct-appswitch &lt;percent&gt; 在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法--pct-anyevent &lt;percent&gt; 它包含了所有其它类型的事件，如：按键、其它不常用的设备按钮等等--throttle &lt;milliseconds&gt; 用于指定用户操作（即事件）间的时延，单位是毫秒--ignore-crashes 忽略crash --ignore-timeouts 忽略anr--ignore-security-exceptions 忽略许可认证-help 更多指令 参考help引导最后搜索日志 一般搜索以下关键字即可 anr crash die exception","categories":[{"name":"test","slug":"test","permalink":"http://luyaoming.com/categories/test/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"测试工具","slug":"测试工具","permalink":"http://luyaoming.com/tags/测试工具/"}]},{"title":"追风筝的人-读书笔记","date":"2017-10-22T01:07:56.000Z","path":"2017/10/22/追风筝的人-读书笔记/","text":"这本书很薄 不过也花了3天才看完 追风筝的人 原著：（美）卡勒德·胡赛尼 读书笔记 by asii 故事讲的是一个阿富汗男孩阿米尔和他的既是仆人也是兄弟的人故事 这个仆人叫哈桑 他其实也是阿米尔同父异母的兄弟 但是阿米尔一直不知道 哈桑 和阿米尔喜欢放风筝 阿米尔是一个性格懦弱的男孩 被孩子欺负的时候 都是哈桑出面挡箭牌 有此遇到一个混混老大和他的两个跟班 哈桑和阿米尔被逼到走投无路 哈桑用弹弓指着混混老大 最后混混放走他们 阿米尔一直期待得到他的老爸 那位威武有力 刚正不苛的大男人的肯定 但他老爸一直觉得他儿子懦弱 柔弱 同时他对他老爸对待哈桑的关照表示妒忌 但是阿米尔和哈桑一直保持着很好的友谊 阿米尔在哈桑的帮助下赢得了那次风筝比赛 哈桑是个追风筝的能手 在那里的风俗是追到最后掉落的风筝是一件值得骄傲的事情 哈桑追到了那只蓝色风筝 但是被之前那个混混老大拦住了 混混老大要挟他要抢走风筝 哈桑之前跟阿米尔说过“为你 千千万万遍”宁死不屈 最后哈桑被那个混混老大爆菊了 还流了血 这一切都被在街角的阿米尔看在眼里 但懦弱的阿米尔并没有勇气去救他兄弟 就这样 哈桑和阿米尔之间产生芥蒂 阿米尔担心自己看到这经过而不去帮忙的事被哈桑发现 一直躲避哈桑 哈桑极力想挽回他们的友谊 但是被阿米尔的这种“不知道如何面对哈桑”的纠结心情拒绝了 到最后甚至想赶走啊里和哈桑 还曾经不经意跟他老爸提过 但他老爸愤怒地呵斥了阿米尔说阿里是他一起长大的兄弟 阿米尔在自己的生日礼物里挑了那块他老爸送他的手表和一些钱贼赃嫁祸了阿里和哈桑 哈桑其实是知道是阿米尔要嫁祸他的 因为他看得出来阿米尔一直在躲避他 其实也是想他走 在老爸问哈桑是不是哈桑偷的时候 哈桑说了是 那是他最后一次给阿米尔做挡箭牌 阿米尔也知道了其实哈桑知道阿米尔当时是没有出来救他的 最后阿里为了维护自己的和他儿子的尊严 在一个雨天离开了 阿米尔如愿以偿 但是不时也会想起他和哈桑度过的开心的日子 也会积累这些内疚 阿富汗发生政变 老爸和阿米尔辗转到了美国生存 阿米儿在那里毕业并且娶到了以前阿富汗一个将军的女儿 后来老爸积劳成疾死了 阿米尔回阿富汗接到了哈桑的儿子 那时候哈桑已经死了 怎么死的不知道 最后他们几个去放风筝 阿米尔想起了他和哈桑以前放风筝的日子 切断了对手的风筝后 对哈桑的儿子说 “为你 千千万万遍” 估计是他想让自己的内疚来弥补哈桑的儿子吧 阿米尔一直保守着秘密 那个哈桑和阿米尔的秘密 全书完 2017年8月31日 后来翻百度和知乎查一下 发觉自己阅读的是阉割版 没有了阿米尔回去救哈桑儿子的故事情节 但总体上不影响故事情节 这是一个关于犯错和自我救赎的故事 阿米尔的老爸跟阿里的老婆生下了哈桑 他偷走了哈桑的父爱 他偷走对阿米尔童年的关爱 他偷走了阿里的老婆 他在书里的那个正面形象何尝不是一种自我救赎呢","categories":[{"name":"novel","slug":"novel","permalink":"http://luyaoming.com/categories/novel/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"追风筝的人","slug":"追风筝的人","permalink":"http://luyaoming.com/tags/追风筝的人/"}]},{"title":"死了七次的男人-读书笔记","date":"2017-10-22T01:06:46.000Z","path":"2017/10/22/死了七次的男人-读书笔记/","text":"因为对这名字的猎奇心理而读的一本书 作者说这是一种科幻推理小说 建立在一个作者幻想的世界观下 然后进行推理的一种小说 小说题材新颖 尽管有相关的电影或电视题材 但是读书过程中通过作者的文笔可以感受到剧情的波澜起伏 引人入胜 有推理兴趣的同学都可以一读 死了七次的男人 原著：西泽保彦 读书笔记 by asii 书的主人公具有一种特殊的体质 当某一天跌入时空黑洞 他可以循环9次 但是只以最后一次为最终定稿 说是体质而不是异能 是因为这种情况不是他能控制的 在他报考高等学府考试的当天正好跌入了时空黑洞 所以让他以满分的成绩入学了 但是毕竟不是他能控制的 后面的考试 如果刚好跌入时空黑洞还好 如果没跌入 他的成绩就很差 导致了整体他在班级内的成绩在倒数 而在日常生活中 小q（主人公）他是一个淡泊名利 上进心不是很强的人 因为伴随着这样的体质 像已经看破了世界规律 使他的心理年龄不少于30岁 而肉体上他只是个高一生 前面都是介绍小q的背景 作者是建立在这个大前提下的推理小说 下面开始讲正在的故事情节 书里死了七次的男人不是小q 而是他的爷爷 他的爷爷以前是个厨师 后来酗酒 加上后来他妻子死了 他就酗酒更凶了 他家有三个女儿 大女儿一共有三个儿子 分别是富士高 世史夫 小q 而二女儿有两个女儿 分别是舞和榴奈 小女儿是胡乃留 膝下无子女 爷爷因为在妻子死后一直无尽到夫妻的责任 所以大女儿和二女儿都分别考上了大学然后出嫁了 远离了这个家 剩下胡乃留 差点逼疯了她 后来爷爷和胡乃留准备死之前买了彩票竟然中奖了 然后爷爷觉得这是天没有让他死 必定是否极泰来 所以开始做起厨师 经营的店还开了很多分店 后来还建立了一间大公司 变得有钱起来了 大女儿和二女儿 这些年他们的丈夫被离职在家借酒消愁了 具体原因是后来小q在爷爷的日志中找到的 为了投靠爷爷 这些年来爷爷都在过年的时候 元旦开始 叫他的女儿回来一起拜年 并且立下新的遗嘱 这年打算找一个作为胡乃留阿姨的养子或者养女 并且继承爷爷大公司的部分财产 家道中落的两个家庭都抓紧机会回来投靠爷爷 然而爷爷因为怨恨当年两个女儿对他和胡乃留阿姨的抛弃 都对他们的摇尾乞怜嗤之以鼻 但没有对他的孙子或孙女有半分怨恨 这个新年 爷爷要求他们都身穿不同颜色的运动服进行拜年 在进行宴会的时候 小q举杯祝酒 到晚上11点多左右就有点醉了 回楼顶睡觉 隔天起床的时候听见胡乃留和居子太太和爷爷在讨论因为没有红色纸而没有定下继承人的问题 其实爷爷是想折叠不同的纸鹤 用抓阄的方式 选定继承人的 这选定继承人的方式真的太随性了 小q继续去厨房吃早餐 然后见到爷爷带着酒过来 爷爷后来邀请小q去顶楼喝酒 小q饮到烂醉 一直睡到下午 然后坐车离开爷爷家 然后小q在睡梦中醒来 发现是在爷爷家 发现自己是掉进了时空黑洞 小q认为是1月2日掉进了时空黑洞 将会一直循环1月2日的事情 在第二轮小q认为的1月2日时 爷爷竟然意外地死了 小q认识到他是这些事件中的唯一变量 他的一举一动将会影响到整个事件的发生 在第二轮中他发现是本来有着隐藏的情侣关系的榴奈和富士高杀死了爷爷 所以在第三轮的时候 他决定拖着他们两个不让他们接近爷爷 然而 二女儿靠近了楼顶的爷爷 杀人事件再次发生 第四轮他决定将榴奈和富士高的事告诉舞 结果舞把爷爷杀死了 后来小q将各人叫过来开年会 杀人事件还是发生 无论小q如何阻止不让人接近爷爷 爷爷都会死 到后来才明白 爷爷其实是饮酒过多而死的 他没有死的那次其实是小q帮他分担了酒量 在其中一轮小q拿到了那些爷爷的日记并发现了很多爷爷的秘密 是他令两位女儿的丈夫失业的从而让他的女儿对他摇尾乞怜的 小q在其中一轮中向继承人之一（非家族内）的友理小姐表白了 后来在某轮中又发现友理说她有喜欢的人了 小q决定将这些事封锁在不曾发生的“历史”里 最后小q利用爷爷的秘密让爷爷不再饮酒 避免了死亡事件的发生 最终主角达到了他的目的 但是在这其中还存在这谜团 最后友理小姐帮忙揭开了谜团 原来小q循环的不是1月2日 而是1月3日 并且有一天是他死了 所以他向友理小姐表白的事情是真实发生了 所以才会被她约出来 后来富士高竟然和榴奈分开了 继承人的事情变成没有定论了 全书完 总体来讲 这是一部轻小说 最后的逆转的确有点意思 但是又有些牵强的味道 读者根本不会猜到就算小q死了 循环还会继续发生这样的逻辑 更不会认为爷爷在1月2日和1月3日第一轮早上说出关于折纸的同样的话 但是总体来说作者的确做到了让人欲罢不能 是一本好书 值得一读","categories":[{"name":"novel","slug":"novel","permalink":"http://luyaoming.com/categories/novel/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"死了七次的男人","slug":"死了七次的男人","permalink":"http://luyaoming.com/tags/死了七次的男人/"}]},{"title":"运动记录10月份","date":"2017-10-11T03:10:25.000Z","path":"2017/10/11/运动记录/","text":"我想要一个好的身体 但是不是说说了事 打算写个记录贴监督下自己 记录日常的运动 只要有恒心 铁杵磨成针 2017年10月11日 感受：跑的过程有点想呕吐的感觉 可能长期没运动的原因 起初先快步走 然后慢跑 然后在同一路段重复来回 设立短期目标 运动完后脚裸以上小腿有疼痛迹象 怀疑是热身运动没做够的后果 但是小腹明显感觉轻松 不再有鼓腹的感觉 明天继续 务必运动前做好热身 减少身体伤害 2017年10月12日 感受：小腿看来是慢慢适应这种运动状态了 第一天疼痛感强烈 第二天继续锻炼 已经不怎么疼了 今天的天气很舒服啊 有点凉风 选择了我昨天来回跑的路段 半走半跑 keep住啊！ 2017年10月13日 感受：天气开始变凉 慢慢有点感觉 继续keep 2017年10月14日 感受：今天的运动量稍微大啊 刚开始小腿大腿比较酸痛 跑了几个来回后 腿开始适应 习惯跑步的时候思考一些东西 使自己忘记了疲劳 明天是周日 也要keep住啊！ 10月18日 10月20日 10月23日 感受：今天开始 全程没有再停下来 现在基本上不会喘气 只是脚有点疼 但是坚持下来后 跑完整个人感觉很爽 明天继续 2017年10月25日 感受：全程没有停下来 右脚有点小疼 自从上星期去跟啊叔去完公园后 感觉右脚有点疼 双臂也有点疼 不应该一次性做过多剧烈运动 伤身体 以后注意 2017年10月31日 感受：用了一个小时运动 跑到后面基本上不觉得累了 呼吸也很顺畅 第一次在微信运动里拿了第一名 高兴了一会 右脚脚裸附近关节有些许疼痛感 注意热身 2017年11月3日 感受：隔了两天没运动 感觉浑身不自在 这次也是跑了一个小时 基本没停过 感觉跑完很爽","categories":[{"name":"Sport","slug":"Sport","permalink":"http://luyaoming.com/categories/Sport/"}],"tags":[{"name":"运动","slug":"运动","permalink":"http://luyaoming.com/tags/运动/"},{"name":"记录","slug":"记录","permalink":"http://luyaoming.com/tags/记录/"}]},{"title":"鬼吹灯-读书笔记","date":"2017-10-08T08:21:49.000Z","path":"2017/10/08/鬼吹灯-读书笔记/","text":"上学的时候 看过几部武侠小说 发觉自己都忘记了内容 看起电视的时候 叔叔和婶婶都回忆起故事情节 我却哑口无言 所以打算写点笔记 记下来看过的故事 情节也好 心得也好 好记性不如烂笔头 鬼吹灯 原著：天下霸唱 — — 读书笔记 by asii 精绝古城胡八一的书《十六字阴阳风水秘术》从他祖父那辈得来 还是个残缺版 他祖父生前是个纨绔子弟 抽鸦片 卖了所有东西 抽鸦片 买个白纸当老婆 白纸变女鬼 祖父没钱用去挖掘坟墓 被女鬼挖了心肝 女鬼要他带人来给他吃心肝 途中遇到个道士 道士帮他消灭了女鬼 道士死前把这本《十六字阴阳风水秘术》传给了祖父 后来这书传到了胡八一手上 然后开始讲胡八一 在当兵的时候 胡八一和他的战友就遇到过火瓢虫 九层妖塔和霸王蝾螈 胡八一当兵的时候 在对战越南战役的时候 越南兵用妇女假装孕妇携带炸弹来做人肉炸弹 杀死了不少胡八一的战友 胡八一愤怒之下射杀俘虏 幸好没有上军事法庭 被撤职了 后来回到老家 见到了好友胖子王凯旋 两人和燕子进的第一个墓就遇到了大粽子 红吼 后来发现了日本的关东军地下要塞 还遇到了草原大地赖 他们打不死红吼 让大地赖和红毛互相残杀 最后拿走了两块玉 给大金牙帮忙卖了 大金牙介绍胡八一去沙漠探险队当领队 开始认识Shirley杨 找了个活地图 安力满 带着陈教授和他的一些学生开始去沙漠寻找精绝古城 两次被白骆驼救 找到了遗址 黑蛇杀人 胡八一破解石阵 找到了密道 找到了水源 找到了个大眼玉可惜被胡八一摔了 遇到了尸香魔芋 迷惑学生自相残杀 见到了很多黑蛇 最后五人逃进了密室 密室有图 预言家语言了进来5个人 然后4个人 其中一个打开二层石匣 暗示他们之中有魔鬼 绑了Shirley 真真假假 原来被尸香魔芋迷惑他们自相残杀 最后靠尸骨的食指指了一条明路 逃生 龙岭迷窟由一只古老的鞋子做引子 这次是胡八一 胖子 大金牙三人的冒险 找到了鱼骨庙 鱼骨庙下面就是墓 他们找到了洞穴的虚位 要爬着进去 发现里面是唐代的墓穴 有唐代的壁画 但是又有西周的大脸鼎 后来不小心进入了悬魂梯 最后三人排成一排 避开了月牙的提示 才出得来 大金牙被人脸蜘蛛拖走了 胡八一和胖子救他 脱光了衣服 烧死蜘蛛 偶遇到稀有的闻香玉 巧克力味 没有淘到名器 就带着这玉出去了 然后开始说雪莉杨的前人鹧鸪哨 原来是搬山道人 为了找雮尘珠拜一个皈依佛教的人为师 该人之前是摸金校尉 进入了一个墓穴 带着一个途中遇到的神父 最后了尘师傅死了 鹧鸪哨没了只手臂 掏出来一块甲骨文的石头 胡八一和胖子身上长了红色的眼睛 追问了另一个教授 教授什么都不肯说 最后带着雪梨杨再去找他 期间认识了个算命瞎子 原来是个卸岭力士 他去过云南虫窟 没进去之前就被毒雾弄瞎了眼睛 但是倒出了一个描绘着云南虫窟的地图 根据那位教授提供的猜测 那个雮尘珠应该就在这里面 于是开始到云南的旅程 云南虫谷这故事比较长 也是我认为一路看下来写得最精彩的一部 下面开始回忆 胡八一和雪莉杨和王胖子根据算命瞎子给的地图来到了云南 目标是献王墓 坐车去的期间在途中遇到个石人俑 破了 里面装满了恶心的虫子 然后他们乔装成博物馆抓蝴蝶的 来到了彩云客栈过一夜就出发 做了个竹筏就出发 一路上见到很多倒挂的石人俑 不知道触发了什么开关石人俑一个个掉进了水里 里面很多虫子会游泳追着他们的竹筏 遇到了青麟大蛇 这大蛇吃这些虫子 吃完后还要袭击他们的竹筏 胡八一他们的装备不好啊 差点打不过这凶猛的大蛇 后来出现了一堆刀齿蝰鱼 这鱼牙齿异常锋利 他们没有眼睛 哪里有血就去哪里 这大蛇被胡八一他们弄出了血 于是被这些吃人鱼围殴 吃人鱼搞点了大蛇后又来进攻竹筏 幸好他们找到了上岸的地方 到目前为止还没找到献王墓的入口 就一连受到了几波攻击 上岸后快到夜晚了 找到了两棵大树的地方过夜 三人约定轮流睡觉 忽然间从大树上传来了鬼信号 于是上树查看究竟 上面有一架飞机残骸 树下面还有个水晶棺 棺材里面还有个大祭司 红色肉线依靠吸附丢下来的生物的生命养分提供给水晶棺内的大祭司 三人在树上还受到了大鸟的攻击 他们把大祭司的身体拔出来还拿了里面的名器 次日出发寻找献王墓入口 找到入口后看见里面的蜻蜓虫子 蟾蜍都很大只 再遇到了很多漂浮的女尸 这女尸也是用身体养虫子 给带着面具的霍氏不死虫当零食 霍氏不死虫战斗力强大 将虫子的尸毒转化为毒瘴大雾封锁盗墓者进来 后来还是被王胖子用炸药炸死了 其实它只是暂时行动不了 霍氏不死虫吐出了一个箱子有三格 最后一格是一只蓝色三脚青蛙 其实是一个影响飞行航线的陨石 没有了霍氏不死虫吐出来的红色气体 那些女尸身上的胎儿开始脱落形成怪婴 三人慌忙逃脱 胡八一掉进了深潭 里面有飞机残骸 进入凌云宫殿 进去后发现非常华丽的装修 他们撬开一个煮尸鼎后听到诡异的笑声 发现红色衣服传过来的 胡八一让胖子去烧衣服 胖子贪心摸到了一块玉还舔了一下 被蛊附身 胡八一冒着被水银淹没的危险在墙壁里找到了玉函 胖子被蛊迷惑想吃尸体 被胡八一发现被挑出舌头肉刺 后来发现献王墓的墓道入口就在潭里 终于到了了献王墓的主墓室 里面三口棺材 其中一个还吊在空中 这三个棺材里装的都是献王的影骨 是他的前世骨头 后来发现了献王的老婆 尸体里还有飞蛾 飞蛾有毒 三人最后找到了最后的墓室 这墓室就是万年太岁化成的 里面有很多人手在不断拉人进去（脑补下） 胡八一找到了献王的棺材 割下了包含雮尘珠的献王人头 开始跑路 太岁发生尸洞效应 开始吞噬一切 三人逃出来一直被尸洞追着 雪莉杨还中了尸毒 幸好中途找到了个植物解毒 痋人（怪婴）与尸洞大战 痋人都被吸进去了 胡八一毁掉那个三脚青蛙 搭着霍氏不死虫的顺风车走出来 这尸洞一直追着献王的人头 胡八一几次想把人头还他了 最后把尸洞引到谷口 用“青龙顿笔”的风水毁了尸洞 三人终于得救 接着开始回忆胡八一当兵时候的支线剧情","categories":[{"name":"novel","slug":"novel","permalink":"http://luyaoming.com/categories/novel/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"鬼吹灯","slug":"鬼吹灯","permalink":"http://luyaoming.com/tags/鬼吹灯/"}]},{"title":"Linux命令行大全-读书笔记（二）","date":"2017-02-24T13:07:47.000Z","path":"2017/02/24/Linux命令行大全-读书笔记（二）/","text":"配置与环境 主要涉及一些环境变量 vi操作 定制提示符 常见任务和主要工具 配置环境printenv 可以可以检查环境变量printenv | less 可以输出到less中 set 显示shell变量 环境变量 以及任何已经定义的shell函数set | less 查看 shell会话有两种类型 login和non-login的login shell的启动文件有这些：/etc/profile ~/.bash_profile ~/.bash_login ~/.profilenon-login shell的启动文件有这些：/etc/bash.bashrc ~/.bashrc .bash_profile 一般会先读取用户的配置文件 ~/.bashrc 环境变量在PATH中 使用冒号:分隔开最后export PATH 修改完环境变量后 可以不关闭shell窗口 直接 source .bashrc 读取一下生效 使用vii 就是insert的缩写 插入模式 l h j k 这4个是移动光标命令 数字0移动到行首 o 字母o插入空白行 在当前行的上方 大写O插入空白行 在当前行的下方 x 删除当前字符 dd 删除当前行 5dd 删除当前行和以下的4行 u 撤销操作 yy 复制当前行 5yy复制当行行和以下的4行 yG复制当前行到文件末尾 fa 查找当前行的a字符 /neeee 斜杠搜索整个文件neeee字符的存在 :%s/Line/liss/g 搜索整个文件Line字符串 并且替换成liss 直到文件结尾 g后面加c 可以结合用户确认 vi file1 file2 打开多个文件 :n 切换下个文件 :N切换上个文件 :r tes1.txt 可以当前行插入tes1.txt的文件内容 :w 保存文件 在命令模式下 大写ZZ可以保存并退出 定制提示符修改提示符 我们平时见到的 用户名@主机名：路径$ 可以被修改例如先保存PS1的提示符 ps1_old=”$PS1” ps1=”\\A \\h |$ “ 提示符会变成 分钟 主机名 $恢复修改过的提示符PS1=”ps1_old” 可以把PS1保存到.bashrc中 export PS1 软件包管理主流软件包主要有两种.deb 和.rpm.deb: 有Debian、 Ubuntu、 Xandros等.rpm: 有Fedora 、CenOS 、Red Hat 目前我在使用Ubuntu系统 所以需要安装的是.deb的软件包 使用高级工具会自动安装依赖 sudo apt-get update 从库源中安装软件依赖 还有apt-get install emac package_name 指软件包的实际名称 package_file 指软件包的文件名 如果是从网上下载的软件包 可以使用低级工具安装 此时不会安装依赖包 dpkg - -install packagefile.deb或者rpm -i package_file.rpm 卸载软件包可以高级也可以用低级 如apt-get remove package_name 或者yum erase package_name 更新软件包 可以让系统一条命令更新从库源中获取到的所有更新包 apt-get update;apt-get upgrade dpkg - -list 可以列出已经安装的软件包 dpkg - -status package_name 查看安装情况 apt-cache show package_name 查看已经安装的的软件包信息 dpkg - -search file_name 查看具体某个文件由哪个软件包安装得到 存储介质less /etc/fstab 文件内容列出系统启动时挂载的设备 信息包含设备名 挂载节点 文件系统类型 等 sudo mount /dev/sdb1 /mnt/flash 将‘/dev/sdb1’文件设备挂载到‘/mnt/flash’目录下 mount 查看已经挂载的文件系统列表 on前面的设备名 on后面跟着的是挂载节点如果要改这个挂载节点即文件的路径位置 要怎么改呢 要先卸载设备使用umount 设备名称这个操作需要先获取超级用户sudo su - 然后cd到想要挂载节点的路径下 调用mount -t 设备类型 设备名 . 即可 调用ls即可查看挂载的设备文件内容 如果此时调动umount卸载会提示busy 需要先把工作目录切换到其他地方再调用 就ok了 sudo tail -f /var/log/messages 如果使用的系统不可以自动挂载设备 那么查看这个文件的最后几行可以查看到设备的文件名 sudo fdisk /dev/sdb 磁盘分区命令 输入m查看更多命令 sudo mkfs -t ext3 /dev/sdb1 为/dev/sdb1设备创建新的文件系统 格式为ext3可配合格式化使用 如sudo fdformat /dev/fd0 格式化/dev/fd0这个设备 然后再创建新的文件系统 sudo mkfs -t vfat /dev/fd0 sudo fsck /dev/sdb1 检测设备问题 dd命令可用于设备间转移数据 例如 dd if=/dev/sdb of=/dev/sdc 将sdb的文件内容转移到sdc设备 又或者转移到电脑 dd if=/dev/sdb of=flash.img 如果你要从一个光盘中创建一个iso镜像 可以这样dd if=/dev/cdrom of=ubuntu.iso enisoimage命令允许我们从一个文件夹创建成一个iso镜像文件 如genisoimage -o cd-rom.iso -R -J ~/cd-rom-file 就是把~/cd-rom-file这个文件夹以及包含的内容提取成cd-rom.iso 镜像 其中-R -J命令指在linux和window中可以使用较长文件名 这时我们已经可以把iso存在于一个光盘中 接着 就可以把该镜像文件挂载到硬盘的文件目录下 mount -t iso9660 -o loop cd-rom.iso /mnt/iso_image 但不需要时可以随时umount wodim dev=/dev/cdrw blank=fast 擦除cd-rom 擦除类型为fast类型wodim dev=/dev/cdrw image.iso 把/dev/cdrw文件目录写入到iso镜像文件中 md5sum image.iso 得到一个16位的字符串 校验iso镜像文件的完整性 网络ping baidu.com 向网络主机发送IMCP ECHO_REQUEST 数据包 验证网络是否接收正常 防火墙经常用来阻止IMCP通信 用ctrl+C来停止ping traceroute baidu.com 跟踪网络数据包的传输路径 会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表 netstat -ie 检查网络数据 ftp fileserver_name 连接文件服务器 lftp 更好的ftp（支持下载重连 后台进程） wget url 非交互式网络下载工具 ssh remote-sys 安全登录远程计算机 scp remote-sys:document.txt . 使用ssh加密隧道进行网络间文件复制 不过不是本地系统的用户 需要在remote-sys前加用户名@ sftp则为安全的ftp版本 使用的不是ftp服务器而是ssh服务器 文件搜索locate较简单的方式查找文件 以寻找指定路径名与给定字符串相匹配的文件 例如查找bin路径下zip开头的文件 如 locate bin/zip注意在macOs中 如果提示数据库没生成 需要输入sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plistsudo /usr/libexec/locate.updatedb findfind可以根据文件的属性 在既定的目录（及其子目录）中查找 最简单的用户如 find ~可以把标准形式输出的结果作为其他程序的输入 如 find ~ | wc -lfind 有test选项 action选项和options选项 先说test选项 使用-type可以指定文件类型 如find ~ -type f | wc -lfind支持的文件类型有b 块设备文件 c 字符设备文件 d 目录 f 普通文件 l 符号链接可以查找所有符合.jpg 通配符格式以及大小超过1mb的普通文件`find ~ -type f -name “.jpg” -size +1M | wc -l`size支持的计量单位有b 512字节的块 c 字节 w两个字节的字 k M G列出find命令常用的test参数 test参数 描述 -cmin n 匹配n分钟前改变状态内容或属性的文件或目录 不到 -n 超过 +n -cnewer file 匹配内容和属性的修改时间比文件file更晚的文件或目录 -empty 匹配空文件以及空目录 -group name 匹配属于name组的文件或者目录 -iname pattern 与-name test选项功能类似 只是不区分大小写 -newer file 匹配内容的修改时间比file文件更近的文件和目录 例如备份后修改了文件可以使用此命令 -size n 匹配n大小的文件 不到-n 超过+n -type c 匹配c文件类型的文件 -user name 匹配属于name用户的文件或者目录 find命令还支持逻辑操作符 如我需要查找那些访问权限不是0600的文件和访问权限不是0700的子目录find ~ \\( -type f -not -perm 0600 \\ ) -or \\( -type d -not -perm 0700 \\)其中\\是转义字符 逻辑操作符包括 -and -or -not action选项test选项用来查找那些文件那么action就是用来对找到的文件进行处理的 例如 -delete -ls -print -quit也可以使用用户自定义操作 格式为 -exec command {} ; 例如 使用-exec完成-delete操作 -exec rm ‘{}’’;’ 这里使用引号为了避免在shell里直接编译 使用+结尾可以只执行一次命令 如find ~ -type f -name &#39;foo*&#39; -exec ls -l &#39;{}&#39; +使用xargs可以达到相同的效果 他是把前面的搜索结果作为 后面的命令的参数 如find ~ -type f -name &#39;foo*&#39; | xargs ls -l使用-ok可以询问用户是否执行 算是后悔药前的提醒吧 find ~ -type f -name &#39;*bak&#39; -ok -delete option选项option选项用于控制find命令的搜索范围 如 -depth -maxdepth levels -mount 备份与归档gzip -文件压缩最简单的用法就是gzip ~/test/foo.txt 而解压就是gunzip ~/text/foo.txt 加入-r参数可以递归压缩 gzip -d 相当于gunzipbzip2 -以牺牲压缩速度来换取高质量的数据压缩bzip2 ~/test/foo.txt 解压 bunzip2 ~/test/foo.txt tar -磁带归档工具创建归档文件tar cf test.tar testdir 而查看tar文件有什么内容 tar tf test.tar zip - 打包压缩工具zip程序即是文件压缩工具也是文件归档工具 常用zip -r test.zip test 加了-r是为了递归压缩子目录内容 unzip ../test.zip 正则表达式grep -文本搜索grep命令通常的格式是 grep [options] regex [file…] grep bzip dirlist.txt 在指定文件集合中搜索包含bzip字符的行正则表达式的元字符包含^ $ . [ ] { } - ? + ( ) | \\grep包含很多选项 -i 忽略大小写 -v不匹配 -c输出匹配数目 -l输出匹配项文件名 -n 在匹配行前面加上该行在文件内的行号-h 进行多文件搜索时 抑制多文件输出 任意字符 . 点点表示任意的单个字符 必定存在一个占位符 例如 grep -h ‘.zip’ dist*.txt 输出结果不会只包含zip的文件 锚在正则表达式里插入符^表示开头 $表示结尾例如 grep -h ‘^zip’ dist.txt 表示查找以zip开头的匹配项 grep -h ‘^zip$’ dist.zip 查找以zip为单独一行的匹配符 中括号表达式和字符类中括号用于匹配括号内的表示字符集的单个字符 例如 grep [abc] 表示查找的字符串可以包含a或者b或者c中一个插入符^在括号内开头表示否定 例如grep -h ‘’[ ^ bg]zip’ dir.txt 表示匹配不以b或者g结合zip的字符串中括号内的-表示字符范围 例如grep -h ‘^ [ A-Za-z0-9 ]’ dir.txt 表示匹配以字母或数字开头的字符串 ? 匹配前面的元素0次或1次 * 匹配某元素多次或0次 + 匹配某元素一次或者多次 {n}指定重复出现n次 举例：电话号码的出现形式 (nnn)nnn-nnnn 和 nnn nnn-nnnn 中的一种 可以使用以下两种方式匹配第一种： ^\\(?[0-9][0-9][0-9]\\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$第二种：^\\(?[0-9]{3}\\)? [0-9]{3}-[0-9]{4}$如果想验证上面正则表达式的有效性 可以使用如：echo &quot;(555) 123-4567&quot; | grep -E ^\\(?[0-9]{3}\\)? [0-9]{3}-[0-9]{4}$ 如果有结果打印出来证明有效 vim和less都支持正则表达式 在底部输入 / 符号后开始输入正则表达式 匹配的内容会自动标注 zgrep命令可以对压缩文件进行搜索 文本处理cat 进行文件之间的拼接 并且输出到标准输出如： cat &gt; ff.txt 然后输入一段文字后 按ctrl+D 结束输入 那么输入的文字会输出到文件末尾将两个文件合并成一个文件 如果两个都是字符串内容就直接进行拼接 cat foo1.txt foo2.txt &gt; foo3.txtcat的一些选项-n 对行编号 -s 禁止输出多个空白行 用法如 cat -ns foo.txt 也可以不加任何选项 使用cat foo.txt输出 sort 对文本进行排序 如sort &gt; foo.txt 将等下输入的内容进行排序并且输出到foo.txt文件内sort 直接对一个文件进行排序 sort foo.txtsort的选项 -f 排序时不区分大小写 -r 逆序排序 -n按字符串的长度排序而不是按字母表顺序可以排序多个文件的内容并进行拼接 如sort foo1.txt foo2.txt foo3.txt &gt; foo4.txtsort命令还可以配合du命令进行使用 du命令是用来显示文件或者目录所占的磁盘空间大小的命令例如 du -ha ~/hexo | sort -nr | head 输出hexo目录下前10个按内容大小从大到小排序的文件名称和大小 uniq 通知或者省略重复的行 注意uniq只对排序好的行起作用 一般配合sort命令使用如 sort -r foo.txt | uniquniq的选项 -c 输出重复行 并且前面加上出现的次数 -d只输出重复行而不包含单独行 comm 逐行比较两个已经排序的文件如 comm 1.txt 2.txt 然后会输出三列内容 第一列表示第一个文件独有的行 第二列表示第二个文件独有的行 第三行表示两个文件所共有的行 可以使用选项省略这三列内容的哪些列 如 comm -12 1.txt 2.txt 省略第1 2列的内容 tr 替换或者删除字符如 cat foo.txt | tr a-z A-Z 将foo.txt里的内容 小写转为大写echo “dadadaaaa” | tr aaaa bbbb 将字符串里的aaaa替换成bbbbcat foo.txt | tr -d ‘da’ 将foo.txt里的内容删除da sed 用于文本过滤和转换的流编辑器如 echo ‘front’ | sed ‘s/front/back’ 输出为back 意义是将front转换成back 斜杠是分隔符也可以使用其他分隔符如下划线可以指定只替换第几行 如 echo “front” | sed ‘1s_front_back’ 只替换第一行的front","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/categories/Linux/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://luyaoming.com/tags/shell/"}]},{"title":"Linux命令行大全-读书笔记（一）","date":"2017-02-15T13:58:54.000Z","path":"2017/02/15/Linux命令行大全-读书笔记（一）/","text":"记录下自己学习加复习Linux命令行的过程 这部分笔记也记录在代码工具snippets中 奈何未开通分享功能 只保留在mac中 所以上传到此 Linux基础命令有什么不懂可以 命令符号 –help查看如何使用 也可以help 命令 less 打开文本less file mv 移动或者重命名mv file1 file2 ls 列出文件列表ls -l 文件列表详情ls -F 文件格式（是否文件夹）ls -t 按时间排序ls -r 反向排序 （默认按字母 加上-t就是按时间反向排序） cd 打开目录cd dircd .. 父目录（相对路径） mkdir 创建文件mkdir dir1 cp 复制文件cp file1 file2 dir file 参看文件类型file filename ln 创建硬链接ln file file-link 创建硬链接 （无法指向文件）ln -s dir dir-link 创建符号链接 （可以指向文件） type 参看命令的类型type cd which 显示可执行程序的位置which ls man 显示程序的手册页man ls apropos 显示合适的命令（按关键字搜索）apropos sym whatis 显示命令的重要描述whatis ls info 显示程序的info条目info ls alias 为命令添加别名 (直接输入alias 可以查看所有定义过的别名)alias foo=’cd /usr; ls; cd -‘ unalias 删除别名unalias foo 重定向符号 可以重定向标准输出和标准错误 ls -l /usr/bin &gt; ls-output.txt (把ls -l /usr/bin 命令执行的结果输出到该txt文本中)执行ls命令失败会清空ls-output.txt的内容 相当于把空白覆盖到之前的内容使用&gt; testClear.txt 重定向命令可以创建 testClear.txt文件或清空该文件的内容使用ls -l /usr/bin &gt;&gt; ls-output.txt 注意&gt;&gt; 符号表示在ls-output.txt内容的末尾最佳内容而不是覆盖 2&gt; 标准错误重定向ls -l /bin/usr 2&gt; ls-error.txt (把ls -l /bin/usr 命令执行错误时 错误信息输出到该txt文本中)注意0代表标准输入文件 1代表标准输出文件 2代表标准错误文件 2&gt;&amp;1 重定向到同一个文件ls -l /usr/bin &gt; ls-out.txt 2&gt;&amp;1 (把标准输出和标准错误到输出到ls-out.txt文件中)或者ls -l /usr/bin &amp;&gt; ls-out.txt 也可以达到同样的效果 dev/null 位桶 接收输入但不对输入做任何处理 cat 标准输入重定向cat ls-output.txt 显示txt文本内容cat movie.mpeg.0* &gt; movie.mpeg 接收多个file并且合并成一个cat &lt; ls-output.txt 把标准输入的源从键盘变成ls-output.txt文件 | 管道符号 把一个命令的标准输出 传送到 另一个命令的标准输入中ls -l /usr/bin | less 把|前面的结果传送到less命令的标准输入中（就是说把一个命令的结果通过分页(文本)形式显示） 管道过滤 sortls -l /usr /usr/bin | sort | less 把这两个目录执行一次排序后 通过分页方式显示出来uniq 显示重复行或去除重复行ls -l /usr /usr/bin | sort | uniq | less 使用uniq去除重复行 使用uniq -d 显示重复行 wc 打印行数 字数 字节数wc ls-output.txtwc 直接打此命令后return 会接收键盘标准输入 按ctrl+d结束输入wc -l ls-output.txt 只显示行数 grep 搜索匹配字符的过滤ls -l /bin /usr/bin | sort | uniq | grep bin | less 这段代码列出匹配包含“bin”字符的文件或文件夹grep -i bin 选项可以忽略大小写 head / tail 过滤前10行或者后10行head ls-output.txthead -n 5 ls-output.txt 只输出前5行tail -f /var/messages 使用-f可以持续监控这个文件 一旦添加新行 就显示在屏幕上 ctrl+c结束 tee 从标准输入读取数据 并同时输出到标准输出和文件中ls -l /usr/bin | tee ls-output.txt | grep bin tee相当于一个T型管道 分流到tee中的文件 又继续向下传递下去 echo 输出一行文本echo * 输出该目录下所有文件名echo $((3+4)) 输出7 使用echo加表达式 这种叫算术扩展 只支持整数echo fontstr{a,b,c}backstr 将打印三个字符串echo {1..5} 将打印1到5个数字echo {Z..A} 将打印Z到A倒序的字母参数扩展用在shell脚本中比直接用在命令行中更为有用 $ (命令) 代替命令 把一个命令的输出作为另一个命令的输入ls -l $(which cp) 把cp命令的路径作为ls的入参 输出cp的详细信息 使用双引号去除不想要的扩展 空格ls -l “tes 1.txt” 例如tes 1.txt是一个带空格的文件名ls -l “$((9+3)) $(cal) {1..6}” 双引号下算术扩展 参数扩展 命令替换 依然生效 使用单引号可以去除所有的扩展echo -l ‘$(ls)’ 将只会输出$(ls) 反斜杠作为转义字符echo “the pen is \\$3.00” 可以成功输出$echo -e “dada \\ndada” \\n是换行转义字符 加上参数e才可生效 -r回车 -t 制表 history显示输入过的命令历史 几个常用的移动光标的快捷键ctrl+A 移动光标到行首ctrl+E 移动光标到行尾ctrl+L 清屏并把光标移动到左上角 和clear相似 修改命令行文本快捷键ctrl+D 删除光标处的字符ctrl+K 剪切从光标开始到行尾的文本ctrl+U 剪切从光标开始到行首的文本ctrl+Y 把kill-ring缓冲区中的文本黏贴到光标位置tab 自动补齐功能 history 查看命令的使用历史 文件属性 r (read) ：运行打开和读取 w(write): 允许写入和截短文件 x：允许文件当作程序来执行使用ls -l test.txt 就可以看到文件属性 组成格式：文件类型 所有者权限 组权限 其他用户权限 chmod 更改文件模式 只有超级用户和文件所有者才有权更改 可以用8进制数字来表示文件的属性 例如文件模式rwx 二进制位111 8进制为7 chmode 600 foo.txt 表示把该txt文件的权限改为 rw- --- --- 常用的二进制和8进制的映射是这几个：7(rwx) 6(rw-) 5(r-x) 4(r--) 0(---) 用户权限 符号表示法：u表示user g表示群组 o表示其他人 a表示所有如果没有指定字符默认是a 而+表示增加一种权限 -表示删除权限 =表示只有指定权限可用 其他所有权限被删除u+x 为文件所有者添加可执行权限u-x 删除文件所有者的可执行权限+x 为所有用户添加可执行权限 相当于a+xo-rw 删除其他所有用户的读写权限go=rw 除了文件所有者之外 设置所属群组和其他用户具有读写权限u+x,go=rx 指定多种权限时 用 , 分割 umask 设置默认权限 例如 umask 0022 就是去除群组和其他用户的w权限 理解下mask就是遮盖的意思 0022实际是由三个二进制组成像这样 000 000 010 010 对应的是--- rw- r-- r-- su 用另一个用户的身份来启动shell 可以用su -l 或者su - 启动 执行命令的格式是su -c ‘ls -l’ 默认是没有设置root密码的 sudo passwd root 来设置密码sudo 不需要输入超级用户密码 不需要进入启动新的shell环境 命令不需要用单引号 chown 更改文件所有者和所属群组sudo chown tony: ~tony/myfile.txt 把myfile.txt文件的文件所有者改为tony chgrp 更改文件所属群组 与chown使用方式相似 passwd 更改用户密码sudo passwd asii 可以指定更改asii用户的密码 直接passwd就是更改用户自己的密码 ps 当前所有进程的运行情况ps x 显示所有进程 top 动态查看进程信息 相当于window的任务管理器 ctrl+c 终端进程 ctrl+z 暂停进程 vim &amp; 在后台运行vim进程 jobs 查看作业中的进程 fg %1 把后台进程还原到前台可以先jobs查看作业中的进程 然后bg %[作业编号] 把进程已到后台运行 也可以fg %1移动到前台进行如果忘记使用&amp;来运行后台进程 那么可以先ctrl+z暂停当前进程 再bg %1让他运行于后台 kill 进程pid 中止进程 killall 进程名称 ：中止多个进程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/categories/Linux/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://luyaoming.com/tags/shell/"}]},{"title":"是时候学一波ios开发","date":"2016-11-14T13:56:57.000Z","path":"2016/11/14/是时候学一波ios开发/","text":"曾几何时有过这么一个念头 但是一直没有时间入坑 与其所没时间 不如说自己懒 最近入职的公司 开会时 高级经理问我会不会ios开发 我尴尬一笑 不会 某次跟同事吃饭 我跟他讲了很多Android相关的东西 他偶尔一问我 会不会ios开发 我尴尬一笑 不会 公司需要一个ios端的应用 不需要上app store 满足需求即可 经理说到时需要招个搞ios 实习生级别的 我想如果我会ios 我把这个也搞了算了 所以我下定了决心 搞起 至于怎么搞 网上的教程铺天盖地 多亏了达内 北大青鸟等培训机构 培养了那么多“互联网创业者” 学习资料都可以在网上有完整的下载 有个旧同事 以前搞ios的 给了我一套比较完善的学习方案 而且提供了两种选择 oc or swift 我的想法是 都学 基于我对Android系统的理解 和 多年开发的经验 估计上手难度不会太难 而且学习设备已经齐全 就差一股学习的劲头 突然想起 近年来 fb公司推出了一个很热的跨平台开发reactive native 只要是精通前端搞web的人 都可以搞移动开发了 是不是我们这行都该转行？ 我的想法是 不至于 跨平台是好 learn once write anywhere 但是很多公司目前还是需要原生开发的 再者 学移动开发的 再去学rn 学js 写css 也不能说转行 只不过是扩充下知识面而已 举一反三 触类旁通 剁手节一件衣服没买 买了300多块钱的书 不说了 学习去~","categories":[{"name":"IOS","slug":"IOS","permalink":"http://luyaoming.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://luyaoming.com/tags/ios/"}]},{"title":"Android代码风格导向","date":"2016-11-02T14:06:17.000Z","path":"2016/11/02/Android代码风格导向/","text":"代码风格 项目导向指引 code stylejava语言规则不要忽略异常写代码时 有时候图方便 加了try catch 但是没有在catch里处理 像下面的 void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; &#125;&#125; 可以接受的处理异常的方式如 把异常抛给调用该方法的人 void setServerPort(String value) throws NumberFormatException &#123; serverPort = Integer.parseInt(value);&#125; 抛出一个新建的适合我们理解的异常 void setServerPort(String value) throws ConfigurationException &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; throw new ConfigurationException(\"Port \" + value + \" is not valid.\"); &#125;&#125; 直接在catch里处理掉这个异常 /** Set port. If value is not a valid number, 80 is substituted. */void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; serverPort = 80; // default port for server &#125;&#125; 抛出运行时异常 这种方式有点危险 仅在你确定这种错误会引起程序崩溃时使用 /** Set port. If value is not a valid number, die. */void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; throw new RuntimeException(\"port \" + value \" is invalid, \", e); &#125;&#125; 最后一种 自信不处理 但是需要加comment /** If value is not a valid number, original port number is used. */void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; // Method is documented to just ignore invalid user input. // serverPort will just be unchanged. &#125;&#125; 不要捕捉大异常这是一种偷懒的方式 /** If value is not a valid number, original port number is used. */void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; // Method is documented to just ignore invalid user input. // serverPort will just be unchanged. &#125;&#125; 这很危险 因为这么做意味着你不期待任何异常发生（包括像ClassCastException这种运行时异常）不要用同一种方式来处理所有异常 就算你需要这么做也要加适当的注解 Remember: exceptions are your friends! 不要使用Finalizersgc在对象有不可达路径时不会立即清除该对象 而是先访问该对象的finalized方法 这是该对象生还的最后稻草线 人们通常在这方法加入一大块代码处理清除外部资源等 但是不保证这个方法会被执行 Android不使用finalizers 如果确实需要这种清除操作 可以像InputSteam那样提供一个close方法来进行资源回收 finalizers只配打印下log 高质imports当你确定只需要使用bar组件时import foo.Bar 不要使用import foo.* java风格规则使用javadoc 标准注解使用如下的标准方式 顶部有copyright 接着包名 imports 类名（接口名）记得在类前注解这个类的用途或用法 /* * Copyright (C) 2015 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.android.internal.foo;import android.os.Blah;import android.view.Yada;import java.sql.ResultSet;import java.sql.SQLException;/** * Does X and Y and provides an abstraction for Z. */public class Foo &#123; ...&#125; 写简短的方法根据面向对象的设计原则 单一职责原则 一个方法内应该包含强相关性的东西 加入一个方法超过40行 可以考虑下拆分 在适当的位置定义成员变量要么在文件的头部 要么在使用该变量的方法前 限制局部变量的使用访问使局部变量的范围最小化 所有局部变量都应该有一个初始化 如下 // Instantiate class cl, which represents some sort of SetSet s = null;try &#123; s = (Set) cl.newInstance();&#125; catch(IllegalAccessException e) &#123; throw new IllegalArgumentException(cl + \" not accessible\");&#125; catch(InstantiationException e) &#123; throw new IllegalArgumentException(cl + \" not instantiable\");&#125;// Exercise the sets.addAll(Arrays.asList(args)); 即使用一个方法包住了try catch 在使用前也应该初始化s 如下 Set createSet(Class cl) &#123; // Instantiate class cl, which represents some sort of Set try &#123; return (Set) cl.newInstance(); &#125; catch(IllegalAccessException e) &#123; throw new IllegalArgumentException(cl + \" not accessible\"); &#125; catch(InstantiationException e) &#123; throw new IllegalArgumentException(cl + \" not instantiable\"); &#125;&#125;...// Exercise the setSet s = createSet(cl);s.addAll(Arrays.asList(args)); import的顺序 Android imports 第三方（com junit net org） java 和 javax 同一个项目的imports 成员变量的命名 非public 非static的成员变量开头使用m 静态成员变量开头使用s 其他成员变量开头使用小写 public static final变量（常量）使用大写连接 例子： public class MyClass &#123; public static final int SOME_CONSTANT = 42; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; 使用标准支架风格日常使用的if else最多 //你可以这么写if (condition) &#123; body();&#125;//或者这么写if (condition) body();//但 不要这么写if (condition) body(); // bad! 使用标准的java注解常用的java注解有@Deprecated @Override @SuppressWarnings 使用抑制警告时 最好前面加个TODO // TODO: The third-party class com.third.useful.Utility.rotate() needs generics@SuppressWarnings(\"generic-cast\")List&lt;String&gt; blix = Utility.rotate(blax); 一些缩写单词的最佳写法 Good Bad XmlHttpRequest XMLHTTPRequest getCustomerId getCustomerID class Html class HTML String url String URL long id long ID 上述观点参考文章 Code Style for Contributors Project guidelines项目结构在Android studio的项目代码结构与eclipse的不一样 主要包含两大目录 src/main/ src/androidTest/ 两个目录下又包含 java/ resources/ java代码应该分布在src/main/java目录下 manifest分布在src/main/AndroidManifest.xml 注意src/androidTest/AndroidManifest.xml并不是必须的 他只是自动生成的 加入项目时从eclipse迁移过来的 可以修改gradle目录结构 如 android &#123; sourceSets &#123; main &#123; manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] &#125; androidTest.setRoot('tests') &#125;&#125; gradle的设置可以参考Gradle Plugin User Guide 文件命名类名命名应该遵循驼峰结构 如SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog 资源命名资源命名使用小写和 _ 下划线分隔符 例如Drawable文件的命名规则 Asset Type Prefix Example Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png icon的命名 Asset Type Prefix Example Icons ic_ ic_star.png Launcher icons ic_launcher ic_launcher_calendar.png Menu icons and Action Bar icons ic_menu ic_menu_archive.png Status bar icons ic_stat_notify ic_stat_notify_msg.png Tab icons ic_tab ic_tab_recent.png Dialog icons ic_dialog ic_dialog_info.png selector的命名 State Suffix Example Normal _normal btn_order_normal.9.png Pressed _pressed btn_order_pressed.9.png Focused _focused btn_order_focused.9.png Disabled _disabled btn_order_disabled.9.png Selected _selected btn_order_selected.9.png layout命名 一般类型放前面 逻辑放后面 Component Class Name Layout Name Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml AdapterView item — item_person.xml Partial layout — partial_stats_bar.xml values文件的命名 应该都是复数的 例如 strings.xml, styles.xml, colors.xml, dimens.xml, attrs.xml String常量命名列举Android中常用到的String常量命名 带的前缀 Element Field Name Prefix SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ // Note the value of the field is the same as the name to avoid duplication issuesstatic final String PREF_EMAIL = \"PREF_EMAIL\";static final String BUNDLE_AGE = \"BUNDLE_AGE\";static final String ARGUMENT_USER_ID = \"ARGUMENT_USER_ID\";// Intent-related items use full package name as valuestatic final String EXTRA_SURNAME = \"com.myapp.extras.EXTRA_SURNAME\";static final String ACTION_OPEN_USER = \"com.myapp.action.ACTION_OPEN_USER\"; callback参数的位置callback一般作为最后的参数加入 // Context always goes firstpublic User loadUser(Context context, int userId);// Callbacks always go lastpublic void loadUserAsync(Context context, int userId, UserCallback callback); 使用静态方法跳转Activity和fragment例如在Activity中使用以下方法快速构建intent public static Intent getStartIntent(Context context, User user) &#123; Intent intent = new Intent(context, ThisActivity.class); intent.putParcelableExtra(EXTRA_USER, user); return intent;&#125; 使用fragment时使用单例 public static UserFragment newInstance(User user) &#123; UserFragment fragment = new UserFragment; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); fragment.setArguments(args) return fragment;&#125; 注意上述方法应该放在onCreate方法前面 EXTRA变量和argument设置成private就行了 无需公开 表达式的长度一般一行不超过100个字符 如果超过可以考虑以下的分割策略 使用符号分割 int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 使用builder调用链时 使用. 分割 Picasso.with(context) .load(\"http://ribot.co.uk/images/sexyjoe.jpg\") .into(imageView); 一些太长的方法参数 使用,分割 loadPicture(context, \"http://ribot.co.uk/images/sexyjoe.jpg\", mImageViewProfilePicture, clickListener, \"Title of the picture\"); xml风格规则使用自关闭tag如果只有一个元素没有内容 使用自关闭tag &lt;TextView android:id=\"@+id/text_view_profile\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; xml资源中的id命名一般使用类型作为前缀 下滑线分隔符 Element Prefix TextView text_ ImageView image_ Button button_ Menu menu_ 像这种 &lt;ImageView android:id=\"@+id/image_profile\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; xml资源中Strings的命名一般先考虑以下前缀 后面再加相应逻辑 Prefix Description error_ An error message msg_ A regular information message title_ A title, i.e. a dialog title action_ An action such as “Save” or “Create” 上述观点参考文章Project guidelines 以上有关命名的同一规律：what_where_description 或者 what_where_description_size 参考文章A SUCCESSFUL XML NAMING CONVENTION","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"翻译","slug":"翻译","permalink":"http://luyaoming.com/tags/翻译/"}]},{"title":"鸟哥的Linux私房菜基础学习篇-读书笔记（一）","date":"2016-10-31T05:13:01.000Z","path":"2016/10/31/鸟哥的Linux私房菜基础学习篇-读书笔记（一）/","text":"Linux的规划与安装 鸟哥的Linux私房菜基础学习篇 作者： 鸟哥– –读书笔记 by asii Linux的规划与安装计算机概论计算机主要有5大单元组成：输入单元 输出单元 cpu内部的控制单元和算术逻辑单元 内存 cpucpu的种类分两种：精简指令集（RISC） 复杂指令集（CISC） 精简指令集包含如ARM架构的cpu 用于手机 pda 导航设备 还有ps3的cell处理器等 复杂指令集包含如AMD和Intel的x86架构的cpu 用于个人计算机 后来cpu的位数升到64位 于是新的cpu统称为x86_64架构cpu 计算机的运作流程可以用人体去理解 如cpu=人脑 内存=人脑中的记录区域 接口设备=手脚 显卡=影像 电源=心脏 主板=神经系统 主板上面最重要的就是芯片组了 分南桥和北桥 北桥负责连接速度较快的cpu 内存 显卡等组件 南桥负责连接速度较慢的周边接口如硬盘 显示器 usb等 AMD与intel的不同在于内存是直接与cpu通讯而不通过北桥 AMD为了加速这两者的通讯 将内存控制组件集成到cpu当中 频率是cpu每秒钟进行的工作次数 如3.0GHZ表示cpu一秒钟进行3x10^9次工作 但是不同指令集的cpu不能只比较频率 只能比较同款的cpu速度 频率=外频x倍频 外频是指cpu与外部组件进行数据传输运算的速度 倍频是cpu内部用来加速工作性能的一个倍数 倍频一般是厂家规定死的 超频一般超外频 内存与北桥的频宽（每秒钟可以传输的数据量）=外频x总线宽度（32/64位） 总线宽度通常为cpu每次能够处理的数据量的字组大小 内存我们平时用到的内存条就是DRAM动态随机访问内存 内存容量很重要 因为所有的数据都要加载到内存当中才会被cpu读取 如果内存不够大会导致大容量数据无法被完整加载 此时已存在内存中但暂时没有使用到的数据必须先要释放 使得可用内存容量大于该数据 那份新数据才能被加载 双通道设计是用来提升内存的数据宽度 例如一条内存64位 那么两条一样内存使用双通道可以达到128位 cpu与内存的外频一致可以提升性能","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/categories/Linux/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://luyaoming.com/tags/Linux/"}]},{"title":"新主题maupassant","date":"2016-10-24T10:21:34.000Z","path":"2016/10/24/新主题maupassant/","text":"主题安装安装主题和渲染器： $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-sass --save 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant。 注：若npm install hexo-renderer-sass安装时报错，可能是国内网络问题，请尝试使用代理或者切换至淘宝NPM镜像安装，感谢光头强提供的方法。 功能配置默认配置: _config.yml_config.ymlfancybox: true ## If you want to use fancybox please set the value to true.duoshuo: ## Your duoshuo_shortname, e.g. usernamedisqus: ## Your disqus_shortname, e.g. usernamegoogle_search: true ## Use Google search, true/false.baidu_search: ## Use Baidu search, true/false.swiftype: ## Your swiftype_key, e.g. m7b11ZrsT8Me7gzApciTtinysou: ## Your tinysou_key, e.g. 4ac092ad8d749fdc6293self_search: ## Use a jQuery-based local search engine, true/false.google_analytics: ## Your Google Analytics tracking id, e.g. UA-42425684-2baidu_analytics: ## Your Baidu Analytics tracking id, e.g. 8006843039519956000show_category_count: false ## If you want to show the count of categories in the sidebar widget please set the value to true.shareto: true ## If you want to use the share button please set the value to true.busuanzi: true ## If you want to use Busuanzi page views please set the value to true.widgets_on_small_screens: false ## Set to true to enable widgets on small screens.menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: rss directory: atom.xml icon: fa-rsswidgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links. - search - category - tag - recent_posts - recent_comments - linkslinks: - title: site-name1 url: http://www.example1.com/ - title: site-name2 url: http://www.example2.com/ - title: site-name3 url: http://www.example3.com/ timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More # Static filesjs: jscss: css# Theme versionversion: 0.0.0 fancybox - 是否启用Fancybox图片灯箱效果 duoshuo - 多说评论 shortname disqus - Disqus评论 shortname google_search - 默认使用Google搜索引擎 baidu_search - 若想使用百度搜索，将其设定为true。 swiftype - Swiftype 站内搜索key tinysou - 微搜索 key self_search - 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用。 google_analytics - Google Analytics 跟踪ID baidu_analytics - 百度统计 跟踪ID show_category_count - 是否显示侧边栏分类数目 shareto - 是否使用分享按鈕 busuanzi - 是否使用不蒜子页面访问计数 widgets_on_small_screens - 是否在移动设备屏幕底部显示侧边栏 menu - 自定义页面及菜单，依照已有格式填写。填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。 widgets - 选择和排列希望使用的侧边栏小工具。 links - 友情链接，请依照格式填写。 timeline - 网站历史时间线，在页面front-matter中设置layout: timeline可显示。 Static files - 静态文件存储路径，方便设置CDN缓存。 Theme version - 主题版本，便于静态文件更新后刷新CDN缓存。 主题特性网站图标若要设置网站Favicon，可以将favicon.ico放在Hexo根目录的source文件夹下，建议的大小：32px*32px。 若要为网站添加苹果设备图标，请将命名为apple-touch-icon.png的图片放在同样的位置，建议的大小：114px*114px。 文章摘要首页默认显示文章摘要而非全文，可以在文章的front-matter中填写一项description:来设置你想显示的摘要，或者直接在文章内容中插入``以隐藏后面的内容。若两者都未设置，则自动截取文章第一段作为摘要。 添加页面在source目录下建立相应名称的文件夹，然后在文件夹中建立index.md文件，并在index.md的front-matter中设置layout为layout: page。若需要单栏页面，就将layout设置为 layout: single-column。 文章目录在文章的front-matter中添加toc: true即可让该篇文章显示目录。 文章评论文章和页面的评论功能可以通过在front-matter中设置comments: true或comments: false来进行开启或关闭（默认开启）。 语法高亮要启用代码高亮，请在Hexo目录的_config.yml中将highlight选项按照如下设置： highlight: enable: true auto_detect: true line_number: true tab_replace: 数学公式要启用数学公式支持，请在Hexo目录的_config.yml中添加： mathjax: true 并在相应文章的front-matter中添加mathjax: true，例如： title: Test Mathdate: 2016-04-05 14:16:00categories: mathmathjax: true--- 数学公式的默认定界符是$$...$$和\\\\[...\\\\]（对于块级公式），以及$...$和\\\\(...\\\\)（对于行内公式）。 但是，如果你的文章内容中经常出现美元符号“$”, 或者说你想将“$”用作美元符号而非行内公式的定界符，请在Hexo目录的_config.yml中添加： mathjax2: true 而不是mathjax: true。 相应地，在需要使用数学公式的文章的front-matter中也添加mathjax2: true。 示例。 支持语言目前支持简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语（ko）和西班牙语（es-ES），欢迎翻译至其它语言。 问题解决 检查一下终端当前的目录是否为Hexo的根目录，并包含source/和themes/。 使用过程中遇到问题欢迎提交issue。 此博客主题fork自屠夫","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://luyaoming.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://luyaoming.com/tags/hexo/"},{"name":"主题","slug":"主题","permalink":"http://luyaoming.com/tags/主题/"}]},{"title":"android优化总结","date":"2016-10-14T07:34:47.000Z","path":"2016/10/14/android优化总结/","text":"主要从UI 内存 代码 电量 等几个方面介绍Android优化 题外：从这篇文章起 使用了新的编辑工具typora代替以前的mou来编辑markdown文件了 所有文字样式上会跟之前的文章不一样 Android优化总结UI优化做ui优化首先要明白ui中的一些原理 Android系统每隔16ms发出VSYNC信号 触发对ui进行渲染 refresh rate 刷新率 代表屏幕在一秒内刷新的次数 取决于硬件的固定参数 如60HZ frame rate 帧率 代表GPU在一秒内绘制操作的帧数 如60fps 刷新率和帧率一起协作 当他们并不总能保持相同的节奏 当不一致时容易发生断裂现象或卡顿现象 当帧率&gt;刷新频率时出现断裂 当帧率&lt;刷新频率时表现为卡顿 定为60fps是有原因的 是因为人眼和大脑无法感知超过60fps的画面刷新 为了app流畅 需要在每一帧16ms内处理完所有的cpu和gpu计算 绘制和渲染操作 图像渲染时会用到双重和三重缓存机制 双重：gpu在绘制第一帧时同时缓存第二帧 这样充分利用了16ms的时间 overdraw过度绘制指屏幕上的某个像素在同一帧的时间内被绘制了多次 会耗费大量的gpu和cpu资源 在2.3以下的系统 bitmap像素是存储在Native内存 bitmap对象存储在java堆中 回收时需要回收这两部分空间的内存 先用recycle()释放native中bitmap的像素数据 再对bitmap对象设置为null好保证gc对他回收 3.0以上的系统无需主动recycle 因为bitmap像素存在heap 只需要置空就可以回收 针对ui可以做什么优化呢？ 手机设置里有个开发者选项 打开show gpu overdraw 可以查看overdraw的情况 为下面改写xml做准备 例如移除必须的背景图片 开发者选项里 打开profile gpu rendering 通过垂直的柱状图来观察每帧画面的渲染情况 柱状图越高绘制时间越长 使用hierarchyViewer来查看布局 使布局尽量扁平化 移除必须的ui组件 减少measure和layout的时间 避免绘制那些完全不可见的组件来尽量减少overdraw 使用traceview工具来查看某个页面的方法的cpu使用情况 可以在代码里加startMethodTraceing和stopMethodTraceing来控制 也可以在ddms点击按钮控制 使用lint工具 Android studio自带 点击工具类的analysis -&gt; inspect code 透明度会影响view的渲染 通过setLayerType可以指定view如何渲染 override view的方法hasOverLappingRendering设置为为false可以避免为为这种view占用额外gpu资源从而提升性能 使用strict mode 通过开发者选项打开 有隐患的地方会出现红色 也可以在api上做细节跟踪 对于canvas方面 仅在view改变时才去触发invalidate 尽量使用clipRect提高绘制性能 使用Canvas.quickReject剔除不在屏幕的元素 图片细节 Android提供了4种图片解码方式 可通过BitmapFactory.Options()来设置 针对大图和小图可以使用不同的编码 inSampleSize可以等比缩放图片 inJustDecodeBound可以不把图片加载到内存获取图片的大小 webp是google提供的既有png优点又比png格式小的图片格式 下载和使用参考这里 webp inBitmap属性可以告知bitmap解码器尝试去使用已经存在的内存区域 使用inBitmap属性是有要求的 新申请的bitmap大小必须小于或等于刚刚赋值过的bitmap大小 并且图片的尺寸也必须一样 拥有相同的编码格式 这样对象才能被重用 我们可以创建一个包含多种典型可重用bitmap的对象池 这样后续的bitmap都可以找到合适的模板去重用 在不配置Options的情况下 decodeFile decodeStream在解析时不会对Bitmap进行一系列的屏幕适配 解析的是原始大小的图 而decodeResource在解析时会对bitmap根据当时屏幕像素密度进行缩放适配操作 最后bitmap的大小比原始的大 px = dp * density 关于bitmap的一些优化 配置BitmapConfig 使用decodeFile、decodeResource、decodeStream进行解析Bitmap时 配置inDensity和inTargetDensity 两者应该相等 值可以等于屏幕像素密度*0.75f 使用inJustDecodeBounds预判断Bitmap的大小及使用inSampleSize进行压缩 使用vectorDrawable代替png和jpg可以有效减少资源大小而且不需要适配屏幕 但是5.0以上才支持 vectorDrawable而且还支持属性动画 使用AnimatedVectorDrawable 关于布局优化 如果已经不想制作多个values文件适配Android屏幕分辨率 可以使用百分比布局 android-percent-support-lib-sample ​ ​ 内存优化尽管jvm与Android的dalvik虚拟机有所不同 但是关于gc机制大体一致 堆内存的划分为新生代 老生代和持久代 新生代是频繁执行的 每次gc后存活的对象会移动到Survivor的to space 内存不足的根据担保机制提前移动到老生代 老生代也会gc但是频率比新生代的低很多 更多内存原理可以回头看我的另一篇文章深入理解java虚拟机-读书笔记（一） 如何观察页面内存的泄漏问题呢 一种方法是启动一个空白页面 跳转到被观察页面 再跳到一个空白页面 保存内存快照 dump到本地使用mat或者ddms工具打开 查找那些没被释放的可疑对象 另一种方式是直接加入Android第三方开源的leakscanary依赖 当有内存泄漏发生时会在一个app显示他的gc路径 内存抖动 因短时间内大量的对象被创建又马上释放而产生 瞬间产生的对象会严重占用新生代的内存区域 当到达阀值时 剩余空间不够的时候会触发gc从而导致刚产生的对象又很快被回收 即使每次分配的对象占用了很少内存 但是他们叠加在一起会增加堆得压力 从而导致其他类型的gc 这个操作有可能影响到帧率并使用户感知到性能问题 可通过内存检测器查看短时间内发生的多次内存涨跌 从而去修复问题 例如避免在for循环内分配对象 避免在view的ondraw执行复杂的操作 避免创建对象 针对必须创建对象的情况可以考虑对象池模型 使用完后记得释放 通过命令行可以查看应用的内存使用情况 adb shell dumpsys meminfo -a com.example.android.activityLifeCircle 有关内存泄漏 是指当一个对象已经不再使用了 本该被回收 而另外一个正在使用的对象持有他的引用从而导致他不能被回收 停留在堆内存中 这就产生了内存泄漏 列举发生的例子 如 在单例模式时构造函数引入Activity的Context 当Activity退出时 由于单例引用这这个context导致这个context不能被正常回收即Activity不能被回收 除此之外还有非静态内部类引起的内存泄漏 handler引起的内存泄漏 资源在Activity退出时未关闭引起的内存泄漏 关于内存优化的主要策略为 首先是减小对象的内存占用 其次是内存对象的重复利用 然后是避免对象的内存泄露 最后是内存使用策略优化 Android系统会在内存紧张的时候收到onLowMemory函数和onTrimMemory的函数回调 可以根据传递的参数判断 合理地选择释放一些内存 好保证系统的流畅度 代码优化在Android中 无论在编写xml还是java代码都有一些使用技巧和注意事项 列出下面 在集合方面 Android自身有提供了sparseArray和ArrayMap来取代那些key为int类型的hashmap 在千个数据以内的都可以使用这些集合代替hashmap 对于枚举 Android官方是尽量避免使用的 因为枚举经常使用的内存是静态常量的2倍 使用randomAssess接口的集合类时用fori循环要比foreach循环快 foreach内部是使用iterator来实现的 requestlayout会导致该layout的父节点都会进行layout 所以尽量避免直接调用 一个复杂的布局了 某一个view起了变化都有可能引起其他view重新layout 使用mainActivity+splashFragment的方式代替单纯的splashActivity 使用getWindow().getDecorView().post的方式来进行延迟加载 对比一般的view.post是前一种方式发生在所有view加载完成后 可以在onResume方法中调用 在编写xml布局文件时 使用style代替一些硬编码 在视图有变化的viewGroup中 使用android:animateLayoutChanges=true 可以使动画平滑过度 listview或者gridview为空内柔时可以设置默认视图 mlistview.setEmptyView(view); 电量优化这个优化往往会排到最后来做但是依然重要 无线电波状态机有三种能量状态 full power（无线连接被激活 允许设备以最大的传输速率进行）low power（中间状态 电量消耗是full power的一半）standby（最小能量状态 没有激活或者没有网络连接） 能量状态转换需要耗费时间 如下图 如何查看电量消耗图呢 可使用Android5.0新引入的api：battery historian 参考胡凯的Android性能优化之电量篇 观察网络唤醒和等待时的电量变化 一台Android设备平均只要30%的电量用来绘制图片摆放布局等操作 剩下70%的电量是用来上报数据 检查位置信息 定时检索后台广告等 对比起来网络访问更加消耗电量 以下操作可以减少电量的消耗 尽量减少唤醒屏幕的次数和持续的时间 使用wakelock来处理唤醒的问题 某些非必须马上执行的操作例如上传歌曲 图片处理等可以等到设备处于充电状态或电量充足的时候才进行 触发网络请求的操作 每次都会保持无线信号保持一段时间 可以把零散的网络请求打包后进行一次操作 避免过多的无线醒后引起的电量消耗 关于网络延迟再批量处理 Android官方提供jobScheduler的api来达成 预取数据 批量处理 减少连接这三种方法是优化电量的网络连接方式 具体参考文章优化下载以高效地访问网络 除此之外 还可以压缩上传或者下载的网络数据来减少网络传输时间 从而导致减少电量使用的目的 观看网络请求发生的时间可以使用Android studio的networking traffic tool来查看 轮询数据访问时最耗费电量的 所以严重不建议这么做 可以使用回退机制来避免固定频率的同步请求 例如在发现返回数据相同的情况下 推迟下次的请求时间 其他优化gradle的配置减少程序安装包大小 在build.gradle文件中配置 buildTypes的minifyEnabled为true minifyEnabled为true同时起到代码混淆的作用 关于proguard的用法可以参考郭霖的文章 shrinkResource为true 可以帮助移除程序使用不到的代码和资源","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"优化","slug":"优化","permalink":"http://luyaoming.com/tags/优化/"}]},{"title":"深入理解java虚拟机-读书笔记（三）","date":"2016-09-07T06:52:36.000Z","path":"2016/09/07/深入理解java虚拟机-读书笔记（三）/","text":"主要介绍java的内存模型和线程调度 深入理解java虚拟机 作者： 周志明– –读书笔记 by asii java内存模型与线程硬件中的java内存模型运算任务是通过处理器的计算 与内存的读取和吸入数据 一起完成的 但是在真实硬件中 储存设备与处理器之间的速度之前有很大的差别 所以需要加入一个高速缓存cache作为内存与处理器之间的缓冲 高速缓冲的作用是 将运算需要用到的数据从主内存复制到缓存中 让运算能快速进行 当运算结束后再从缓存同步到内存中 这样处理器就无需等待缓慢的内存读写了 在多处理器系统中 每个处理器都有自己的高速缓存而且他们共享一个主内存 在读写过程中将可能导致各自的缓存数据不一致 当同步回到主内存时以谁的缓存数据为准？ ‘缓存一致性协议’就是为了解决这个问题而存在的 这类协议有 MSI MESI MOSI Synapse等 乱序执行为了处理器内存的运算单元能尽量充分利用 处理器可能会对输入代码进行乱序执行优化 out of order execution 处理器会在计算后将乱序执行的结果重组 保证该结果与顺序执行的结果一致 但不保证程序中各个语句计算的先后顺序与输入代码的顺序一致 因此如果存在一个计算任务依赖另外一个计算任务的中间结果 那么顺序性并不能靠代码的先后顺序来保证 java虚拟机的即时编译也有类似的指令重排序 Instruction Recorder 软件中的java内存模型与硬件中的java内存模型有类比性 每条线程还有自己的工作内存 线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝 线程对变量的所有操作都必须在工作内存中进行 而不能直接读写主内存中的变量 不同线程之间不能相互访问对方工作内存中的变量 线程间的变量值传递均需要通过主内存来完成 内存模型中还定义了8中交互操作 分别是lock unlock read load use assign store write 根据字面理解 主要是工作内存和主内存之间的交互 volatilevolatile关键字是java虚拟机提供的最轻量级的同步机制 他有两个特性 第一 保证此变量都所有线程的可见性 如何理解？ 当一条线程修改了这个变量的值 新值对于其他线程来说是立即得知的 普通变量不能做到这点 因为线程间的变量传递需要通过主内存来完成 例如 线程1修改了一个普通变量的值 然后向主内存进行回写 另外线程2必须要在线程1完成回写之后再从主内存读取才能读到修改后的值 否则是未修改的值 注意在使用volatile时在对该变量写操作时不适合依赖于变量本身如i++相当于i=i+1这种依赖于本身的写操作 所以不具备操作的原子性 第二个特性是 禁止指令重排序 可以保证变量的赋值顺序与程序代码的执行顺序一致 volatile的性能比synchronized关键字和concurrent里面的锁性能要高 总开销低 除long和double类型的变量外 那8个内存交互操作都具有原子性 java内存模型具有 原子性 可见性和有序性三个特性 有关原子性操作 java还提供如AutomicInteger AutomicLong等类型来进行原子性操作 在多线程并发操作同一资源 使用lock-free算法来代替锁 开销更小速度更快 所谓原子性操作可以举例i++原来分三步 原子性操作作为一步仅限单一线程修改 线程调度协同式调度 线程的执行时间由本身来控制 线程自己的工作执行完了之后 要主动通知系统切换到另外一个线程上去抢占式调度 执行时间不由自己控制 又系统来控制执行时间 不会有由于一个线程阻塞而导致整个进行阻塞的问题 线程的状态插图来源于网络 调用thread的isAlived 只有在新建和死亡这两种状态下才会为false 其他都是true 不能对已经在死亡状态的线程调用start方法 关于线程的join方法的例子 a线程在执行 b线程在a线程里调用join()方法时 a线程会进入阻塞状态 b线程执行完成后 a线程进入就绪状态参与资源竞争 调用yield会让线程进入就绪状态 与sleep不一样 sleep进入的是阻塞状态 yield是让步的意思 有可能线程调用yield后 又马上获得了处理器资源进入运行状态 在执行同步代码时 监视器（被同步的对象）调用wait方法才会释放同步锁 在当前线程调用sleep或者yield都不会释放同步锁 BlockingQueue是控制线程同步的集合 他继承Queue 通过put放元素 take取元素 放元素时如果队列已满则堵塞线程 取元素时如果队列为空则堵塞线程 使用BlockingQueue可以应用在一放一取交替进行的线程","categories":[{"name":"JVM","slug":"JVM","permalink":"http://luyaoming.com/categories/JVM/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"java","slug":"java","permalink":"http://luyaoming.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://luyaoming.com/tags/jvm/"}]},{"title":"深入理解java虚拟机-读书笔记（二）","date":"2016-08-28T06:04:09.000Z","path":"2016/08/28/深入理解java虚拟机-读书笔记（二）/","text":"主要介绍jvm的类加载机制 深入理解java虚拟机 作者： 周志明– –读书笔记 by asii 虚拟机类加载机制类加载的时机类从被加载到虚拟机内存开始 到卸载出内存为止 经历的生命周期如下：加载 验证 准备解析 初始化 使用 卸载七个阶段 其中验证准备 解析统称为连接 除了解析这个步骤 其他都是按步骤依次执行的 因为java有运行时绑定 可以在初始化后再解析 加载 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储数据结构转化为方法区的运行时数据结构 在java堆中生成一个代表这个类的Class对象作为方法区这些数据的访问入口 验证 是连接阶段的第一步 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求并且不会危害虚拟机自身的安全 这一阶段包含文件格式验证 元数据验证 字节码验证 符号引用验证 准备 正式为类变量分配内存并设置类变量初始值的阶段 这些内存都将在方法区中进行分配 解析 虚拟机将常量池内的符号引用替换成直接引用的过程 初始化 真正开始执行开始执行类中定义的java程序代码 是执行类构造器方法的过程 类加载器对于任意一个类 都需要由加载他的类加载器和这个类本身一同确定其在java虚拟机的唯一性 即使两个类来源于同一个class文件 只要加载他们的类加载器不同 那这两个类必定不相等 双亲委派模型有三种系统提供的类加载器 启动类加载器 BootStrap ClassLoader 将JAVA_HOME\\lib下面的类库加载到虚拟机内存中 无法被java程序直接引用 扩展类加载器 Extension ClassLoader 将JAVA_HOME\\lib\\ext下面的类库加载到虚拟机内存中 可以被java程序直接引用 应用程序类加载器 Application ClassLoader 使用getSystemClassLoader的返回值也称为系统类加载器 将用户类路径下的类库加载到内存中 若用户没有指定自己的类加载器 他就是默认的 类加载器双亲委派模型如下图双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求 他首先不会自己去尝试加载这个类 而是把这个请求委派给父类加载器去完成 每一个层次的类加载器都是如此 因此所有的加载请求最终都会传送到顶层的启动类加载器中 只有父类加载器反馈自己无法完成这个加载请求时 子加载器才会尝试自己去加载 这个模型的好处是java类随着类加载器拥有优先级的层次关系 例如自己写一个Object类放在rt.jar包并放在ClassPath中 虚拟机加载时时会从父类加载器中找 找到了就会无视自己写的那个Object类 但是此类依然可以通过编译 只不过不会被加载运行","categories":[{"name":"JVM","slug":"JVM","permalink":"http://luyaoming.com/categories/JVM/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"java","slug":"java","permalink":"http://luyaoming.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://luyaoming.com/tags/jvm/"}]},{"title":"深入理解rxjava","date":"2016-08-25T15:25:25.000Z","path":"2016/08/25/深入理解rxjava/","text":"深入分析下rxjava在源码中的运行过程 深入理解rxjava先感谢两位前辈的文章指导 下面贴图和代码部分来源于他们 http://gank.io/post/560e15be2dca930e00da1083 –抛物线 http://android.walfud.com/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-rxjava-%E4%B8%AD%E7%BA%A7%E7%AF%87/ –walfud 本文通过自己阅读rxjava源码的理解 结合前辈的文章对rxjava的运作流程做一个分析 什么是subscriberSubscriber是特殊的Observer 除了自带的三个方法onNext onComplete onError之外还带有onStart和onUnSubscribe 其中onStart方法是执行在所订阅线程的线程上而不是主线程 所以不能随便放ui操作 关于just from的疑惑使用Observable.just或者Observable.from(数组或集合) 创建的Observable对象 其默认的onSubscribe对象是OnSubscribeFromIterable 其中call方法为 @Overridepublic void call(final Subscriber&lt;? super T&gt; o) {final Iterator&lt;? extends T&gt; it = is.iterator();if (!it.hasNext() &amp;&amp; !o.isUnsubscribed()) o.onCompleted();else o.setProducer(new IterableProducer&lt;T&gt;(o, it));&#125; setProducer会调用request方法 来源于IterableProducer的request方法 最后request方法会调用fastpath方法如下 void fastpath() &#123;// fast-path without backpressurefinal Subscriber&lt;? super T&gt; o = this.o;final Iterator&lt;? extends T&gt; it = this.it;while (true) &#123; if (o.isUnsubscribed()) &#123; return; &#125; else if (it.hasNext()) &#123; o.onNext(it.next()); &#125; else if (!o.isUnsubscribed()) &#123; o.onCompleted(); return; &#125; else &#123; // is unsubscribed return; &#125; &#125;&#125; 现实中可以自定义这些onNext onCompleted的执行顺序 即不使用from或者just接收数组或集合的方法来构建Observable 例如如下 传入自定义的onSubscribe对象Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;@Overridepublic void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted();&#125;&#125;); rxjava是如何运作的真正使用中 Observable可能会发生很多操作如map flatMap等变换操作 最后调用subscribe方法完成整个回调链 在未调用subscribe方法之前 表明未有观察者订阅被观察者所以所有的变换等操作不会执行 但是这些操作都在计划表里 只有等subscribe方法调用时 才真正开始执行 查看subscribe方法的代码 subscribe有多个重载的方法 当最终会调用下面私有方法private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {主要的运行语句是subscriber.onStart();hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);return hook.onSubscribeReturn(subscriber);上面的语句是先运行传进来的subscriber的onStart方法 再运行onSubscribe对象的call方法 此onSubscribe对象在构建Observable时例如create 构造函数 from等方法传入 而flatMap map等方法的function操作什么时候开始执行呢 下面先看map的代码操作public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return lift(new OperatorMap&lt;T, R&gt;(func));&#125; 再看lift的代码部分public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) &#123; return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber&lt;? super R&gt; o) &#123; try &#123; Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o); try &#123; // new Subscriber created and being subscribed with so 'onStart' it st.onStart(); onSubscribe.call(st); &#125; catch (Throwable e) &#123; // localized capture of errors rather than it skipping all operators // and ending up in the try/catch of the subscribe method which then // prevents onErrorResumeNext and other similar approaches to error handling Exceptions.throwIfFatal(e); st.onError(e); &#125; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // if the lift function failed all we can do is pass the error to the final Subscriber // as we don't have the operator available to us o.onError(e); &#125; &#125;&#125;);&#125; 这些转换操作返回了新的Observable对象 然后再创建新的onSubscribe对象 在call方法里又通过OperaterMap（此对象来自于一开始调用的map方法）创建新的Subscriber对象 如下代码 @Overridepublic Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) &#123;return new Subscriber&lt;T&gt;(o) &#123; @Override public void onCompleted() &#123; o.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; o.onError(e); &#125; @Override public void onNext(T t) &#123; try &#123; o.onNext(transformer.call(t)); &#125; catch (Throwable e) &#123; Exceptions.throwOrReport(e, this, t); &#125; &#125;&#125;;&#125; 此步骤就是将最终目标的subscriber对象封装到一个新的subscriber对象中 接着讲解lift方法中的onSubscribe.call(st) st为上一步创建的新subscriber对象 传入到父onSubscribe对象中 这里说父onSubscribe对象是因为有可能多个变换操作 该onSubscribe对象由下往上传递 最终传递到Observable通过create函数中创建的onSubscribe对象中并执行call方法（一般会执行onNext onComplete等操作） 进行到这一步 真正的回调才开始执行 由该onNext开始 调用封装后的Subscriber对象的onNext方法 执行代码o.onNext(transfromer.call(t)); 会先调用这一层进行的变换 再调用onNext方法 再玩下调用下一层的变换 再调用onNext方法 以此类推 最终最终才调用最后的subscriber对象的onNext方法 抽象流程图如下代码流程图如下","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"rxjava","slug":"rxjava","permalink":"http://luyaoming.com/tags/rxjava/"}]},{"title":"深入理解java虚拟机-读书笔记（一）","date":"2016-08-20T13:19:30.000Z","path":"2016/08/20/深入理解java虚拟机-读书笔记（一）/","text":"主要介绍java的内存区域和内存溢出异常 垃圾收集器和内存分配策略 深入理解java虚拟机 作者： 周志明– –读书笔记 by asii java内存区域与内存溢出异常运行时区域运行时数据区域如下图 下面逐个分析 程序计数器可以看做是当前线程所执行的字节码的行号指示器 每条线程都需要独立的程序计数器 线程之间的计数器互不影响 这个是线程私有的内存 此区域是唯一不会outOfMemoryError情况的区域 java虚拟机栈线程私有 生命周期与线程相同 描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表 操作数栈 动态链接 方法出口等信息 局部变量表存放编译期可知的基本数据类型 对象引用 返回地址类型 当线程请求的栈深度大于虚拟机所允许的栈深度会抛出StackOverflowError异常 如果虚拟机栈可以动态扩展 但是当扩展时无法申请到足够的内存时会抛出outOfMemoryError异常 本地方法栈与虚拟机栈发挥的作用类似 区别在虚拟机栈为虚拟机执行java方法（字节码）的服务 而本地方法栈则是Native方法服务 java堆所有线程共享此区域 存放的都是对象实例 从内存回收角度看 收集器基本采用分代收集算法 所以java堆可以细分为 新生代老生代 再细致的是Eden空间 fromSurvivor空间和toSurvivor空间 java堆在物理上是不连续的内存空间但逻辑上是连续的 如果堆没有内存完成实例分配并且堆无法再扩展时会抛出outOfmemoryError 方法区所有线程共享此区域 存储已被虚拟机加载的类信息 常量 静态变量 即时编译编译后的代码等数据 别名Non-Heap 这个区域的回收目标是针对常量池的收回和类型的卸载但总是难以令人满意 当方法区无法满足内存分配需求时抛出 OutOfMemoryError 运行时常量池是方法区的一部分 Class文件中除了有类的版本 字段 方法 接口等描述信息外 还有常量池 用于存放编译期生成的各种字面量和符号引用 这部分内容将在类加载后存放到方法区的运行时常量池中 这个区域也会抛outOfMemoryError 对象访问从Object obj = new Object();这句代码包含三个内存区域的访问 其中“Object obj”反映到java栈帧的本地变量表中 作为一个reference类型数据出现 “new Object()”这部分反映到java堆中 存储了Object类型所有实例数据值 同时方法区中包含能查找到此对象类型数据（如对象类型 父类 实现的接口 方法等）的地址信息 虚拟机有两种方式去访问java堆中对象的具体位置 1 句柄池 存储对象的句柄地址（包含对象实例数据和类型数据的地址信息）2 直接指针地址访问方式 OutOfMemoryError异常当出现OutOfMemoryError异常时应该怎么做？首先需要根据异常信息判断内存溢出的区域 然后需要知道怎样的代码会导致这个区域的内存溢出 最后如果该异常还是出现该如何处理 要知道在java运行时内存中 只有使用程序计数器不会报此异常 可以使用Eclipse的MAT工具 或者Android的leaksCanary包跟踪到内存溢出的位置 同时还可以观察那些对象会出现内存泄漏 要注意通过不断建立新线程的方式造成的内存泄漏跟栈空间分配的内存有关 原因是操作系统分配个每个进程的内存有限制的 总容量减去最大堆容量 减去最大方法区容量 程序计数器内存容量很少可以忽略 剩下的就是虚拟机栈和本地方法栈 所以每个线程分配到的栈空间越大 可以建立的线程数量自然越少 如果建立过多的线程导致内存泄漏 在不能减少线程数或者更换64位虚拟机的情况下 只能通过减少最大堆和减少栈容量来换取更多的线程 java.lang.outOfMemoryError：permGen space 方法区引起的内存泄漏java.lang.outOfMemoryError：java heap space 堆内存引起的内存泄漏 垃圾收集器和内存分配策略怎样描述一个对象已经“死去”而被垃圾回收器回收呢 引用计数算法可以描述一个对象的进行引用时计数器加一 引用失效时减一 当引用计数为0时证明对象已经“死去”？然而这并不是真正的判断方式 因为他无法解决对象互相循环引用的问题 java虚拟机也不会因为他们相互引用并且他们都置null了而不去回收他们 引用算法令我想起了《Android系统源代码情景分析》一书中提到的c++的智能指针 使用的真是引用计数技术 智能指针可以使两个互相引用的指针之间存在“父子”关系 只要父指针对子指针存在强引用关系 而子对父存在弱引用关系 弱引用不会影响引用计数 所以当父失去引用置空时 子不会再限制父被回收 在java和c#中 根搜索算法GC Roots Tracing是判断对象是否存活的方法 他的思路是通过一系列名为“GC Roots”的对象作为起始点 从这些节点开始向下搜索 搜索走过的路径称为引用链 当一个对象到GC Roots没有任何引用链时即这个对象不可达时 则证明这个对象是不可用的 当对象不可达时 对象不会立即被垃圾回收器处刑 而是先进行一次标记 然后再进行筛选 筛选的条件是该对象是否有必要执行finalize()方法 当对象没有覆盖此方法或者已经被调用过 则视为没有必要 如果在finalized中 重新与引用链的任何一个对象建立了关联 那么将逃脱被回收的命运 注意一个对象的finalized方法最多只会被系统自动调用一次 以上垃圾回收都是针对java堆 而方法区回收效率就比较低了 它属于永久代 垃圾回收算法 标记-清除算法 首先标记出所有需要回收的对象 在标记完成后统一回收掉所有被标记的对象 复制算法 内存容量划分为大小相等两份 每次只使用其中一份 当这块的内存用完了 再将存活的对象复制到另一块上面 然后再将使用过的那块内存一次清理掉 确使每次只对其中一块进行内存回收 内存分配时不用再考虑内存碎片等复杂情况 这种算法适合每次存活很小对象的情况 标记-整理算法 相比复制算法 此算法适合存活很多对象的情况 先标记 然后让所有存活的对象都向一端移动 清理掉端边以外的内存 分代收集算法 将java堆分为新生代和老年代 根据各个年代的特点采用最适合的收集算法 内存分配和回收策略java堆得各代划分大多数情况下 对象都在新生代Eden区中分配 当Eden没有足够空间时会发起一次Minor GC 存活的对象会移动到Survivor Space 如果Survivor Space没有足够的空间去存放这些对象 会通过分配担保机制提前移动到老年代中 新生代的可用内存空间包括Eden区+From区 剩余to Survivor Space是空闲的用于复制算法 老年代也有GC 叫做Major GC或者Full GC 他的回收速度比Minor GC慢很多 在Full GC之前一般伴随一次Minor GC 对于大对象数据 为了避免在Eden区与两个Survivor区之间发生大量的内存拷贝 可以在虚拟机设置-XX：PretenureSizeThreshould参数设置成大于某个值的大对象数据直接进入老年代 长期存活的对象会进入老年代 实现的原理是虚拟机给每个对象顶一个对象年龄age计数器 如果对象在Eden出生并经过一次Minor GC后依然存活并且能被Survivor容纳的话会被移动到to Survivor空间并将年龄对象设为1 对象在Survivor空间每熬过一次Minor GC年龄就增加1 当他的年龄增加到一定程度就会晋升到老年代 对象晋升老年代的年龄阈值可以通过参数-XX：MaxTenuringThreshold来设置 还有另外一种策略是Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半 年龄大于或等于该年龄的对象就可以直接进入老年代 无需等到MaxTenuringThreshold达到阈值 罗列一些虚拟机可以设置的参数 堆设置 -Xms :初始堆大小 -Xmx :最大堆大小 -XX:NewSize=n :设置年轻代大小 -XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n :年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n :设置持久代大小 收集器设置 -XX:+UseSerialGC :设置串行收集器 -XX:+UseParallelGC :设置并行收集器 -XX:+UseParalledlOldGC :设置并行年老代收集器 -XX:+UseConcMarkSweepGC :设置并发收集器 垃圾回收统计信息 -XX:+PrintHeapAtGC GC的heap详情 -XX:+PrintGCDetails GC详情 -XX:+PrintGCTimeStamps 打印GC时间信息 -XX:+PrintTenuringDistribution 打印年龄信息等 -XX:+HandlePromotionFailure 老年代分配担保（true or false） 并行收集器设置 -XX:ParallelGCThreads=n :设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n :设置并行收集最大暂停时间 -XX:GCTimeRatio=n :设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置 -XX:+CMSIncrementalMode :设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n :设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://luyaoming.com/categories/JVM/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"java","slug":"java","permalink":"http://luyaoming.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://luyaoming.com/tags/jvm/"}]},{"title":"java8函数式编程-读书笔记（一）","date":"2016-07-28T08:33:28.000Z","path":"2016/07/28/java8函数式编程-读书笔记（一）/","text":"java8函数式编程 作者： Richard Warburton 翻译：王群锋– –读书笔记 by asii lambda表达式lambda表达式改写了匿名内部类 如​button.setOnClickListener( new View.onClickListener()&#123; @override public void onClick(View v)&#123; v.setVisible(View.INVISIBLE); &#125; &#125;);//运用lambda表达式后 变成button.setonClickListener(v -&gt; v.setVisible(View.INVISIBLE));//有两个参数的表达式可以写成这样BinaryOperator&lt;long&gt; add = (Long x,Long y) -&gt; x+y;//或者BinaryOperator&lt;long&gt; add = (x,y) -&gt; x+y; 匿名内部类中使用局部变量时 需要把变量声明为final类型或者直接变为成员变量 在使用lambda表达式时 局部变量可以不写final声明 其实是一种非显式的final 但是一样具有final的效果 例如下面使用局部变量name 然后试图修改他的值 在编译时会报错​String name = getUserName();name = formatUserName();button.setonClickListener(v -&gt; v.setText(name)); 函数接口函数接口是只有一个抽象方法的接口 用作lambda表达式的类型 下面是java中重要的函数接口 接口 参数 返回类型Predicate&lt;T&gt; T booleanConsumer&lt;T&gt; T voidFunction&lt;T,R&gt; T RSupplier&lt;T&gt; None TUnaryOperator&lt;T&gt; T TBinaryOperator&lt;T&gt; (T,T) T javac可以根据上下文自动推断出参数的类型 且用户也可以手动声明类型 流java8引入了流stream 对集合类也进行了改进 流stream是用函数式编程方式在集合类上进行复杂操作的工具 //例如 使用迭代器计算来自伦敦艺术家的人数int count = 0;Iterator&lt;Artist&gt; iterator = allArtists.iterator();while(iterator.hasNext())&#123; Artist artist = iterator.next(); if(artist.from(\"london\"))&#123; count++; &#125;&#125;//使用流后long count = allArtist.stream() .filter(artist -&gt; artist.isFrom(\"london\")) .count(); 上面的stream操作方式 注意 在没有调用count前他依然是个steam类型 不会产生新的集合 这是一种惰性求值方法 而count是从stream产生值得方法是及早求值方法 常用的流操作collect(Collectors.toList);这个方法是由stream里的值生成一个列表 是一个及早求值操作 例如List&lt;String&gt; collected = Steam.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).collect(Collectors.tolist()); map 将一个流中的值转换成一个新的流 例如 List&lt;String&gt; collected = Stream.of(\"a\",\"b\",\"c\") .map(string -&gt; string.toUpperCase()) .collect(Collectors.toList()); map操作显然使用的是function函数接口 filter 前面使用过filter了 接受一个predicate来过滤结果 例如 List&lt;String&gt; newMembers = Stream.of(\"a\",\"1b\",\"2c\") .filter(value- &gt;isDigst(value.chatAt(0))) .collect(Collectors.toList()); flatMap 可用stream替换值 然后将多个stream连接成一个stream 常见于多层循环 List&lt;Integer&gt; together = Stream.of(asList(1,2),asList(3,4)).flatMap(number -&gt; numbers.stream()).collect(Collectors.toList()); max和min 求最大值最小值 在collections可以使用sort接受一个比较器进行排序求出最大值最小值 在stream中也有这样的操作 Track shortestTrack = tracks.stream() .min(Compartor.comparing(track -&gt; track.getLength())) .get(); reduce 从一组值中生成一个值 cout max min都是reduce操作 例如实现一个累加器 int count = Stream.of(1,2,3).reduce(0,(acc,element) -&gt; acc+element); reduce方法重载了三次对应1 2 3个参数 注意他们的泛型方法参数类型要对应 追踪reduce函数 他的回调是在AbstractPipeline类的copyInto方法中进行的 这个回调链我找了好久 很深 类库高阶函数 如果函数的参数列表中包含函数接口 或函数返回一个函数接口 那么该函数就是高阶函数 每个用作函数接口的接口都添加了@FunctionalInterface注释 默认方法 在方法前声明default 接口中允许有多个默认方法 这些方法可以写实现方式 java允许多重实现 当同时实现的两个接口中具有相同的默认方法时 编译器会强制用户必须实现自己的方法（重载此默认方法） Optional对象 旨在创建一个代替null的变量 相当于值得容器 可以通过get方法获取里面的值 通过of方法赋值 使用ofNullable判断是否有值 例如 Optional&lt;String&gt; aOp = Optional.of(\"a\");String value = aOp.get();Optional empty = Optional.ofNullable(aOp); 当试图避免空值相关的缺陷 如未捕获的异常时可以考虑一下使用它 高级集合类和收集器这章节主要讲java8对集合类的改进 方法引用artist -&gt; artist.getName()可以换成Artist::getName的写法 标准语法是ClassName::methodName另外new表达式可以写成Artist::new 介绍下Collectors这个类 他有很多静态方法 例如常用的toList toMap toSet返回集合类型的 也有返回值得例如maxBy averageInt 还有将一个流分解成两个不同的集合用如Map&lt;boolean,List&lt;Artist&gt;&gt;储存的方法 partitionBy 有点像sql中的group by操作 还有对字符串的操作 Collectors.joining(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;)三个参数分别代表分隔符 前缀 后缀 组合收集器 如groupingBy可以对stream进行分组 用map来存储 例如albums.collect(Collectors.groupingBy(album -&gt; album.getMainMusician()))按专辑的主唱分组的集合Map&lt;Artist,List&lt;Album&gt;&gt;而如果想继而统计这样分组后的专辑的数量 那么可以写成albums.collect(Collectors.groupingBy(album -&gt; album.getMainMusician(),Collectors.counting()))加了counting来统计数量 java8中map加入了函数接口 例如一个常用的操作是缓存 先试着从map中取值 如果没取到 创建一个新的值并返回cacheList.computeIfAbsent(name,this::readFromDB) 数据并行化从集合中返回流可以采用stream()的写法 但是还有一个parallelStream()的写法是返回一个并行化的流 另外Arrays类也加入了parallelPrefix parallelSort的并行化写法","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"java","slug":"java","permalink":"http://luyaoming.com/tags/java/"},{"name":"函数式","slug":"函数式","permalink":"http://luyaoming.com/tags/函数式/"},{"name":"lambda","slug":"lambda","permalink":"http://luyaoming.com/tags/lambda/"}]},{"title":"深入理解Android卷三-读书笔记（二）","date":"2016-07-06T15:12:14.000Z","path":"2016/07/06/深入理解Android卷三-读书笔记（二）/","text":"主要介绍windowManager viewRootImpl 和 这些组件之间的联系 深入理解Android卷三 作者： 张大伟– –读书笔记 by asii windowManager可以通过Context.getSystemService(Context.WINDOW_SERVICE)的方式来获取一个windowManager的实例 其实质是通过构造一个WindowManagerImpl类的实例返回的 这个实例依赖于display对象 他在wms中表示一个屏幕 在wmi调用addview添加窗口时 实质是通过windowManagerGlobal实例来添加 这个global是进程唯一的 查看windowManagerGlobal添加窗口的代码 如果当前窗口需要被添加为另外一个窗口的附属窗口（子窗口）则需要让父窗口视自己的情况对当前窗口的布局参数layoutParams进行一些修改 创建一个viewRootImpl对象并保存在root变量中 将作为窗口的控件view 布局参数params 以及新建的viewrootImpl以相同的索引值保存在三个数组中 将作为窗口的控件设置给viewrootImpl 这个动作将导致viewrootImpl向wms添加新的窗口 申请surface以及托管控件在surface上的重绘动作 这一步是控件能够作为一个窗口显示在屏幕上的根本原因 如果需要调整布局 可以更新 通过viewrootImpl.setLayoutParams进行更新而删除一个窗口 可以调用 ViewrootImpl.die 可以看出windowManager的新增删除更新窗口 都是通过WindowManagerGlobal的viewRootImpl来实现的 ViewRootImplviewrootImpl实现了viewParent接口 作为整个控件树的根部 他是控件树正常运作的动力所在 控件树的测量 布局 绘制以及输入事件的派发处理都是由viewRootImpl触发分析viewrootImpl的构造函数 从windowManagerGlobal中获取一个IWindowSession的实例 他是ViewRootImpl和wms进行通信的代理 保存参数display 在后面setView调用中将会把窗口添加到这个display上 保存当前线程到mThread 该线程会成为ui线程 传一个MDirty区域 就是数据或者状态发生改变时需要重绘的区域 创建mWinFrame 用来描述窗口的位置和尺寸 创建IWindow.Stub的一个子类W 接受来自wms的回调 创建mAttachInfo 他存储了当前控件树所贴符窗口的各种有用信息 并且会派发给控件树中的每一个控件 创建FallbackEventHandler 是一个处理未经任何人消费的输入事件的场所 创建一个依附于当前线程 即主线程的choreographyer 用于通过VSYNC特性安排重绘行为 下面分析viewrootImpl.setView的过程 用mView保存控件树的根 mWindowAttitudes保存窗口对应的layoutparams requestLayout在添加窗口之前 先通过他来在主线程上安排一次遍历 初始化mInputChanel 如果mInputChanel不为空 则创建mInputEventReceiver 用于接收输入事件 第二步指的遍历实际上执行的就是performTraversals方法 viewrootImpl中接收的各种变化 如来自wms窗口属性变化 来自控件树的尺寸变化以及重绘请求等都会引发performTraversals的调用 View类以及其子类中的onMeasure onLayout以及onDraw等回调都是在performTraversals的执行过程中直接或间接地引发 performTraversals这方法是控件系统的心跳 下面总结他的工作阶段大体分5步 预测量阶段 会计算出控件树为其显示内容所需的尺寸 view的onMeasure方法将会沿着控件树依次被回调 布局窗口阶段 根据预测量的结果 通过IWindowSession.relayout向wms请求调整窗口的尺寸等属性 这将会引发wms对窗口进行重新布局 并将布局结果返回给viewrootImpl 最终测量阶段 要注意的是第一步预测量的结果是控件树所期望的窗口尺寸 由于wms中影响窗口布局的因素很多 wms不一定会将窗口准确地布局为控件树所要求的尺寸 在这个阶段 performTraversals将以窗口的实际尺寸对控件进行最终测量 view的onMeasure方法将会沿着控件树依次被回调 布局控件树阶段 view的layout方法会被回调 绘制阶段 view的onDraw方法被回调 第一步的预测量阶段在onMeasure时会接受到父控件的建议尺寸 出现widthSpec和heightSpec 这些参数收到MeasureSpec.UNSPECIFIED Measure.EXACTLY Measure.AT_MOST影响 遵循三个原则 第一次遍历时使用应用可用的最大尺寸作为SPEC_SIZE的候选 此窗口是一个悬浮窗口LayoutParams.width/height其中之一被指定为wrapContent时 使用应用可用的最大尺寸作为SPEC_SIZE的候选 其他情况使用窗口最新尺寸作为SPEC_SIZE的候选 布局控件树阶段主要分两步 第一个是进行控件树的布局 第二个是设置窗口的透明区域 performDraw是控件树的绘制入口 layoutRequested是一个判断标志位 判断控件树是否需要进入测量阶段 如果不需要就直接进入绘制阶段 进入requestLayout的目的是为了确定控件的位置和尺寸 而有时候这些都没有发生改变 只是改变了文字颜色或者背景 那么只需要调用invalidate canvascanvas就是一块画布 是一个绘图工具类 他的绘图指令分两类 一类是drawxxx来实现绘制点 线条 圆形 方块等 二类是辅助指令 如变换 剪切区域 save和restore来恢复坐标系等指令 canvas的绘制目标按软件绘制和硬件加速两种分 软件绘制的目标是建立在surface之上的位图bitmap 当通过Surface.lockCanvas方法获取一个canvas时会以Surface的内存创建一个Bitmap 通过canvas所绘制的内容直接反映到surface中第二种是hardwareLayer绘制目标是displayList displayList不是一块bitmap而是指令序列 displayList会将canvas的绘制指令编译并优化为硬件绘制指令 并且可以在需要时将这些指令回放到一个hardwareLayer上 而不需要重新使用canvas进行绘制 canvas.translate(x,y)可以进行坐标转换 使用save和restore进行恢复 view.invalidate会将需要重绘的区域沿着控件树提交给viewrootImpl 并保存在viewrootImpl的mDirty成员中 通过scheduleTraversals引发一次遍历 进而进行重绘工作 这个方法必须在主线程执行 但不会立即开始 主线程的Looper会在处理完其他消息后再处理invalidate 多次调用invalidate会使得viewrootImpl多次接受到设置脏区域的请求 viewRootImpl会将这些区域累加到mDirty中 进而随后的遍历中一次性地完成所有脏区域的重绘 另外postInvalidate用于在子线程开启的重绘 viewRootImpl.draw方法中产生硬件加速绘制和软件绘制两个分支 如果是硬件加速将会创建一个hardwareRender保存在mAttachInfo中 各组件之间的联系window是一个抽象类 他的具体实现是phoneWindow 而WindowManager是外界访问window的入口 windowManager只是接口 他继承自viewManager（主要三个方法addView updateViewLayout removeView） windowManager的实现由WindowManagerImpl来完成 windowManagerImpl中 有些版本会调用windowManagerGlobal的工厂方法来进行addview操作 而windowManagerGlobal会通过viewRootImpl的setview setLayoutParams来完成添加更新操作 而viewRootImpl最终通过IPC机制使用windowManagerService来执行添加更新删除操作","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"windowManager","slug":"windowManager","permalink":"http://luyaoming.com/tags/windowManager/"}]},{"title":"深入理解Android卷三-读书笔记（一）","date":"2016-07-01T09:07:27.000Z","path":"2016/07/01/深入理解Android卷三-读书笔记（一）/","text":"主要介绍windowManagerService的构成 深入理解Android卷三 作者： 张大伟– –读书笔记 by asii windowManagerServicewms主要有两个基础系统 布局系统 计算和管理窗口的位置和层次 动画系统 根据布局系统计算窗口位置与层次渲染窗口动画 关于窗口的概念窗口的本质是画布surface 用户看到的窗口实质上是一块块surface通过wms编排后输入到屏幕上展示给用户的 根据对surface的操作类型可以将Android的显示系统分为三个层次 ui框架层 负责在surface上绘制ui元素以及响应输入事件 wms 负责管理surface的分配和层级顺序等 surfaceFlinger 负责将多个surface混合后输出 在wms在新增窗口addWindow时包含了三个重要的内容 windowToken windowState和DisplayContent windowTokenwindowToken将属于同一个应用组件的窗口组织在一起 所谓应用组件包括activity inputMethod wallpaper 和dream 在wms对窗口管理的过程中用windowToken指代一个应用组件 在ZOrder排序时 属于同一个windowToken的会被安排在一起 第二点 windowToken具有令牌的作用 应用组件在需要新窗口时 必须提供windowToken表明自己的身份 并且窗口的类型必须与所持有windowToken的类型一致 在创建系统类型的窗口时 不需要提供一个有效的token wms会隐式地为其声明一个windowToken 但是要求客户端必须拥有创建系统窗口的权限 windowStatewindowState表示一个窗口的所有属性 所以他是wms事实上的窗口 在显示组件一侧也有对应的类型 IWindow.Stub 提供了很多与窗口管理相关通知的回调 例如尺寸变化和焦点变化 displayContentdisplayContent是根据窗口的显示位置将窗口分组 属于同一个displayContent的窗口将会被显示在同一个屏幕中 关于surface的显示次序 窗口根据自己的类型得出其主序以及子序 然后addWindowToListInOrderLocked()根据主序和子序以及所属的Activity的顺序 按照升序排列在在DisplayContent的MWindow列表中 然后assignLayersLocked()为MWindows中所有窗口分配最终的显示次序 之后 wms的动画系统将最终的显示次序通过surface.setLayer()设置进surfaceFlinger 窗口的布局将relayoutWindow作为布局的切入点 先修改了窗口属性 屏幕属性 焦点属性等 标记相关的displayContent为relayoutNeeded 调用performLayoutAndPlaceSurfaceLocked进行全局布局 再对布局结果进行进一步的操作 在布局的过程中 需要连续重新布局多次 最后才能布局完成 以窗口布局计算为主要任务的布局循环 以performLayoutLockedInner函数为核心 根据屏幕尺寸以及状态栏 导航栏 输入法窗口等系统窗口确定了作为窗口布局准绳的8歌矩形 再从8个矩形中选择4个矩形作为窗口布局的直接参数 并以这4个参数计算出窗口的最终位置 然后根据布局计算设置surface的位置和尺寸 并更新一些由窗口指定的系统属性为目的布局后处理 displayContent的布局其实是窗口的布局 而窗口的布局中又以窗口的布局计算为核心","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"windowManagerService","slug":"windowManagerService","permalink":"http://luyaoming.com/tags/windowManagerService/"}]},{"title":"Android软件安全与逆向分析-读书笔记（三）","date":"2016-06-22T03:40:15.000Z","path":"2016/06/22/Android软件安全与逆向分析-读书笔记（三）/","text":"主要介绍Android的破解和反破解技术 Android软件安全与逆向分析 作者： 丰生强– –读书笔记 by asii Android软件的破解技术android平台的试用版软件大致分为三类 免费试用版 演示版 和限制功能免费版 这三种类别的软件可能只使用同一个软件安装包 通过不同的授权来区别使用权限 又或者使用不同的安装包提供不同的软件功能 试用版软件下面介绍一种需要安装授权key的apk才能升级为高级版或者专业版的破解 破解的需求是：不需要安装授权key也可以使用专业版的所有功能 通过反编译dex文件得到的smali文件 查找判断权限的地方 一般带if条件 查找类似check appkey这类关键字容易找到 使用授权key的原理是目标程序与授权key程序拥有相同的用户id和签名 这样在目标程序就可以访问授权key内的内容信息 从而判断目标程序是免费版还是专业版 基于这种原理 我们只需要在目标程序判断授权key的地方修改条件就可以 序列号保护也称为注册码保护 在购买这种保护方式的软件时 用户需要向软件作者提供注册信息（用户名或者机器码）然后软件作者根据编写好的算法程序计算出注册码发回给用户 用户使用这个注册码完成注册的过程 而软件作者的这种算法技术也称为注册机 在计算可逆机密算法程序的注册码时 通常是软件加密的一个逆过程 网络验证网络抓包工具 fiddler tcpdump wireshark 网络验证是软件在运行时需要联网进行一些验证 链接方式可能是socket或者http 验证的内容可以是软件注册信息验证 代码完整性验证 软件功能解密等 静态的网络验证比较容易破解 静态的网络验证就像访问服务器上的某个文件获取内容然后客户端进行校验 在破解时只需要根据地址获取到该内容就可以在本地进行破解 而动态的网络验证比较麻烦 可能需要传递特定的参数访问服务器然后服务器的脚本程序根据不同的参数返回不同的数据 应用内付费一般的应用内付费都是需要google checkout账号 需要发布在google play平台 必须通过访问google play服务器进行交易 由于国内暂时不支持google 所以就不做讨论了 重启验证保护法在软件注册时 不直接提示注册成功与否 而是将注册信息保存下来 然后在软件下次启动时读取并验证 如果失败则软件未注册 成功则开启注册版的功能 一般重启验证的保护模块采用Native代码编写 并且加入网络验证 Android软件的反破解技术一般分4个步骤 反编译 静态分析 动态分析 重编译 那么反破解就要分别对应这4步进行反破解 对抗反编译 可通过压力测试 阅读反编译工具源码等方式来查找反编译工具的缺陷 对抗静态分析 因为java代码容易被反编译 native代码是一种好的代码保护手段 毕竟逆向原生比较难懂些 还有一种方式就是使用Proguard混淆技术 可以使用keep class使某些java代码不被混淆 对抗动态调试 (1)先检测调试器 在AndroidManifest中的application的标签中加入android:debuggable=”false”可以让程序不可调试 再在java代码中检测这个这个值是否被修改 如果被修改克直接退出进程 另外sdk还提供了一个方法检测调试器是否连接 android.os.Debug.isDebuggerConnected() (2)检测模拟器 可以检测下面几个属性 ro.product.model模拟器为sdk 正常手机为手机型号 ro.build.tags 模拟器为test-key 正常手机为release-keys ro.kernel.qemu 模拟器为1 正常手机没有该属性 可以直接在命令行运行 adb shell getprop ro.kernel.qemu来对比下属性 对抗重编译 (1)检查签名 getPackageManager().getPackageInfo(…).signatures可以获得签名 比较签名的hashcode就可以判断软件是否被重编译 （2）校验保护 代码每次重编译生成的dex文件的hash值都会发生改变 apk本身是一个zip 可以采用CRC作为classes.dex的校验算法zf = new ZipFile(getApplicationContext().getPackageCodePath()); ZipEntry ze = zf.getEntry(“Classes.dex”);String crc = String.valueOf(ze.getCrc()); Android系统攻击与防范关于root手机root手机有几种安全隐患 1 系统不稳定 2 病毒侵入 3 隐私数据暴露root手机的原理 可以通过x-ray for Android检查手机的提权漏洞 比较常见的漏洞是Gingerbreak 一键root工具是基于这些漏洞 向手机系统的/system/app目录写入root权限管理软件 Superuser.apk 以及向/system/bin/或者/system/xbin目录写入su程序 这两个软件由ChainsDD在github上维护 作者Zinx就是Android安全之路的先驱 Android的串谋权限攻击A程序没有声明权限使用功能 B程序具备权限使用功能 A程序可以通过B程序来使用这些权限功能 这就是串谋权限攻击 关于检测权限攻击 可以使用Mercury工具 Android组件安全activity具备在intent过滤器 默认是可以通过外部访问的 这样容易被其他外部程序发起串谋攻击 activity有一个属性 android:exported属性 当该属性声明为false时 外部程序（签名不同 用户id不同的程序）就不能发起调用了 还可以在指定activity中加入android:permission=”com.test.abc”来限定某些加入该权限才能访问的程序 activity劫持 劫持的原理是当用户安装了带有activity劫持功能的恶意程序后 恶意程序会遍历系统中运行的程序 当检测到需要劫持的activity（通常是网银或者其他网络程序的登录界面）在前台运行时 恶意程序会启动一个带有FLAG_ACTIVITY_NEW_TASK标志的钓鱼式activity覆盖正常的activity 从而欺骗用户输入用户名或者密码信息 当用户输入完信息后 恶意程序会将信息发送到指定的网址或者邮箱 然后切换到正常的activity中去 下面演示下activity劫持的检测和启动过程 启动定时器检测系统正在运行的进程是否与劫持的进程列表相匹配的 如果有就劫持 private TimeTask mTask = new TimerTask()&#123; @override public void run()&#123; ActivityManager am=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningAppProcessInfo&gt; infos = am.getRunningAppProcesss(); for(RunningAppProcessInfo painfo: infos)&#123; if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FORGROUND)&#123; //检测到是前台进程 if(mhijackingList.contains(psinfo.processName))&#123; Intent intent = new Intent(getBaseContext(),HijackActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.putExtra(\"processName\",psinfo.processName); getApplication().startActivity(intent); &#125; &#125; &#125; &#125;&#125; 上面的手法是劫持了进程（可以是多个进程） 想劫持activity可以将getRunningAppProcess换成getRunningTask就可以获取当前的任务列表这种劫持手法透明 一般防病毒软件无法检测 手机用户更是防不胜防 有个比较简单的检测方式是长按home键查看最后运行的程序来判断activity是否被劫持过 然后这种方法并不是时常有效 可以设置属性android:exludeFromRecents的值为true 即使运行过的进程也不会显示最近运行过的列表中 broadcast Receiver安全凡是通过intent-filter来接收的都可以通过外部来访问 之前讲过解决方案是组件属性Android:exported属性设置为false 让组件只能接收到同用户id和签名的进程发送的广播 要想指定哪类进程可以发送 也可以配置permission 广播又分有序广播和无序广播两种 sendBroadcast和sendOrderedBroadcast 无序广播可以被所有广播接收者接收并且不能通过abortBroadcast中止广播 有序广播按照优先级度顺序接受 优先度高的广播可以拦截广播调用abortBroadcast中止广播 优先级度通过属性android:priority属性的数值来决定 数值越大 优先度越高 取值范围-1000到1000 我们可以设置接收短信的receiver的值为最大值 就可以拦截短信 短信不回存到收件箱 service安全service一般用作后台任务 由于他没有界面 执行起来更加隐蔽 同样可以使用exported属性为false来阻止其他恶意软件调用 同一作者如果想多个程序共享使用该服务可以定义权限 没有声明该权限下调用该服务会报SecurityException异常 数据安全数据分外部存储和内部存储两种 使用new file(“dir”)这类一般为外部存储 使用openFileOutput(“config.txt”,MODE_PRIVATE)这类为内部存储 注意第二个参数MODE_PRIVATE使其他程序无法访问这个文件 如果改为MODE_WORLD_READABLE就会被其他程序访问到 可以使用如下代码​Context Context = new createPackageContext(\"com.adb.abc\",Context.CONTEXT_IGNORE_SECURITY);FileInputStream fis = context.openFileInput(\"config.txt\"); 其实无论有无设置MODE_PRIVATE 想获取私有内部数据都是有可能的 所以关键在于数据的加密 还要注意的是所有使用intent来传递数据的 尽量不要使用action的方式 而是采用指定目标组件的方式 因为使用action容易被其他程序拦截 当优先级被抢夺后信息就会暴露","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"破解","slug":"破解","permalink":"http://luyaoming.com/tags/破解/"}]},{"title":"Android软件安全与逆向分析-读书笔记（二）","date":"2016-06-20T08:02:16.000Z","path":"2016/06/20/Android软件安全与逆向分析-读书笔记（二）/","text":"主要介绍破解Android程序使用的两种方式 静态分析和动态调试 Android软件安全与逆向分析 作者： 丰生强– –读书笔记 by asii 静态分析Android程序何为静态分析 是指在不运行代码的情况下 采用词法分析 语法分析等各种技术手段对程序文件进行扫描从而生成程序的反汇编代码 然后阅读反汇编代码在掌握程序功能的一种技术 静态分析主要分两种方法 阅读反汇编生成的dalvik字节码 可以使用IDA PRO分析dex文件 或者使用文本编辑器阅读baksmali反编译生成的smali文件 阅读反编译生成的java代码 可以使用dex2jar生成jar文件 然后再使用jd-gui来阅读jar文件的代码 快速定位程序中的关键代码先使用apktool反编译apk文件 拿到manifest文件可以查看主activity 分析application类 作者总结了几种定位关键代码的方法 信息反馈法 先运行目标程序然后根据程序运行时给出的反馈信息作为突破口寻找关键代码 例如之前说的根据toast查账string中的这段id 再根据id查找到代码调用处 特征函数法 某一些特别的函数会被调动 然后搜索该函数并进行筛选 顺序查看法 根据软件的启动代码开始逐行向下分析 这种方法在病毒分析时经常用 代码注入法 这是一种动态调试方法 手动修改apk文件的反汇编代码加入log输出 配合logcat查看程序执行到特定点时的状态数据 栈跟踪法 也是动态分析法 原理是输出运行时的栈跟踪信息 然后查看栈上的函数调用序列来理解方法的执行流程 method profiling 也是动态分析法 根据函数的占用cpu时间 函数的调用关系等查找关键代码 对于静态分析工具 IDA PRO和Androguard 都是非常实用的工具 前者是付费版 需要在Linux或者windows系统下安装运行 后者是免费工具 只能在Linux下运行 可以评估apk风险 计算apk相似度 可以与gephi配合 生成图形文件直观地分析 前面的阅读笔记提及过apktool和baksmali 有很多静态分析工具都是以他们为基础开发的 有款apkInspector由国人开发 上面说的都是静态分析的第一种方法 都是直接分析smali来修改代码 下面介绍的是第二种分析方法 使用dex2jar生成jar文件 再使用jd-gui来查看jar文件的源码 如果需要一个集成环境专门开研究Android反编译的问题 可以安装一个Ubuntu系统 santoku 他的官网是https://santoku-linux.com 里面集成了大量主流的Android程序分析工具 可支持Android iphone等移动设备的取证工作 集成渗透测试工具 集成网络数据分析工具 提一下Android ndk作为Android应用开发人员 通常是下面这两种情况下用到Android ndk 第一种是移植其他平台的c或c++库到Android程序中来 这类程序开发一般分三个阶段 首先需要完成代码的移植 然后编写接口函数来完成原生代码与java代码的通信 在接口中调用功能代码 通过jni接口返回特定类型的数据 最后在java代码中调用这些接口函数 第二种是为了加强代码保护 防止核心技术被破解 这是一种为了原生代码而编写原生代码的方法 动态调试Android应用程序ddms就是一个常用的动态调试工具 全称是dalvik debugs monitor service 他提供了设备截屏 查看运行的线程信息 文件浏览 logcat method profiling 广播状态信息 模拟电话呼叫 接受sms 虚拟地理坐标等功能 通过代码注入法 可以在代码关键处 添加toast或者log注入 让注册码打印出来 或者作为是否被调用的根据 当然这些前提都是需要先阅读smali代码并理解关键代码在哪才可以注入 栈跟踪法 用法类似代码注入法 不过并不是打印日志 而是打印个staceTrace 相应的java代码类似于 new Exception(“print trace”).printStackTrace();而转换为smali代码如下 new-instance v0, Ljava/lang/Exception;const-string v1, \"print trace\"invoke-direct &#123;v0,v1&#125;, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)Vinvoke-virtual &#123;v0&#125;, Ljava/lang/Exception;-&gt;printStackTrace()V 把上面一段代码插入到断点地方 就可以查看运行到断点之前的所有方法运行的路径 使用ddms的method profiling 可以追踪方法的调用 parent代表该方法被哪个方法调用 children代表该方法调用了哪些方法 可以在代码段中添加startMethodTracing和stopMethodTracing来追踪方法的调用 生成的trace文件使用traceview来打开 对于原生代码的分析 可以使用IDA PRO和gdb","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"IDA PRO","slug":"IDA-PRO","permalink":"http://luyaoming.com/tags/IDA-PRO/"}]},{"title":"Android软件安全与逆向分析-读书笔记（一）","date":"2016-06-19T03:17:27.000Z","path":"2016/06/19/Android软件安全与逆向分析-读书笔记（一）/","text":"主要介绍逆向的思路 使用的工具 和 dvm的指令集 Android软件安全与逆向分析 作者： 丰生强– –读书笔记 by asii 破解第一个应用程序一般破解程序可以从错误信息入手 例如toast提示 注册失败！ 那么可以在资源文件中找到该string字段 通过R.java文件找到对应的id 在反编译后的smali文件中查找该id 读dalvik指令集 判断注册成功的地方 修改代码 重新打包dex 工具 apktool 编译和反编译工具 在windows或者Ubuntu下可用 windows下使用方法 反编译 apktool d abc.apk outdir 编译 apktool b app路径 abc2.apk 工具 signapk.jar 签名工具 位于android源码目录下/build/tools/signapk/SignApk.java 可使用Android系统提供的签名文件进行签名testkey.pk8和testkey.x509.pem 新建批处理文件signapk.bat java -jar &quot;%~dp0signapk.jar&quot; &quot;%~dp0testkey.x509.pem&quot; &quot;%~dp0testkey.pk8&quot; %1signed.apk 将testkey.pk8和testkey.x509.pem和signapk.jar,signapk.bat放在同一目录下 cmd进入该目录 运行signapk abc.apk 就会在该目录下生产apk文件 dex文件反汇编工具 主流的有bakSmali和Dedexer将dex文件反汇编成smali文件 采用baksmali的代码示例为java -jar baksmali.jar -o baksmaliout Hello.dex 编译smali文件使用smali.jar 示例java -jar smali.jar -o classes.dex HelloWorld.smali 了解Android Dalvik虚拟机以下简写java虚拟机为jvm Android dalvik虚拟机为dvm jvm和dvm的区别 jvm运行的是java字节码即class文件 dvm运行的是dalvik字节码 jvm通过解码class文件运行程序 而dvm是通过dx工具将class转为dalvik字节码 dalvik可执行文件体积更小 在转换过程中会对class重排列 消除冗余信息减少dalvik可执行文件的体积 jvm和dvm架构不同 jvm是基于栈架构 运行时jvm需要频繁从栈上读取和写入数据这个过程需要更多指令分派和内存访问 会消耗不少cpu时间 而dvm是基于寄存器架构的 数据访问通过寄存器间直接传递 dvm是如何执行程序的dvm属于Android Runtime层 从Android系统启动开始分析dvm是如何执行程序的 Android加载完Linux内核后 第一个执行的进程是init进程 运行init.rc脚本启动zygote进程 zygote进程是进程孵化器 zygote进程在启动过程中 先初始化dvm 然后启动system_server进入zygote模式 创建出一个server socket等待activityManagerService向zygote发送一个进程间通信请求 来创建一个新的应用进程 zygote收到请求后通过fork自身来创建一个dvm实例来执行main函数 fork成功后工作就交给dvm 下面是dvm的执行过程 首先通过LoadclassfromDex函数完成类的装载工作 虚拟机使用gDvm.loadedClasses来存储和查询所有装载进来的类 字节码验证器使用dvmVerifyCodeFlow对装入的代码进行校验 虚拟机调用finaClass查找并装载main函数 调用dvmInterpret初始化解释器并执行字节码流 关于jit即时编译 从Android2.2开始加入 是一种通过在运行时将字节码翻译成机械码的技术 主流jit包含两种字节码编译方式 method方式 以函数为单位进行编译 trace方式 以trace为单位进行编译 trace分热路径和冷路径 很少被执行的称为冷路径 频繁执行的称为热路径 虚拟机默认trace方式编译代码 dalvik指令集 空操作指令 nop 数据操作指令 例如move vA,vB 就是将vB寄存器的值赋给vA寄存器 两种寄存器都是4位 返回指令 例如return-void 函数从一个void方法返回 数据定义指令 例如 const/4 vA,#+B 将数值符号扩展为32位后赋给寄存器vA 锁指令 例如monitor-enter vAA 为指定的对象获取锁 实例操作指令 例如new-instance vAA,type@BBBB 构造一个指定类型对象的新实例 并将对象引用赋值给vAA寄存器 类型符type指定的类型不能是数组类 数据操作指令 例如array-length vA,vB 获取给定vB寄存器中数组的长度并将值赋给vA寄存器 数组长度指的是数组的条目个数 异常指令 throw vAA 抛出vAA寄存器中指定类型的异常 跳转指令 goto +AA 无条件跳转到指定偏移处 偏移量AAAA不能为0 比较指令 cmpl-float 比较两个单精度浮点数 如果vBB寄存器大于vCC寄存器 则结果为-1 相等为0 小于为1 字段操作指令 普通字段操作指令有iget iget-wide 静态字段操作指令sget sget-wide 方法调用指令 invoke-virtual 或invoke-virtual/range 调用实例虚方法 数据转换指令 float-to-int 将单精度浮点型转为整形 数据运算指令 add-int v1,v2 将v1寄存器与v2寄存器的值相加","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"Dalvik","slug":"Dalvik","permalink":"http://luyaoming.com/tags/Dalvik/"}]},{"title":"Android系统源代码情景分析-读书笔记（八）","date":"2016-06-17T09:33:03.000Z","path":"2016/06/17/Android系统源代码情景分析-读书笔记（八）/","text":"主要介绍Android应用程序的安装和显示过程 在源码中的流程 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii Android应用程序的安装和显示过程package管理服务packageManagerService在安装一个应用程序过程中主要实现两件事 第一 解析这个应用程序的配置文件AndroidManifest.xml 以便获得他的安装信息 第二 给这个应用程序分配Linux用户id和Linux用户组id 以便他可以在系统中获得合适的运行权限 系统的默认home应用程序launcher就是通过请求packageManagerService返回已经在系统中安装了应用程序的信息 接着这些信息封装成桌面图片显示在屏幕中 以便用户可以点击快速启动程序的 应用程序的安装过程上面提到packageManagerService会做的两件事 第二件是分配Linux用户id和用户组id 在分配用户id之前他会先判断是否与其他应用程序共享了同一个id 否则分配一个唯一的Linux用户id 而用户组id有什么用 例如应用程序需要使用读取联系人信息 使用摄像头 拍照等操作 就需要获得这些资源的使用权限 给他分配相应的用户组id 他就有了这些资源的使用权限 代码过程一共分17步 PackageManagerService.main 入口 通过mSetting的writeLP函数将前面获得的应用程序安装信息保存在本地的一个配置文件中 以便下次可以恢复 Settings.readLP 读取上次保存的安装信息 Settings.readPackageLp Settings.addPackageLP Settings.readSharedUserLP Settings.addSharedUserLP PackageManagerService.scanDirLI PackageManagerService.scanPackageLI PackageParser.parsePackage PackageParser.parseApplication PackageManagerService.scanPackageLI Settings.getPackageLP Settings.newUserIDLP PackageManagerService.updatePermissionLP PackageManagerService.grantPermissionLP Settings.writeLP Settings.writePackage 上面的代码没有一一分析 其实只是做个记录 等自己再翻代码时可以有条路径可以追溯 应用程序的显示过程Server进程是由zygote进程启动起来的 server进程在启动过程中 又会创建一个ServerThread线程来启动系统中的关键服务 当系统中的关键服务都启动起来之后 这个serverThread线程就会通知ActivityManagerService将应用程序Launcher启动起来 代码共分13步 ServerThread.run ActivityManagerService.systemReady ActivityStack.resumeTopActivityLocked ActivityManagerService.startHomeActivityLocked ActivityStack.startActivityLocked Launcher.onCreate LauncherModel.startLoader LoaderTask.run LoaderTask.loadAndBindAllApps LoaderTask.loadAllAppsByBatch PackageManagerService.queryIntentActivities Launcher.bindAllApplication AllApps2D.setApps 显示完成后 当点击某个快捷图标时 会调用onItemClick方法 获得程序信息 然后launcher通过startActivitySafely来启动相应的应用程序","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"packageManagerService","slug":"packageManagerService","permalink":"http://luyaoming.com/tags/packageManagerService/"}]},{"title":"Android系统源代码情景分析-读书笔记（七）","date":"2016-06-10T15:52:09.000Z","path":"2016/06/10/Android系统源代码情景分析-读书笔记（七）/","text":"主要介绍Android应用程序的消息处理机制 和 线程的消息循环模型 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii Android应用程序的消息处理机制Android系统的消息处理机制围绕着消息队列来实现 将一个线程的生命周期划分为创建消息和消息循环两部分 而消息循环又划分为发送消息和处理消息两个阶段 这两个阶段交替进行 消息处理机制通过这三个类来实现 messageQueue Looper handler 各司其职 messageQueue用来描述消息队列 Looper用来创建消息队列以及进入消息循环 handler用来发送消息和处理消息 创建消息java层的looper和messageQueue对应c++层的looper（native）和NativeMessageQueue 其中java层的messageQueue包含有一个int类型的成员变量mPtr 它保存的是NativeMessageQueue对象的地址值 这样就可以把java层和c++层关联起来 通过调用java层的prepare或prepareMainLooper来为线程创建一个消息队列时 先在线程中创建一个looper对象 由于looper类包含成员messageQueue 所以会创建messageQueue对象 而messageQueue对象又包含对C++层nativeMessageQueue的地址 会调用Nativeinit创建NativeMessageQueue对象 而nativeMessageQueue对象包含c++层的looper 继而创建native的looper对象 Looper对象再包含两个文件描述符 分别是对管道的读和写 消息循环用代码来描述下这个过程 Looper.loop java层 MessageQueue.next java MessageQueue.nativePollOnce c++ NativeMessageQueue.pollOnce c++ Looper.pollOnce c++ Looper.pollInner c++ Looper.awoken c++ 当没有消息时 消息线程会进入睡眠状态以免占用时间片 当有新消息时会把当前线程唤起以便他及时去处理刚刚发送到他的消息队列的消息 消息发送分析下handler类 他包含两个成员变量mLooper和mQueue 调用handler的默认构造函数可以初始化这两个变量 其中mLooper的获得是通过mLooper = Looper.myLooper();而mQueue是通过mQueue = mLooper.mQueue; 我们知道调用myLooper函数是通过mLocalThread.get来获取当前线程的looper的 所以handler在哪个线程创建 looper就是哪个线程的 按代码描述分5步 Handler.sendMessage MessageQueue.enqueueMessage MessageQueue.nativeWake NativeMessageQueue.wake Looper.wake 从java层到c++层的调用都是通过MessageQueue中的mPtr引用 最后一步 通过looper向管道写入数据从而唤醒线程 消息处理过程handler可以通过三种途径来处理消息先看handler分发消息的方法​public class Handler&#123; ... public void dispatchMessage(Message msg)&#123; if(msg.callback!=null)&#123; handleCallback(msg); &#125;else&#123; if(mCallback!=null)&#123; if(mCallback.handleMessage(msg))&#123; return; &#125; &#125; handleMessage(msg); &#125; &#125;&#125; 第一种 先判断传进来的msg中是否含有callback 这个callback实际上是个runnable 通过message.callback.run();来调用 第二种是通过判断handler内部的callback变量 这个callback从哪儿赋值的呢 是从handler另一个构造函数public Handler(Callback callback) 第三种就是我们常用的 通过重写Handler的成员函数handleMessage来处理 这三种情况不是同级的 优先级1&gt;2&gt;3 应用程序线程的消息循环模型不定期的后台任务有两种执行方式 第一种是满足条件时创建一个子线程来执行一个不定期任务 任务执行完后 新建的子线程会随之退出 第二种是创建一个具有消息循环的子线程 每当满足条件时会把不定期任务封装成一个消息发送到子线程的消息队列中执行 当条件不满足时 子线程会因为消息队列为空而进入睡眠状态 虽然第一种执行方式不需要消息循环 但是不断创建和销毁线程是有代价的 从这个角度 希望子线程也像主线程一样具有消息循环 共有三种消息循环模型 第一种是应用程序主线程消息循环模型 第二种和第三种是与界面有关和无关的子线程消息循环模型 第一种 应用程序的主线程就是我们常说的ui线程 从前面的章节了解到是有activityManagerService通过process的start函数请求zygote进程创建一个新的应用程序进程 这个进程创建完成后 会以ActivityThread的main函数来作为新创建的应用程序入口 所以这个ui线程的入口就是这个main函数 main函数中会调用Looper.prepareMainLooper来创建消息循环并且创建MessageQueue对象 第二种 与界面无关的应用程序子线程的消息循环模型 ui线程的消息循环已经在ActivityThread的main函数中通过prepareMainLooper自动创建完成 而子线程的looper需要通过用户自己创建 使用函数Looper.myLooper来创建子线程的looper而这些操作 都封装在Android自带的一个类handlerThread中 public class HanderThread extends Thread&#123; ... private Looper mLooper; public HandlerThread(String name)&#123; super(name); ... &#125; public void run()&#123; ... Looper.prepare(); synchronized(this)&#123; mLooper = Looper.myLooper(); ... &#125; ... Looper.loop(); ... &#125; public Looper getLooper()&#123; ... return mLooper; &#125; public void quit()&#123; Looper looper = getLooper(); if(looper!=null)&#123; looper.quit(); return true; &#125; return false; &#125; &#125; 上面是sdk自带的实现消息循环的类handlerThread 看她的run方法包含了创建消息循环的过程 使用起来也简单 在Activity中 首先创建Handlerthread实例 让他成为成员变量方便使用HandlerThread mHandlerThead = new HandlerThread(\"Handler\");mHandlerThread.start();这样就启动了一个消息循环 当有任务需要处理时 任务作为一个runnable 通过自定义的handler使用post的方式封装成消息发送出去创建runnable任务Runnable task = new Runnable&#123; public void run()&#123; ...耗时任务 &#125;&#125;;创建handler用于发送消息 记得要把之前创建的handlerThead的looper对象传进入 没有此looper的话 在哪创建的handler 就是使用哪里的线程的looperHandler handler = new Handler(mHandlerThread.getLooper());handler.post(task);在不再需要线程循环的地方例如onDesory时调用mHandlerTread.quit()就可以退出 第三种 与界面相关的应用程序子线程消息循环模型符合这种模型的如Android应用框架的AsyncTask 他的应用很简单 重写他的三个方法doInBackground onProgressUpdate onPostExecute 其实他的内部一样是通过handler和thread来实现的 AsyncTask内部包含一个线程池TreadPoolExecutor 一个线程工厂ThreadFactory 和一个InnerHandler 这个handler重写handleMessage方法接受MESSAGE_POST_RESULT MESSAGE_POST_PROGRESS 和 MESSAGE_POST_CANCLE三中消息并分别调用用户的回调函数finish onProgressUpdate onCancel AsyncTask在构造函数中初始化一个WorkerRunnable来回调doInBackground方法 然后封装成一个futureTask 外部通过executeOnExecutor来调用线程池Executor来执行此任务futureTask回调finish函数时 进而回调onPostExecut方法结束","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"handler","slug":"handler","permalink":"http://luyaoming.com/tags/handler/"}]},{"title":"Android系统源代码情景分析-读书笔记（六）","date":"2016-06-08T08:40:45.000Z","path":"2016/06/08/Android系统源代码情景分析-读书笔记（六）/","text":"主要介绍zygote system进程的启动流程 和 Android应用程序的启动流程 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii zygote和system进程的启动过程zygote进程是Android系统的第一个进程init启动起来的 他称之为进程孵化器 所有的应用进程 以及用来运行系统关键服务的system进程都是由zygote进程负责创建的 init进程在内核加载完后会启动 启动过程中会读取根目录下得init.rc脚本 service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server socket zygote steam 666 这段脚本代码表示 zygote是以服务形式启动的 对应程序文件/system/bin/app_procee zygote启动完后会把system进程启动 zygote进程在启动过程中会在内部创建一个名为zygote的socket 这个socket用于进程间通信 访问权限为666支持所有用户读写 运行在system进程的ActivityManagerService会通过socket请求zygote创建新的应用进程 zygote一开始加载的进程文件为system/bin/app_process init.c中通过调用fork函数复制自己来创建一个子进程 通过create_socket函数创建socket 创建成功会返回一个文件描述符 然后再通过publish_socket把文件描述符发布到系统中 zygote的启动过程 app_procee.main AndroidRuntime.start ZygoteInit.main ZygoteInit.startZygoteSocket ZygoteInit.startSystemServer ZygoteInit.runSeleteLoopMode 到启动的最后一步时 zygote开启了一个无限循环来等待Activity管理服务ActivityManagerService请求Zygote进程创建新的应用程序进程 注意此时他们只是建立了连接 并没有创建进程 system进程的启动过程 ZygoteInit.handleSystemServerProcess RuntimeInit.zygoteInit SystemServer.main SystemServer.init1 SystemServer.init2 ServerThread.run 到最后一步 系统中的关键服务启动起来 包括ActivityManagerService ContentService WindowManagerService PackageManagerService 这时候其他进程就可以通过Service Manager来获得这些服务的代理对象 并且通过这些代理对象来使用系统提供的基础服务了 Android应用程序的启动过程 每当ActivityManagerService需要创建一个新的应用程序进程来启动一个应用程序组件时 他就会调用ActivityManagerService类的成员函数startProcessLocked向zygote进程发送一个创建应用程序进程的请求 代码实现 一共分8步 ActivityManagerService.startProcessLocked Process.start Process.startViaZygote Process.zygoteSendArgsAndGetPid ZygoteInit.runSeleteLoopMode ZygoteConnetction.runOnce ZygoteConnetction.handleChildProc RuntimeInit.zygoteInit 应用程序进程创建完成后会继续启动一个binder线程池主要分三步 RuntimeInit.zygoteInitNative AppRuntime.onZygoteInit ProcessState.startThreadPool 执行完成后 新创建的应用进程就可以支持binder进程间通信了 这意味着我们以后在应用程序进程中实现自己的binder本地对象时 只需要将他启动起来并且注册到service Manager中就可以了 接下来就要为进程创建消息循环队列 ActivityThread的main函数为应用程序进程的入口函数 在main调用过程中 创建消息循环 RuntimeInit.invokeStaticMain ZygoteInit.main methodAndArgsCaller.run ActivityThread.main 在Android系统中 每一个应用程序进程在启动完成后 都会自动进入到一个消息循环中 这样 运行在里面的应用程序组件就可以方便地使用Android系统的消息处理机制来实现自己的业务逻辑","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"android","slug":"android","permalink":"http://luyaoming.com/tags/android/"},{"name":"zygote","slug":"zygote","permalink":"http://luyaoming.com/tags/zygote/"}]},{"title":"Android系统源代码情景分析-读书笔记（五）","date":"2016-06-05T02:58:23.000Z","path":"2016/06/05/Android系统源代码情景分析-读书笔记（五）/","text":"主要介绍Android中的广播在源码中的启动流程 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii 广播机制是基于消息发布和订阅的事件驱动模型 就是广播发送者负责发布消息 而广播接收者需要先订阅消息 才能接收到消息 广播与activity和service和contentprovider 都可以进程间通信 都是通过底层的binder的c++代码 只不过在4大组件中封装了调用的过程 他们都是ActivityManagerService作用的 而广播与他们区别的有点在 client和server组件通信之前 必须先获得一个代理对象即Client必须知道server组件的存在 而广播发送者是不需要知道广播接收者是否存在的 这样可以降低广播接受者和发送者的耦合度 在不同的activity或fragment或service中 我们时常会使用接口来进行函数回调和交互 而广播是另一种解决方案 他的优点在于可以降低发送者与接收者之间的耦合度 接受者不再依赖于发送者的回调接口 先看广播的注册过程 Activity.registerReceiver ContextWrapper.registerReceiver ContextImpl.registerReceiver ActivityManagerProxy.registerReceiver ActivityManagerService.registerReceiver 在注册过程中 使用一个hashmap把接收者和注册组件关联在一起 最终proxy中的binder代理对象remote调用transact向ActivityManagerService发送一个REGISTER_RECEIVER_TARNSACTION的进程间通信请求 广播的发送过程 广播发送者 即activity或者service组件 将一个特定类型的广播发送给activityManagerService activityManagerService接收到广播后 首先找到这个广播对应的广播接收者然后将他添加到广播调度队列中 最后向ActivityManagerService所运行的线程的消息队列发送一个类型为BROADCAST_INTENT_MSG的消息 当上面那个消息被处理时 ActivityManagerService会从广播调度队列中找到需要广播的广播接收者 并且把对应的广播发送给他们所运行在的应用程序进程 广播接收者所运行在的应用程序进程接收到ActivityManagerService发送过来的广播后 并不是直接将接收到的广播分发给广播接收者来处理 而是将接收到的广播封装成一个消息 并且发送给主线程的消息队列中 当这个消息被处理时 应用程序才会将他所描述的广播发送给相应的广播接收者处理 activity.sendBroadcast ContextWrapper.sendBroadcast ContextImpl.sendBroadcast ActivityManagerProxy.broadcastIntent ActivityManagerService.broadcastIntent ActivityManagerService.broadcastIntentLocked ActivityManagerService.scheduleBroadcastsLocked Handler.handle Message ActivityManagerService.processNextBroadcast ActivityManagerService.deliverToRegisterReceiverLocked ActivityManagerService.performReceiveLocked ActivityManagerProxy.scheduleRegisteredReceiver ApplicationThread.scheduleRegistereReceiver InnerReceiver.performReceive ReceiverDispatcher.performReceive Args.run BroadcastReceiver.onReceive 可以看到广播的注册和接收都是离不开ActivityManagerService 都通过binder进程间通信来处理消息 广播接收者接收到消息并不是理解处理的 而是先添加到主线程的消息队列中 再由process调度再发送给相应的receiver处理的","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Broadcast","slug":"Broadcast","permalink":"http://luyaoming.com/tags/Broadcast/"}]},{"title":"Android系统源代码情景分析-读书笔记（四）","date":"2016-06-04T08:19:40.000Z","path":"2016/06/04/Android系统源代码情景分析-读书笔记（四）/","text":"主要介绍Android的service在新进程中的启动过程 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii service在新进程中的启动过程service组件也是通过activity管理服务activityManagerService启动的 service跟activity不同 他没有界面 所以启动新组件之前 不需要让前面的组件进入pause状态 我在这里先把activity称为client service称为server 大概的步骤有4步 client组件首先向ActivityManagerService发送一个启动Server组件的进程间通信请求 ActivityManagerService发现用来运行Server组件的应用程序不存在 因此先把Server组件的信息保存下来 接着再创建一个新的进程 新的应用程序进程启动完成后 会向ActivityManagerService发送一个启动完成的进程间通信请求 以便ActivityManagerService可以继续执行启动Server组件的操作 ActivityManagerService会将第二步保存下来的service组件信息发送给新创建的进程 以便他把server启动起来 下面贴一下19个代码步骤 有很多与activity的启动过程相似 client.onCreate ContextWrapper.startService ContextImpl.startService ActivityManagerProxy.startService ActivityManagerService.startService ActivityManagerService.startServiceLocked ActivityManagerService.bringUpServiceLocked ActivityManagerService.startProcessLocked ActivityThread.main ActivityManagerProxy.attachApplication ActivityManagerService.startApplcation ActivityManagerService.attachApplicationLocked ActivityManagerService.realStartServiceLocked ApplicationThreadProxy.scheduleCreateService ApplicationThread.scheduleCreateService ActivityThread.queueOrSendMessage H.handleMessage ActivityThread.handleCreateService Server.onCreate","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"service","slug":"service","permalink":"http://luyaoming.com/tags/service/"}]},{"title":"Android系统源代码情景分析-读书笔记（三）","date":"2016-06-02T04:11:24.000Z","path":"2016/06/02/Android系统源代码情景分析-读书笔记（三）/","text":"主要介绍Activity组件的启动流程 包括从launcher点开和从另一个页面点开两种 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii Activity组件的启动过程怎么把其中一个Activity运行在另一个进程里 只需要在manifest中为activity配置属性process:”abcd” 注意其他activity的process属性要跟他不一样 这样这个独特的activity就运行在名为“abcd”的进程里 使用命令行查看activity的task信息 adb shell dumpsys activity 引用程序在启动时 会先启动launcher组件 再启动activity组件 根activity的启动过程 launcher组件向activityManagerService发送一个启动MainActivity组件的进程间通信请求 activityManagerService首先将要启动的MainActivity组件的信息保存下来 然后再向Launcher组件发送一个进入中止状态的进程间通信请求 Launcher组件进入到中止状态后 就会向ActivityManagerService发送一个已进入中止状态的进程间通信请求 ActivityManagerService发现用来运行MainActivity组件的应用程序不存在 因此 他会先启动新的应用程序 新的应用程序进程启动完成后 就会向ActivityManagerService发送一个启动完成的进程间通信请求 ActivityManagerService将第二步保存下来的MainActivity组件的信息发送给第四步创建的应用程序进程 以便MainActivity组件启动起来 上面的过程要追踪代码的话 要分35步 Launcher.startActivitySafely 根Activity是由Launcher启动起来的 Launcher.startActivitySafely会接受一个intent参数 里面包含MainActivity的组件信息 这个组件信息是在系统启动时 会启动一个PackageManagerService来安装系统中的应用程序 在安装过程中 会对配置文件AndroidManifest.xml进行解析 从而得到里面的组件信息 Activity.startActivity 第一步的Launcher.startActivitySafely函数直接调用父类的startActivity Activity.startActivityForResult 第二步调用第三步的函数 requestcode为-1 mInstrumentation.execStartActivity(this,mMainThread.getApplicationThread(),mToken,this,intent,requestCode) mInstrumentation是监控应用程序和系统之间的交互操作的组件 调用execStartActivity是代为启动Activity组件的操作 里面的参数：mMainThread是一个ActivityThread类实例 用来描述一个应用程序进程 通过mMainThread.getApplicationThread获取Binder本地对象这个对象就是给ActivityManagerService用来进程间通信的 mToken是一个binder代理对象 他是一个类型为ActivityRecord的Binder本地对象 这个对象用来维护对应的activity的活动状态和信息 Instrumention.execStartActivity 通过ActivityManagerNative来获得ActivityManagerService的代理对象 ActivityManagerProxy.startActity ActivityManagerNative类包含ActivityManagerProxy 里面调用mRemote.transact 就是向ActivityManagerService发送一个类型为START_ACTIVITY_TRANSACTION进程间通信请求 ActivityManagerService.startActivity ActivityManagerService实质是ActivityManagerNative的子类 里面包含一个ActivityStack 用来描述Activity组件堆栈 ActivityManagerService通过处理类型为START_ACTIVITY_TRANSACTION的进程间通信请求来执行启动Activity组件的操作 ActivityStack.startActivityMayWait 通过packageManagerService解析intent的内容并且保存到ResolveInfo中 传递到startActivityLocked继续执行 ActivityStack.startActivityLocked 在ActivityManagerService中每一个应用程序都使用一个ProcessRecord对象来描述 他会通过函数getRecordForAppLocked来获得 而每一个Activity组件是用ActivityRecord对象来描述 先通过堆栈mHistory获取launcher组件的ActivityRecord 再创建出目标对象mainActivity的ActivityRecord ActivityStack.startActivityUnCheckedLocked 这一步是检查启动的目标Activity的flag标志位 并且运行addtotask添加到组件堆栈中 ActivityStack.resumeTopActivityLocked 检查当前activity组件是否处于task最顶层并且处于非结束状态 activityStack会包含三种组件：当前激活的组件 上一次被中止的组件 正在被中止的组件 由于当前激活的是launcher组件 所以调用startPausingLocked来通知他进入中止状态 以便将焦点让给即将启动的mainActivity组件 ActivityStack.startPausingLocked ApplicationThreadProxy.schedulePauseActivity ApplicationThread.schedulePauseActivity 第11 12 13步都在传递这个pause的消息 ActivityThread.queueOrSendMessage H.handleMessage ActivityThread.handlePauseActivity 第14 15 16步就是launcher的ActivityThread处理ActivityManagerService发送给他的中止launcher组件的进程间通信请求 ActivityManagerProxy.activityPaused ActivityManagerService.activityPause ActivityStack.activityPaused ActivityStack.completePauseLocked 第17到20步是确定launcher组件进入中止状态 同时检查当前系统是否处于睡眠或者关闭状态 接着处理activity组件堆栈顶层的activity组件 ActivityStack.resumeTopActivityLocked 开始启动activity堆栈顶层组件 ActivityStack.startSpecificActivtyLocked ActivityManagerService.startProcessLocked 在ActivityManagerService中 每一个Activity组件都有一个用户id和进程名称 他在启动activity之前会检查id和进程名称是否存在对应的一个应用程序进程 无则创建 然后再通知新进程将activity组件启动起来 ActivityThread.main 新的应用程序在启动时主要做了两件事 第一件是在进程中创建一个ActivityThread对象 调用attach先activityManagerService发送启动完成的通知 第二件事 使当前进程进入到MainLoop消息循环中去 ActivityManagerProxy.attachApplication ActivityManagerService.attachApplication ActivityManagerService.attachApplicationLocked 第25 26 27 是binder代理对象向ActivityManagerService发送一个ATTACH_APPLICATION_TRANSACTION的进程间通信请求 ActivityStack.realStartActivityLocked ApplicationThreadProxy.scheduleLaunchActivity ApplicationThread.scheduleLaunchActivity 第28到30是在处理ActivityManagerService发出的SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION进程间通信请求 ActivityThread.queueOrSendMessage H.handleMessage LAUNCH_ACTIVITY消息传递到ActivityThread层 将接收到的额obj转为ActivityClientRecord对象 他描述的就是Activity组件 ActivityThread.handleLaunchActivity ActivityThread.performLaunchActivity 创建上下文Context 调用callActivityOnCreate MainActivity.onCreate 上面的35步通过代码一步一步追踪 描述了根Activity的启动过程 其实也就是应用程序的启动过程 子Activity组件在进程内的启动过程意思是通过mainActivity跳转到到subActivityInProcess 在Androidmanifest中声明process属性是同一个名称 所以他们属于同一进程 总的流程分四步 MainActivity组件先向ActivityManagerService发送一个启动SubActivityInProcess组件的进程间通信请求 ActivityManagerService首先将要启动的SubActivityInProcess组件的信息保存下来 然后再向mainActivity组件发送一个进入中止状态的进程间通信请求 MainActivity组件进入中止状态后 就会向ActivityManagerServices发送一个已进入中止状态的进程间通信请求 ActivityManagerService发现用来运行SubActivityInProcess的引用程序进程已经存在 就会将第2步保存下来的 SubActivityInProcess组件信息发送给该应用程序进程 总结子Activity组件在另一个进程启动的过程与在同一进程内启动的过程相类似 只不过多了一个创建新进程的通信请求 他们都围绕着ActivityManagerService做消息处理 共同点都是先保存要启动的组件的信息 然后向前边组件(launcher或者activity)发送中止状态的进程间通信请求 然后判断打开该组件的process是否存在 没有则发送创建的请求 创建完成后将前面保存的组件信息放到新启动的进程内 在这些过程中 activityManagerService ActivityThread ActivityStack 还有各种代理对象 出镜率最高 进程间通信的组件都是binder","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Activity","slug":"Activity","permalink":"http://luyaoming.com/tags/Activity/"}]},{"title":"Android系统源代码情景分析-读书笔记（二）","date":"2016-06-01T01:47:01.000Z","path":"2016/06/01/Android系统源代码情景分析-读书笔记（二）/","text":"主要介绍Binder进程间通信和aidl的使用 简要介绍了匿名共享内存的使用 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii Binder进程间通信系统Binder进程间通信主要涉及4个角色 Client Server ServiceManager BinderDriver 下面一幅图说明他们之间的关系 简介：Binder进程间通信是在OpenBinder的基础上实现的 采用CS的通信方式 提供服务的叫server进程 访问服务的进程为client进程 同一个server进程可以同时运行多个组件来向Client进程提供服务 这些组件称之为service组件 而同一个Client进程也可以同时向多个service组件请求服务 每一个请求对应一个client组件 称为service代理对象 由于每一个server进程和Client进程都维护一个binder线程池来处理进程间的通信请求 所以Client和server可以并发地提供和访问服务 server进程和Client进程的通信依靠运行在内核空间的binder驱动程序进行 binderDriver通过向用户暴露的一个设备文件/dev/binder 使得应用程序可以间接地通过他来建立通信通道 service组件在启动时 会将自己注册到一个service Manager组件中 以便Client组件可以通过serviceManager找到他 所以service组件是binder进程间通信的上下文管理者 同时由于他需要先普通的server和Client通信 所以他也是一个service组件只不过是一个特殊的service组件 引用老罗博客的文章归纳几点 Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中 Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open mmap和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 mmap是什么 mmap是一个函数 进程打开/dev/binder文件之后会通过这个函数 把这个设备文件映射到进程的地址空间 为了为进程分配内核缓冲区 以便用来传输进程间通信数据 内核缓冲区有两个地址 分别是用户地址和内核地址 这两个地址是线性对应的 当binder驱动程序需要将一块数据传输到一个进程时 他可以先把这块数据保存在为该进程分配的一块内存缓冲区中 然后再把这块缓冲区的用户空间地址告诉进程 最后进程可以访问里面的数据 这样做的好处是不需要将数据从内核空间地址拷贝到用户空间从而提高数据传输效率 binder库都是通过c/c++来实现 下面分析binder进程间通信的java接口通过java层的一些代理对象 用JNI的方法来调用binder库的c++接口 从而使java层具有binder进程间通信的能力 ServiceManagerProxy是ServiceManager的代理对象 里面包含mRemote成员变量实际指向的就是BinderProxy binderProxy实现了IBinder接口 内部包含一个int类型的mObject 实质上指向了c++层的一个Binder代理对象 这样就可以将一个java代理对象与c++层中的一个binder代理对象关联起来 即可以通过c++层的binder代理对象来实现java服务代理对象的功能 那么 如何创建这个BinderProxy呢其实 他是由ServiceManager中的getIServiceManager来创建的 serviceManager中包含一个serviceManagerProxy的静态成员变量 他里面的方法getService addservice等都通过代理对象来实现 而getIServiceManager是通过调用ServiceManagerNative的asInterface来提供 这个serviceManagerNative继承自Binder Binder里包含的mObject实质上指向的就是真正的C++层的binder本地对象 这样 就可以吧c++层的binder本地对象与java层的服务关联起来 java层的Binder通过mObject指向一个Native层的javaBBinderHolder对象 Native层的JavaBBinderHolder对象通过mBinder成员变量指向一个Native的javaBBinder对象 Native的javaBBinder对象又通过mObject变量指向一个java层的Binder对象 ActivityManagerService响应请求的流程是 binder客户端通向binder驱动程序发起一个请求 binder驱动程序通过过onTransact函数向Native层的javaBBinder发送请求 而JavaBBinder通过执行exeTransat函数向java层的binder发送请求 java层的binder通过ActivityManagerNative来回调请求 而ActivityManagerNative又通过他的子类如ActivityManagerService来回调请求 AIDLAIDL进程间通信实际上就是运用binder进行进程间通信下面出一个使用的范例 主要分三个步骤去实现aidl例子的代码转载自 http://www.cnblogs.com/linlf03/p/3192025.html 创建AIDL服务端 创建AIDL客户端 客户端调用服务端提供的服务接口 第一步 先创建一个aidl文件 IStudentService.aidl interface IStudentService&#123; Map getMap(in String test_class,in Student student); Student getStudent();&#125; 注意 Student需要实现Parcelable接口进行序列化 第二步 编译上述的aidl文件 在gen目录下生产一个IStudentService.java文件 里面会包含stub和proxy接口 然后实现stub接口里面的方法 供客户端调用 把它包含进service中 通过绑定的方式返回这个binder 至此一个服务端就创建完成 public class StudentService extends Service&#123;@Overridepublic IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub return new StudentServiceImple();&#125; public class StudentServiceImple extends IStudentService.Stub &#123; @Override public Student getStudent() throws RemoteException &#123; Student student = new Student(); student.setAge(25); student.setName(\"Zhang san\"); return student; &#125; @Override public Map getMap(String test_class, Student student) throws RemoteException &#123; // TODO Auto-generated method stub Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"class\", \"06109091\"); map.put(\"age\", student.getAge()); map.put(\"name\", student.getName()); return map; &#125; &#125; &#125; 在manifest中注册这个service 可以通过intent启动​&lt;service android:name=\".StudentService\" android:exported=\"true\" android:enabled=\"true\" android:process=\":remote\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.studentservice.IStudentService\"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/service&gt; 第三步 创建AIDL客户端把刚刚在服务端建的java文件和外层的包拷贝到客户端src目录下 主要需要包名一致 服务端的位置-&gt; 客户端的位置-&gt; 第四步 最后 编写客户端调用代码 public class MainActivity extends Activity &#123;private Button btn1, btn2; private IStudentService stuService = null;private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub stuService = IStudentService.Stub.asInterface(service); &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn1 = (Button)findViewById(R.id.button1); btn2 = (Button)findViewById(R.id.button2); btn1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub bindService(new Intent(\"com.example.studentservice.IStudentService\"), serviceConnection, Context.BIND_AUTO_CREATE);//; &#125; &#125;); btn2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub StringBuilder sb = new StringBuilder(); try &#123; if (stuService == null) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"Error\") .setMessage(\"stuService is null\").setPositiveButton( android.R.string.ok, null).show(); return; &#125; sb.append(\"学生名称为：\" + stuService.getStudent().getName() + \"\\n\"); sb.append(\"年龄为：\" + stuService.getStudent().getAge() + \"\\n\"); sb.append(\"map 对象内容为如下：\" + stuService.getMap(\"中国\", stuService.getStudent()) .toString()); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; new AlertDialog.Builder(MainActivity.this).setTitle(\"调用外部服务\") .setMessage(sb.toString()).setPositiveButton( android.R.string.ok, null).show(); &#125; &#125;); &#125;&#125; Ashmem匿名共享内存Ashmem是应用程序之间共享数据的一种方式 系统中所有的匿名共享内存都由ashmem驱动程序负责分配和管理 为了方便应用程序使用匿名共享内存 Android系统在运行时库cutils中提供了c接口来访问ashmem驱动程序 同时 又在应用程序框架层提供了更高级的c++和java接口来访问运行时库cutils的匿名共享内存c接口 在c++层主要使用MemoryBase和MemoryHeapBase来使用 而java层主要使用MemoryFile来使用匿名共享内存 而在运行时库cutils中主要提供了三个函数ashmem_create_region ashmem_pin_regin ashmem_unpin_regin 来访问Ashmem驱动程序 ashmem驱动程序在启动时 会创建一个dev/ashmem设备文件 cutils中的匿名共享内存c接口就可以通过文件操作函数open和ioctl来访问ashmem驱动程序 ashmem的应用应用程序之间共享数据一样需要需要client和server两端的创建 例如定义一个aidl interface IMemoryService&#123; ParcelFileDescription getFileDescription(); void setValue(int val);&#125; 通过aidl pakageName/IMemoryService.aidl 编译后会得到一个IMemoryService java文件 通过继承IMemoryService.Stub并实现其中的两个方法 得到一个MemoryService 服务组件 服务组件内创建MemoryFile 再创建应用组件Service 在onCreate时创建该MemoryService服务组件 并通过ServiceManager.addService的方式添加这个service 也可以通过onBind的方式返回这个service 然后创建客户端Activity 通过IMemoryService.Stub.asInterface(ServiceManager.getService(…))的方式获取服务 也可以重写onServiceConnected来获得binder代理对象 然后就可以直接调用getFileDescription和setValue这两个方法了 可以获得ParcelFileDescription以下简称fd 通过fd来构造一个MemoryFile MemoryFile在创建的过程中 会将文件描述符fd对应的匿名共享内存映射到本进程的地址空间 也就是在MemoryService服务中创建的那块匿名共享内存映射到本进程的地址空间 共享的原理匿名共享内存能够在不同的进程中共享的奥妙在于 这两个进程分别有一个文件描述符fd1和fd2 他们指向了同一个文件结构体file1 而这个文件结构体又指向了一块匿名共享内存 这时候 如果这两个进程的文件描述符fd1和fd2分别映射到各自的地址空间 那么他们会把同一块匿名共享内存映射到各自的地址空间 从而实现不同的进程中共享同一块匿名共享内存","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"Binder","slug":"Binder","permalink":"http://luyaoming.com/tags/Binder/"},{"name":"AIDL","slug":"AIDL","permalink":"http://luyaoming.com/tags/AIDL/"},{"name":"Ashmem","slug":"Ashmem","permalink":"http://luyaoming.com/tags/Ashmem/"}]},{"title":"Android系统源代码情景分析-读书笔记（一）","date":"2016-05-30T11:11:26.000Z","path":"2016/05/30/Android系统源代码情景分析-读书笔记（一）/","text":"从今天开始啃这本超厚的书 第一篇想写下智能指针 Android系统源代码情景分析 作者： 罗升阳– –读书笔记 by asii 智能指针出现的原因： Android系统源码中有相当一部分使用c或c++编写 c和c++相对java的一大特点是使用指针 指针使用不当 轻则内存泄漏 重则系统崩溃 Android提供了c++智能指针来避免出现指针使用不恰当的问题 智能指针是一种能够自动维护对象引用计数的技术 他本身不是指针 他是一个对象 他的使用方法是 在引用对象构造时 引用计数加1 当引用对象析构时 引用计数减1 当引用计数变为0时表明该对象不再被引用可以释放掉 然而考虑一个经典的引用问题 类似垃圾回收问题 A引用B B也引用A 当A不再使用时就要析构不再引用B （析构就是c中的free和置空） 然而A还不能被回收 因为B还在引用A 两个资源互相等待对方释放 就像我们常见的死锁问题 只用这两个对象确定为同时不再使用时才能被两两释放 引用计数计数解决这个问题 采用强引用和弱引用两种计数方式 利用了一个技巧 对象的生命周期只受强引用计数控制 首先 将两两关联的对象划分为 父子 和 子父 关系 父对象通过强引用来引用子对象 子对象通过弱引用来引用父对象 回归上面的引用问题 当A不再使用时 需要释放A 由于B是通过弱引计数来引用他的 所以对象A的生命周期不收B的影响 此时A可以安全地被释放 A释放后同时也会释放对B的强引用计数 相反地 加入先要释放B 那么可以直接在A中手动释放对B的强引用计数就可以 要注意的一点是B对象在使用A时 需要先判断A已经被释放 通过将对A的弱引用升级为强引用的方式成功否来判断A是否已经被释放 如果A已经被释放那么B不能再使用A Android系统提供了三种类型的c++智能指针 轻量级指针 使用简单的引用计数计数 就是加1减1 强指针和弱指针 使用强引用计数与弱引用计数技术","categories":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"智能指针","slug":"智能指针","permalink":"http://luyaoming.com/tags/智能指针/"}]},{"title":"c语言程序设计现代方法-读书笔记（二）","date":"2016-05-21T11:33:31.000Z","path":"2016/05/21/c语言程序设计现代方法-读书笔记（二）/","text":"主要介绍c语言的struct union 动态内存分配 还有c的标准库等 c语言程序设计现代方法 原著：K.N.King 翻译：吕秀峰 – –读书笔记 by asii #深入 struct是c中类似于javabean的东西 他的定义如下 struct&#123; int num; char name[NAME_LEN+1]; int on_hand;&#125;part1 = &#123;528，“disk driver”,10&#125;,part2;strct&#123; char name[NAME_LEN+1]; int num; char sex;&#125;employee1,employee2; 这两个struct可以同时存在不冲突 结构在内存的存储是按变量的声明顺序存储的 part1和part2是结构1的变量 employee1和employee2是结构2的变量 可以对part1声明的同时进行初始化 注意顺序必须与声明的顺序一样 如果只声明前一个 剩下的都以0作为初始值 访问结构的成员 跟java的一样 可以对他临时进行赋值 part1.num = 1;也可以直接对成员进行自增如 part1.num++ 相当于（part1.num）++ 可以使用结构进行赋值 例如 part2 = part1; 这样part2的num和part1的num取得一样的值 其他都是 我们知道数组不可以直接进行赋值a[10] = b[10]是不合法的 但是struct可以 所有有个讨巧的方式struct{int a[10]}a1,a2; a1=a2; 那么两者的变量a[]数组的元素也一样了struct不能使用==和!=这种运算符 与javabean不同的是 struct竟然可以在没有名字的前提下存活 当然 他也有给struct定义名字的写法 在声明的时候就可以给定名字​struct part&#123; int num;&#125; ;//注意上面的最后一个;是不可以省略的 他表示struct定义的结束//下面开始声明变量 不能省略struct关键字struct part part1,part2;//当然也可以定义和声明合拼在一起struct part&#123; int num&#125; part1,part2;//第二种给struct命名的方式typedef struct&#123; int num;&#125;Part;//Part就是类型名 结构可以包含结构 数组可以包含结构 结构也可以包含数组 比较常用的读入一行的写法​#include &lt;ctype.h&gt;#include &lt;studio.h&gt;#include \"readline.h\"//读入一行 除了遇到换行符或者文件结尾才结束读int read_line(char str[],int n)&#123; int ch,i = 0; while(isspace(ch = getchar())) ; while(ch != '\\n' &amp;&amp; ch != EOF)&#123; if(i &lt; n)&#123; str[i++] = ch; &#125; ch = getchar(); &#125; str[i] = '\\0'; return i; &#125; 联合union具有与struct相似的结构形式 都可以包含各种类型的成员变量 不同点在于结构struct的成员存储在单独的不同的内存地址中 而union是存储在同一内存地址中 这些成员在这个空间内相互彼此覆盖 可以理解union的长度为最大成员变量的长度union这种存储方式带来的后果是 赋予新值也会改变所有其他成员的值​union &#123; int i; float f;&#125;u; 访问跟struct一样 u.i = 8; u.f = 1.1; 当第二句执行时 u.i的值就会被清掉了 因为u.f的地址覆盖了u.i的地址 同样地再运行u.i = 2; 那么u.f的值也会变得无意义 所以union是存储i或者存储f的地方 而struct是同时存储i和f的地方 union只有第一个成员可以获得初始化 相似地可以表示 u = {1}; union看似用处不大 但用在数组时候就非常让人惊奇 因为数组一般都只能保存一种类型的变量 但是联合是他保存不同类型变量成为可能 例如一个联合数组 union u array[100] 可以吧数组的第一个元素存储整型 array[0].i = 2; 第二个元素存储浮点 array[1].f = 1.1; c中枚举与java的相类似​enum suit &#123;CLUBS,DIAMONDS,HEARTS,SPADES&#125;;//声明enum suit s1,s2; 可以把结构的声明放在头文件中来共享struct 在struct中包含union和union中包含struct都是经常的事情 动态分配内存在中有三个函数 malloc 分配内存块但是不对内存块进行初始化 calloc 分配内存块 并且对内存进行清除 realloc 调整先前分配的内存块 //比较下面两种情况 str对内存的管理char *str = malloc(sizeof(int));strcpy(str,\"yao\");printf(\"%s\",*str);*str = \"yao\";printf(\"%s\",*str);//上面两种方式对str赋值 第一种方式使用strcpy函数将“yao”拷贝入内存中 str还指向堆内存的首地址 依然可以通过str操纵堆内存 第二种方式 直接让str指向了常量 刚才开辟的内存已经不属于str管理了 开辟的堆内存已经丢失 泄漏了（没有free） 所以调用 str[1]=\"c\";会出错 因为不可以直接改变常量区的值 一般的字符串放在数组中 很难动态分配大小 可以使用malloc对字符串分配内存p = malloc(n+1);malloc本来返回void 的指针类型 他可以转型为其他所有指针类型 例如char p 在中的free函数可以用来释放内存空间​p = malloc(...);q = malloc(...)'free(p);p = q; 从p = q;开始 由于p指向了q的内存块 那么原先分配的内存块没有了指向 需要释放掉 就是用了free函数 内存返回给堆 当调用free后 尝试再使用指针 会出错 这叫悬空指针 一般 free(p)操作后 都会p=NULL;因为free操作意思是p指向的内存已经不再受p管理 但是p还保留原来的指向 不能对p进行两次free 可以用struct构建一个链表 所谓链表 就是包含一个指针 指向下一个数据项 这里的数据项是struct 所以这么写​struct node&#123; int value; struct node *next;&#125;;//声明第一个变量struct的指针为first first指向这个NULL 链表为空struct node *first = NULL;//声明一个新的节点struct node *new_node;//为节点分配空间new_node = malloc(sizeof(struct node));//(*new_node).value = 10; 使用-&gt;运算符可以替换*和.号 意思是new_node指向的变量的成员变量赋值10 new_node-&gt;value = 10;//在第一个节点前面插入一个新的节点 first指向了NULL 所以new_node指向了NULLnew_node-&gt;next = first;//需要把第一节点设定为first 此时第一个节点为new_node 这样first和new_node都指向了同一个节点first = new_node;//创建一个新的节点 new_node变量指向了一个新的内存区域 而first还保留之前的指向new_node = malloc(sizeof(struct node));//赋值20new_node-&gt;value = 20;//把这个节点放置在第一个节点前面 另next指向第一个节点就行了 first指针保留着第一次创建的节点的指向 所以这里指向first就行了new_node-&gt;next = first;//最后把first指针指向最新插入的节点first = new_node; ​可以用函数总结上面的插入节点的过程 list为第一个节点的指针 n为值 struct node *add_to_list(struct node *list,int n)&#123; struct node *new_node; new_node = malloc(sizeof(struct node)); if(new_node == NULL)&#123; printf(\"创建节点失败\\n\"); exit(EXIT_FAILURE); &#125; new_node-&gt;value = n; new_node-&gt;next = list; //注意这里 如果使用list = new_node; 试图改变list的指向是不可行的 因为*list是值传递 不能改向了 除非有指针指向这个list指针 return new_node; &#125;//调用 first作为一个中间变量int main()&#123; struct node *first = NULL; first = add_to_list(first,10); first = add_to_list(first,20); &#125;使用for循环遍历一个链表的惯用写法for(p=first;p!=NULL;P=P-&gt;next)查找某个value为n的节点并删除 cur指当前节点 pre指前一节点struct node *delete_from_list(struct node *list,n)&#123; struct node *cur,*prev; for(cur=list,prev = NULL; cur!=NULL&amp;&amp;cur-&gt;value!=n; pre=cur;cur = cur-&gt;next) ; if(cur == NULL)&#123; return list; //未找到n &#125; if(prev == NULL) //n在第一个节点 list = list-&gt;next; else //找到节点后 删除节点 pre-&gt;next = cur-&gt;next; free(cur); return list; &#125; 还可以让指针指向指针 使用之前链表添加节点的例子 *list表示指向list的指针 去掉了return 直接让list指向最新的节点 void add_to_list(struct node **list,int n)&#123; struct node *new_node; new_node = malloc(sizeof(struct node)); if(new_node == NULL)&#123; printf(\"创建节点失败\\n\"); exit(EXIT_FAILURE); &#125; new_node-&gt;value = n; new_node-&gt;next = *list; *list = new_node; &#125; 指针还可以指向函数 也叫函数指针 例如定义一个指向函数的指针 void (pf)(int) pf指向任何一个带有int型实际参数的 返回void的函数 如果f是符合这样的函数 可以把pf=f；所以可以这么调用f函数`(pf)(i) `或者简单写成pf(i) 函数指针经常用在函数回调上 函数指针可以包含在数组内 例如 void (file_cmd[])(void)={new_cmd,open_cmd,close_cmd}; 指针file_cmd可以直接调用函数`(file_cmd[n])()` 或者写成 file_cmd[n] 声明的种类 存储类型 auto static extern register 必须把它放置在声明中的首要位置 最多只能有一个 类型限定符 const volatile 可以声明0个 一个或两个 类型说明符 void char short int float …等都是类型说明符 包括结构 联合 枚举 用typedef创建的类型也是 必须跟在存储类型的后面例如 static float x,y,*p; 还有 const char mouth[];还有extern const unsigned long int a[10] 变量的默认存储期限 作用域 链接 都依赖于变量声明的位置例如 int i; i变量定义在文件内方法外 那么属于静态存储期限 文件作用域 外部链接void f(void){int j;} j变量定义在方法内部 那么属于自动存储期限块作用域 无连接 extern存储类型可以使几个源文件共享同一变量 static 存储类型定义在外部 本质上隐藏了他所在声明文件内的变量 只有出现在同一文件中的函数可以看到此变量 有点像java中的private声明 这是一种信息隐藏技术 在块内定义static 可以让他值进行一次初始化 register存储类型可以要求变量存储在寄存器中 寄存器中没有地址 不能使用&amp;变量 register变量一般用在频繁使用的变量上 现在的编译器一般会自己决定把变量存储在哪执行更快​const不同于宏 不能用于常量表达式 例如const int n=10; int a[10];是错的 对于声明符遵循两个原则 第一个原则 始终从内到外读声明符 第二个原则 先后* 例如在标记符前面 而标记符后面跟着[] 那么标记符是数组而不是指针 如int ap[10] 这是一个存储int型指针的数组 如果在标记符前面 而后面跟着()那么标记符是函数不是指针 如float fp(float) 表示一个返回float指针的接受float参数的函数fp fp是函数名 void (*pf)(int) 表示一个返回void 接受int实际参数 标记符是指针的 指针函数 pf是指针名 c语言中的左移&lt;&lt; 与 右移&gt;&gt;运算符 操作数可以是任意整形或者字符型的i&lt;&lt;j的值是将i中的位左移j位后的结果 i&lt;&lt;2 相当于i * 2的2次方 i&gt;&gt; 相当于i/2的2次方（去除小数部分） 移位运算符优先级低于算数运算符 其他按位运算符 ~是按位求反就是1变0 0变1 &amp;是按位与就是两个都为1才为1 其余都为0 ^是按位异或就是10为1 00为0 11为0 |是按位或就是10为1 00为0 11为1异域运算可用作简单加密 之前我们知道在宏中 我们可以声明简单的函数 而当我们在真是的函数声明时 出现与宏相同的名字时会优先调用宏的定义 使用undef来取消宏的定义 简单概述标准库 诊断 仅包含assert宏 通过插入该宏检查程序状态 一旦检查失败程序终止 字符处理 包含用于字符分类以及大小写转换的函数 错误 检查错误用的 浮点型的特性 描述浮点类型的宏 包括值得范围和精度 整形的大小 整数型和字符型特性的宏 包括最大值最小值 本地化 与本地化得相关的行为方式如货币格式 日期时间表示形式 字符集等等 数学计算 提供大量用于数学的计算的函数 包括三角函数 双曲函数 指数函数 对数函数 其中大部分函数使用double型的实际参数 并且返回double的值 非本地跳转 提供setjmp函数和longjmp函数 setjmp函数会标记程序中的一个位置 随后用longjmp返回被标记的位置 这些函数可以用来从一个函数跳转到另一个函数中 绕过正常的函数返回机制 提供异常情况 信号处理的函数 raise函数产生一个信号 signal函数令信号发送后自动调用signal函数设置的函数 可变实际参数 提供函数可以处理不定个数个参数的工具就像printf和scanf函数 常用定义 提供了经常使用的类型和宏的定义 输入输出函数 包含顺序读写 随机读写 常用实用程序 将字符串转为数 产生伪随机值 执行内存管理任务 与操作系统通信 执行搜索与排序 对多字节字符以及字符串进行操作 字符串处理 对字符串操纵的函数 复制 拼接 比较 搜索等 日期和时间 获取时间与日期 多种方式显示时间 看到第22章 未完持续","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c语言","slug":"c语言","permalink":"http://luyaoming.com/tags/c语言/"}]},{"title":"c语言程序设计现代方法-读书笔记（一）","date":"2016-05-17T13:12:07.000Z","path":"2016/05/17/c语言程序设计现代方法-读书笔记（一）/","text":"主要介绍c语言里的运算符 指针 数组 宏等 c语言程序设计现代方法 原著：K.N.King 翻译：吕秀峰 – –读书笔记 by asii 基础从java角度看c 对于c程序 将c代码转变为可执行形式的步骤为1 预处理指令 2 编译 3 链接 %d 是int类型的占位符 %f是float型的占位符默认小数点后6位 %.2f就是小数点后2位 int a,b,c=10; 这个声明中 只有c被初始化 scanf(“%f”,&amp;x) 读取一个float 存入x中 f就是format的意思 printf的f也是scanf(“%d,%f”,&amp;x,&amp;y) 记得输入时 要输入 1，2 这样的格式 中间不能有空格 格式需与双引号内的格式一致 每一次读取到不正确的字符时 都会保留给下一次读取 定义常量 #define ABC 10 定义一个常量数值为10 这是一个宏定义 #define是预处理指令 宏定义可以有表达式但是必须用括号 如#define ABC (1+1) 后面没有分号一句完成 c语言区别大小写 标准c对标记符没有最大长度限制 其实是记住前31个字符 命名时不能使用关键字 列举下jaca中没有的关键字 auto struct register typedef extern union const unsigned signed sizeof 另外最好别使用以下划线开头的标记符 printf(“%f %d\\n”,i,x)其中i是int型 x是float型 那么输出的记过是一个float型和一个int型 但是因为i和x的位置对调了 所以输出的他们的值都是无意义的 %g用于不确定大小或者数字变化范围的情况 %i可以匹配8进制 10进制 16进制 %5d int型占5位 往左边占 %-5d int型占5位 往右边占 %5.3d int型占5位 至少包含三个数字 往左边占 数字右对齐 %10.3f float型占10位 保留3位小数 右对齐 %10.3e 指数型占10位 保留三位小数右对齐 %-10.3g int型占10位 左对齐 不应该以聪明才智和逻辑分析能力来评判程序员 而要看起分析问题的全面性 有符号的int的最大整数是2的15次方-1 无符号（unsigned）的最大整数是2的16次方-1 int的取值范围（-32768到32767）unsigned int的取值范围(0到65535) 除非特别说明 默认所有整数都是有符号的 如long signed int和long int是一样的类型 并且 顺序无要求 如long signed int和signed long int是一样的 在16位的机器上short Int和int的取值范围是一样的 在32位的机器上 int和long的取值范围是一样的 所以为了可移植性 对不超过32767的整数采用int 对其他的整数采用long int 进制 u表示10进制 o表示8进制 x表示16进制 “%hd”表示short int “%ld”表示长整型 使用#included 中定义了每种整型的最大值和最小值的宏 浮点常量默认以双精度的形式存储 scanf(“%lf”,&amp;x)读取double类型 注意printf不支持“%lf”的写法 然而 scanf(“%Lf”,&amp;x)读取long double printf(“%Lf”,x)是合法的 char的有符号取值是（-128到127）无符号的取值范围（0到255）chat可以与int直接运算 把小写转大写 ch = ch - ‘a’ + ‘A’;getchar()和putchar()用来读写字符 while(getchar() != ‘\\n’)… 表示直到用户输入换行符位置一直根据用户输入的字符执行循环体 sizeof()会根据机械的位数不同而不同 表示存储指定类型值所需的空间大小 typedef 定义一种类型 跟java的类有些相似但是不同 例如typedef double dollars 定义dollars代表double类型 使用double i;和使用dollars i;意义是一样的 自定义函数如果出现在main函数之后 会无法识别 所以需要声明函数例如float average(float a,float b); 如果函数是放在main函数之前 可以不声明 c允许形式参数和实际参数的类型不一样 会隐式地自动转型 但是记得要函数声明或者函数前置 使用函数传递数组时 只能忽略第一维的长度 列的长度不能忽略 函数中return 可以返回与设定函数时不一样的类型 会以return的类型为准 什么都不返回时可以return; 退出函数 可以使用exit(0);也可以使用 return 0; 可以在a函数内声明b函数 但是b函数只能在a函数内有效 到了别的函数要想调用需要先声明 可以倒不如在外面声明函数 但是c的宽松允许第一种做法 指针变量p存储变量i的地址时 就说p指向i 指针就是地址 指针变量是只存储地址的变量 int *p;表示p是指向int型对象的指针变量 &amp;是取地址运算符 星号是间接寻址运算符 int i,*p; 然后 p = &amp;i ;就是将i变量的地址给p指针 int i,*p = &amp;i;相当于做了两步 这是简便写法int i,*p;p = &amp;i; int p = &a; printf(“p=%p”,p);%p代表打印指针 就是打印a的地址printf(“p=%p”,p++); 重新打印出的地址比原来p的地址大4个字节 因为int占用4个字节 同样如果p指向char 类型 p++的地址就会比原来大2个字节 j=&i;是合法的 `i=1;p=&i;p=2;那么i=2,*p=2` 注意 不要把间接寻址运算符用于未初始化的指针变量 例如int *p;※p=1;是错的 可以使用=进行指针的复制 例如 //先声明int i,j,*p,*q; //初始化指针p的指向p=&amp;i;//对指针进行复制 此时 p和q指向了相同的地址 都是i的地址q=p;*p=1； 在未出现指针之前 下面交换两个数的值的写法是错误的​void swap(int,int);main()&#123; int a=1,b=2; swap(a,b); printf(\"a:%d,b:%d\",a,b);&#125; void swap(int x,int y)&#123; int temp; temp =x; y = x; x = temp;&#125;//上面函数打印得到值是a:1,b:2//使用指针 就像java中改变引用的值 这样交换才是正确的void swap(int *,int *);main()&#123; int a=1,b=2; swap(&amp;a,&amp;b); printf(\"a:%d,b:%d\",a,b);&#125;void swap(int *x,int *y)&#123; int temp; temp =*x; *x = *y; *y = temp;&#125; 注意*x=*y 才是改变x指针指向的值 如果x=y只是让x指向y的指向地址 const 可以修饰形式参数 就像java中的final一样​void f(const int *p)&#123; int j=1; *p = j;//这样写 编译器会提示不能被修改&#125;//然而 可以这么写void f(const int *p)&#123; int j=1; p = &amp;j;//这样写 是合法的&#125;//还有种情况 const放在p前面 保护的是p指针本身 不可以再指向别的地址void f(int * const p)&#123; int j=1; *p = 0;//合法 p = &amp;j;//不合法&#125;//如果两个都需要保护 即既要保护*p也要保护pvoid f(const int * const p)&#123; int j=1; *p = 0;//不合法 p = &amp;j;//不合法&#125; 函数可以返回指针 但是不要返回局部变量产生的指针 指针不单只可以指向普通变量 还可以指向数据变量 例如int a[10],*p; p = &amp;a[0];可以使用指针的加减法运算代替数组下标的运算 接前面对的p+3表示a[0+3]当然需要该下标存在才能正确表示 两个指针相减表示数组之间的距离 用来计算数组中的元素个数 要注意的是只有指针指向数据元素 他的元素才有意义 而且两个指针必须指向同一数组 使用指针代替数组下标进行运算的实例​int getSum(int a[],int len)&#123; int sum = 0; for(int i=&amp;a[0]; i&lt; &amp;a[len];i++)&#123; sum += *i; &#125; return sum;&#125;//更简便的写法int getSum(int a[],int len)&#123; int *p = &amp;a[0]; while(p &lt; &amp;a[len])&#123; sum += *p++; &#125;&#125; 可以用数组的名字作为指向数组第一个元素的指针 例如int a[10]; *a = 1;相当于a[0]=1; 那么※(a+1)=2;相当于a[0+1] = 2;于是有下面的写法​//求和for(p = a;p &lt; a+len; p++)&#123; sum += *p;&#125;//但是不能把数组名指向其他地方while(*a != 0)&#123; a++;//错误 试图将a指向a+1 但是可以吧a赋值给指针变量再改变指针变量&#125;int *p = a;while(*p != 0)&#123; P++;//合法&#125; 指针也可以表示二维数组 例如 int *p = &amp;a[i][0];相当于 p = a[i];指针p指向的是二维数组第i行的第一个元素 数组和指针之间还没做到完全可以互换 例如使用当p = &amp;a[0];时 sizeof(a)和sizeof(p)得到的结果不一样 c中的字符串使用字符数组来存储 例如“abc” 存了4个字符包含最后一个/0 作为结束字符如果定义一个比字符串字符个数多时 如char data[9] = “june 14”;后面将会包含两个/0 所以定义数组来表示字符串时要确保数组的给定长度要大于实际字符串的长度 也可以不定义长度留空 如char date[]=”june 14”;编译器自动计算长度 注意c中的单个字母的字符串“a”和字符‘a’是不一样的 前者通过数组来存储 字面量“a”用指针来表示 而‘a’是用整数来表示 未初始化的指针变量不能作为字符串修改值 比较char date[] = “abc”;和char date = “abc”;有什么不同 当声明为指针时不能修改字符串字面量例如 (date+1) = ‘a’不合法 但是date[1] = ‘a’是合法的 第二点：声明为数组时date是数组名 声明为指针时 date是变量 可以改变指向其他字符串 字符串在printf函数中 用%s来表示 转换说明%m.ps其中m,p都是数字 表示字符串的前p个字符在大小m的域内显示 可以用函数puts(str)来代替printf函数 会自动添加换行符 比较特别的是scanf(“%s”,str)其中str是数组名 不需要再str前添加&amp; 因为编译器自动把它当成指针来处理 使用gets(str)函数可以达到接受用户输入的效果 需要注意的是gets遇到空白字符不会预留给下一次输入 而是直接把它计入字符串内 直到遇到换行符 char str1[10]; str1 = “abc”;是错误的 str为数组的指针 这句解析为一个指针对另一个指针的赋值 但是char str1[10] = “abc”;是合法的 在声明中=不是赋值运算符 另外判断if(str1 == str2)会一定得到0 因为比较的是指针 就是内存地址 函数库里的string操作包括 strcpy 复制函数 使用：char strcpy(char str1,const char *str2)意思是讲str2的字符复制到str1 str2指向的字符始终不变 现在可以吧“abc”给str1了 strcpy(str1,”abc”); strcat函数 char strcat(char s1,const *s2); 把字符串s2的内容追加到字符串s1的末尾 并且返回字符串s1的指针 strcmp函数 int strcmp(const char s1,const char s2);比较s1和s2的大小 这个跟java的直接比较相似（像if(s1&lt;s2)）对字符串内单词的逐个比较 在 ASCII字符集中 记住所有大写字母都小于小写字母 数字小于字母 空格最小 size_t strlen(const char *s)求字符串的长度 size_t是无符号整数 可以是int也可以是long int 都是unsigned 使用strlen测量字符串长度时不会考虑数组的大小 而只会返回字符串实际的字符个数 sprintf(day_str,”%2d”,day);将int类型写入到字符串 习惯用法 while(*s)s++; 查找字符串结尾的空字符 此时s指向了空字符 预处理指令可以放在程序中的任何地方 指令换行要加 \\ 符号 注意宏定义 不要添加附加的标点符号 除了开头的# 宏还可以做简单函数的使用 例如带参数的宏​#define MAX(x,y) ((x)&gt;(y)?(x):(y)) main()&#123; int i = MAX(a,b);&#125; 宏还可以用来定义一个函数 #define GENERIC_MAX(type) type type##_max(type x,type y) &#123; return x&gt;y ?x:y; &#125; 使用##是粘着符号 当使用 GENERIC_MAX(float)时 预处理器会展开这段代码为float float_max(float x,float y){return x&gt;y?x:y;} 一个宏可以应用另一个宏 例如#define PI 3.14 #define CIRCLE(r) (PI 2 (r)) 注意每次使用宏参数时 要加圆括号（） 取消一个宏定义 #undef FUNC 删除FUNC的宏定义 以后可以跟FUNC新的宏定义 宏就相当于java中的工具类 一处编写 到处使用 一次修改 到处修改 条件编译 根据预处理器所执行的测试结果来包含或者排除程序的片段例如 #if 和#endif语句 #define DEBUG 1#if DEBUGprintf(\"value of i:%d\\n\",i);#endif 在上述处理过程中 测试指令会测试DEBUG的值 当DEBUG&gt;0时 预处理器会将这个printf函数保留在程序中 否则会让这些代码都消失（包含if指令） defined 运算符用来判断宏是否被定义过 定义过返回1 否则返回0 经常跟#if指令一起使用​#if defined(DEBUG)...#endif 仅当DEBUG被定义成宏时 #if和#endif之间的代码会被保留在程序中 使用#ifdef指令与 使用#if defined指令一样 而#ifndef 等价于#if !defined 为宏提供默认定义​#ifndef BUFFER_SIZE#define BUFFER_SIZE 256#endif 如果BUFFER_SIZE没有被定义过 就将他的定义默认为256 指令#include “文件名” 用来引入自己编写的文件 c语言自身库的头文件用的是&lt;文件名&gt; 头文件可以包含另一个头文件 并引用里面的变量或者类型 这是嵌套包含 当嵌套保护遇到类型定义时会发生编译错误 解决方案是添加头文件保护 就是在类型定义前添加个开关#ifndef 这样可以避免重复编译 带main方法的c文件的文件名就是程序的名字 unix系统通过makefile，使用make工具构建程序 mac有xcode自动编译程序文件","categories":[{"name":"C","slug":"C","permalink":"http://luyaoming.com/categories/C/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"c语言","slug":"c语言","permalink":"http://luyaoming.com/tags/c语言/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（十）","date":"2016-05-17T06:10:01.000Z","path":"2016/05/17/Android源码设计模式解析与实践-读书笔记（十）/","text":"读到这里 已经接近这本书的尾声了 作者在这里分享了设计模式以外的东西–框架 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 无论mvc还是mvp 都是一种框架模式 不是设计模式 框架里可以体现很多各种设计模式 框架模式 通常是对代码的重用（意思是可以写少些代码）而设计模式 是对设计的重用 换一种说法 框架 是面向一系列相同行为代码的重用 而设计师面向一系列相同结构代码的重用 正题 mvp有三个元素 m – model 数据的存取 v – view 用户界面 通常指activity fragment 或者某个view控件 他包含一个presenter成员变量 p – presenter 主持人（交互中间人）作为沟通view和model的桥梁 将包含view接口和model 主要的业务逻辑写在这里 例如什么请求服务器 读取缓存数据等 基本的mvp的写法​public class ArticlePresenter&#123; //view ArticleInterface mArticleView; //model ArticleModel mArticleModel = new ArticleModelImpl(); //model2 ArticleAPI mArticleAPI = new ArticleAPI(); //从构造函数接受view 建立与view的联系 让view包含presenter 让presenter包含model 就是这样把三者建立关系的 public ArticlePresenter(ArticleViewInterface viewInterface)&#123; mArticleView = viewInterface; &#125; //从服务器中获取数据 通过model来访问 通过view来显示 public void fetchArticles()&#123; mArticleView.showLoading(); mArticleApi.fetchArticles(new DataListener&lt;List&lt;Article&gt;&gt;()&#123; @override public void onComplete(List&lt;Article&gt; result)&#123; mArticleView.showArticle(result); mArticleView.hideLoading(); mArticleModel.saveArticle(result); &#125; &#125;); &#125; //从缓存中获取数据 通过model来访问 通过view来显示 public void loadArticleFromDB()&#123; mArticleModel.loadArticlesFromCache(new DataListener&lt;List&lt;Article&gt;&gt;()&#123; @override public void onComplete(List&lt;Article&gt; result)&#123; mArticleView.showArticles(result); &#125; &#125;); &#125; //定义view接口 用于与presenter的交互public interface AricleViewInterface&#123; public void showArticle(List&lt;Article&gt; articles); public void showloading(); public void hideloading(); &#125;//定义model的实现类 存取数据用public class ArticleModelImpl implements ArticleModel&#123; List&lt;Article&gt; mCacheArticles = new LinkedList&lt;Article&gt;(); @override public void saveArticles(List&lt;Article&gt; articles)&#123; mCacheArticles.addAll(articles); &#125; @override public void loadArticlesFromCache(DataListener&lt;List&lt;Articles&gt;&gt; listener)&#123; listener.onComplete(mCacheArticles); &#125; &#125;@override public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity); initViews(); mPresenter = new ArticlePresenter(this); //业务逻辑已经交给presenter处理 mPresenter.fetchArticles(); &#125;//回调在presenter会用的三个方法 @override public void showArticles()&#123; ... &#125; @override public void showLoading()&#123; ... &#125; @override public void hideLoading()&#123; ... &#125;&#125; 就是使用这种结构做到业务逻辑与view分开 我在之前公司的开发经验中 遇到过一种mvc的写法 activity作为controller来处理业务逻辑 接口访问 数据存取会放在这里 而view得处理 会放到一个UI Block代码块里 例如点击事件啊 变化等都封装在block里 还有一个activity里有多少个block是不确定的要因情况而定 当遇到控件与控件间的交互时需要 用setter方法把view传递到block中 view和controller确实是分开了 但有个问题未解决 view可以直接访问model 用户可以直接向view发送指令 再由view直接要求model改变状态 相比mvp view不能直接访问model 要向presenter发出请求 view和model不直接通信 mvp框架有个问题需要被重视：presenter经常执行一些耗时操作 而presenter持有activity的强引用 如果在请求结束之前activity销毁了 那么由于网络请求还没有返回导致presenter一直持有activity对象 使得activity对象无法被回收 因此会导致内存泄漏 可以用弱引用和activity fragment的生命周期来解决这个问题 public abstract class BasePresenter&lt;V&gt;&#123; protected Reference&lt;V&gt; mViewRef; public void attachView(V view)&#123; //建立view和presenter的联系 代替了构造函数 mViewRef = new WeakReference&lt;V&gt;(view); &#125; protected T getView()&#123; return mViewRef.get(); &#125; public boolean isViewAttached()&#123; return mViewRef != null &amp;&amp; mViewRef.get() !=null; &#125; public void detachView()&#123; if(mViewRef !=null)&#123; mViewRef.clear(); mViewRef = null; &#125; &#125;&#125; public abstract class MVPBaseActivity&lt;V,T extends BasePresenter&lt;V&gt;&gt; extends Activity&#123; protected T mPresenter; @override protected void onCreate(Bundle saveInstanceState)&#123; super.onCreate(saveInstanceState); //创建presenter mPresenter = createPresenter(); mPresenter.attachView((V)this); &#125; @override protected void onDestory()&#123; super.onDestory(); mPresenter.detachView(); &#125; protected abstract T createPresenter();&#125; 这里可能有个疑问 既然有onDestory消除引用了 为什么还需要弱引用 因为activity销毁并不一定会被调用 一旦这种情况发生 弱引用能够保证不会造成内存泄漏 设计模式总结开章介绍了六大原则 其中记忆深刻的是单一职责原则 开闭原则 依赖倒置原则 设计模式 都是在这些原则上的延伸 然后单例模式是最常用的模式有多种 饿汉懒汉dcl 静态内部枚举容器 其中dcl和静态内部最推荐 builder模式用于不方便每次修改只适合初次定义对象的情况 原型模式的浅拷贝和深拷贝 为了数据的保护的拷贝 工厂模式又分简单工厂 工厂方法和抽象工厂 策略模式和状态模式相类似 当遇到if-else语句时就可以考虑用到 书里的责任链模式 解析器模式 命令模式直接被我略过了 我看过 在Android中的开发中适用性并不高 观察者模式就不同了 经常会见到所以详细探讨了 备忘录模式其实就是一个数据恢复的过程 迭代器模式花了一章节的时间来讲iterator 模板方法讲了baseActivity存在的意义 访问者模式不太好理解 其实他是把被访问对象的操作转移到访问者身上以此来避免污染访问者 否则要加if-else来判断不同的访问者操作 中介者模式是将多对对转变为一对多关系 经典例子是用主板组装电脑 代理模式是常见的模式 一般用组合来代替继承 组合模式描述树状结构的组成例如文件夹的组成 适配器模式分类适配器和对象适配器用于不匹配接口的中间层 装饰器模式与代理模式相类似但是强调扩展 享元模式将内部状态作为key 本身作为value 使用map缓存起来以减少内存的创建和销毁 外观模式就是为很多不同的接口提供一个门面 参看Imageloader 最后桥接模式是将某些功能的实现部分分离开来 再把它们包含进抽象类中 让功能部分和抽象类独立地进行变化 对书的评价总体上讲 如果评星星数 以10为满分的话 这本书可以评7星 以前看过headfirst的设计模式 他们用很生动的例子去讲解java的模式 而这本书的着重点在透过Android的源码（包括framework源码）和应用代码来讲解 对本身作为Android开发者的我来说更加适用 在我的阅读笔记中摘抄了大部分的书中的代码 是为了巩固记忆 有些不恰当的地方自己又加以修改 所以都是经过思考的 所谓取其精华去其糟粕嘛 书的结尾用mvp和mvc两个框架作为结尾 后面再无什么总结性的 感觉结尾是有点仓促不带总结 总觉得少了东西可以做得更好 这本书还是可以值得一读的！（个人不喜欢写标点符号 这里着重加了！） 接下来的计划准备进攻罗升阳的《Android系统源代码情景分析》 随便翻了下目录 发现需要做些知识储备 所以打算先用一个星期的时间 阅读下早已遗忘得差不多的c和c++","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"mvp","slug":"mvp","permalink":"http://luyaoming.com/tags/mvp/"},{"name":"总结","slug":"总结","permalink":"http://luyaoming.com/tags/总结/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（九）","date":"2016-05-16T05:32:26.000Z","path":"2016/05/16/Android源码设计模式解析与实践--读书笔记（九）/","text":"主要介绍装饰模式 桥接模式 享元模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 装饰模式装饰模式 可以透明地动态地扩展对象的功能 是继承关系的一种替代方案之一 他比生成子类更加灵活 //定义抽象的组件类public abstract class component&#123; public abstract void operate();&#125;//定义实现类 这是被装饰的最基础的组件 由这里开始扩展public class ConcreateComponent&#123; @override public void operate();&#125;//定义一个装饰器的抽象类 因为有可能有多个装饰者存在public abstract class Decorator extends Component&#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; @override public void operate()&#123; component.operate(); &#125; &#125;public class ConcreateDecoratorA extends Decorator&#123; public ConcreateDecoratorA(Component component)&#123; super(component); &#125; @override public void operate()&#123; operateA(); super.operate(); ...省略一些添加的代码 &#125; private void operateA()&#123; ... &#125;&#125;public class ConcreateDecoratorB extends Decorator&#123; public ConcreateDecoratorB(Component component)&#123; super(component); &#125; @override public void operate()&#123; super.operate(); operateB(); ...省略一些添加的代码 &#125; private void operateB()&#123; ... &#125;&#125;public class Test&#123; main()&#123; //创建一个被装饰者 Component component = new ConcreateComponment(); //创建装饰者A 给组件新增了operateA功能方法 Decorator da = new ConcreateDecoratorA(component); da.operate(); //创建装饰者B 给组件新增了operateB功能方法 Decorator db = new ConcreateDecoratorB(component); db.operate(); //在装饰者A的基础上再新增operateB的功能方法 Decorator db2 = new ConcreateDecoratorB(da); db2.operate(); &#125;&#125; 装饰模式与继承相比 有这么个优点 我想扩展某一个类让他拥有a功能 我要扩展同一个类拥有b功能 但是a b功能不能同时存在 所以我们不能先继承A 再继承B 这样拥有两个功能 再者 “拥有”这个词 应该是has a关系 而不是is a关系 所以用implement比extends贴切 装饰模式可以既实现两个功能ab分开 如上面代码的的da和db两个分开的装饰者 也可以同时存在如db2 因为他在a的基础上新增b 这些都得益于依赖倒置原则 装饰者构造方法接受的是一个abstract抽象类 装饰者拥有的成员变量是一个抽象类 他们的依赖关系是通过抽象来进行的 所以装饰B可以装饰A 因为A也是组件 所以我们可以很随意地叠加或者分开功能 装饰模式与代理模式有点相类似 他们都一样包含一个基础组件 然后都引用基础组件的方法 区别是代理模式更强调对原有对象的控制 装饰模式更强调对原有对象的扩展 装饰模式用在Android的recyclerView的扩展上 可参考Android 优雅的为RecyclerView添加HeaderView和FooterView 享元模式享元模式用来尽可能地减少内存的使用量 适用于创建大量重复的对象的场景 来缓存可以共享的对象 享元模式分外部状态和内部状态 内部状态是可以共享的 外部状态是不可以共享的 通常用map作为一个缓存池 key就是享元对象的内部状态 他的值就是享元对象本身 有这么一个场景 卖票系统可以提供查询车程从哪到哪 各种铺位的车票 加入有10000个人查询 那么是否需要10000个列表呢 答案是否定的 使用享元模式缓存这些列表 譬如 可以缓存从珠海到广州的车票列表 那么珠海到广州就构成了享元模式的内部状态 票价和铺位就是外部状态了 public interface Ticket&#123; public void showTicketInfo(String bunk);&#125;public class BusTicket&#123; public String from; public String to; public int price; public String bunk; public BusTicket(String from,String to)&#123; this.form = from; this.to = to; &#125; @override public void showTicketInfo(String bunk)&#123; ... &#125;&#125;public class TicketFactory&#123; static Map&lt;String,Ticket&gt; map = new HashMap&lt;String,Ticket&gt;(); public static Ticket getTicket(String from,String to)&#123; String key = from+\"-\"+to; if(map.contains(key))&#123; return map.get(key); &#125;else&#123; Ticket ticket = new BusTicket(from,to); map.put(key,ticket); return ticket; &#125; &#125;&#125; 在Android系统中 消息处理中的message 可以通过new Messsage() 也可以通过obtainMessage()方法来获取 其中obtainMessage()就是运用了享元模式 将message缓存到一个链表中 每次通过next来获取下一个message obtainMessage会取表头的message 链表中没有的时候再新建message 减少了内存的消耗和重复对象的gc 桥接模式定义：将抽象部分与实现部分分离 使他们都可以独立地进行变化 他的代码结构是这样的 public interface Implementor&#123; public void operationImpl();&#125;public class ConcreateImplementorA implements Implementor&#123; @override public void operationImpl()&#123; ... &#125;&#125;public class ConcreateImplementorB implements Implementor&#123; @override public void operationImpl()&#123; ... &#125;&#125;public abstract class Abstraction&#123; private Implementor mImplementor; public Abstraction(Implementor mImplementor)&#123; this.mImplementor = mImplementor; &#125; public void operation()&#123; mImplementor.operationImpl(); &#125; &#125;public class RefinedAbstraction extends Abstraction&#123; public RefinedAbstraction(Implementor mImplementor)&#123; super(mImplementor); &#125; public void refinedOperation()&#123; ... &#125;&#125; Implementor和Abstraction都属于抽象层 他们都有各自的扩展方向 但是他们之间又有联系 所以将他们连接的方式就是通过抽象层使用组合的方式联系在一起 这段话不太好了解 再举一个例子 public abstract class BaseProgressBar&#123; protected Paint mPaint; protected BaseProgressBar()&#123; mPaint = new Paint(); &#125; public abstract int getMesureHeight(); public abstract int getMesureWidth(); public abstract void draw(View v,Canvas c);&#125;public class HorizontalProgressBar extends BaseProgressBar&#123; @override public int getMeasureHeight()&#123; return 50; &#125; @override public int getMeasureWidth()&#123; return 1000; &#125; public void draw(View v,Canvas c)&#123; ... &#125;&#125; public class CircleProgressBar extends BaseProgressBar&#123; @override public int getMeasureHeight()&#123; return 70; &#125; @override public int getMeasureWidth()&#123; return 2000; &#125; public void draw(View v,Canvas c)&#123; ... &#125;&#125;public class ProgressBar extends View&#123; private BaseProgressBar mBaseProgressBar; private Context mContext; public ProgressBar(Context context)&#123; this(context,null); &#125; public ProgressBar(Context context,AttributeSet attrs)&#123; this(context,attrs,0); &#125; public ProgressBar(Context context,AttributeSet attrs,int defStyleAttr)&#123; super(context,attrs,defStyleAttr); ... if(style == HORIZONTAL)&#123; mBaseProgresBar = new HorizontalProgressBar(); &#125;else if(style == CIRCLE)&#123; mBaseProgress = new CircleProgressBar(); &#125; ... &#125; @override protected void onDraw(Canvas canvas)&#123; mBaseProgress.draw(this,canvas); &#125; &#125; ProgressBar持有BaseProgressBar类的引用 抽象和具体实现分开 ProgressBar其实可以为一个抽象的 只不过这里已经继承自view就没有在封装成抽象 不同类型的ProgressBar就是具体的实现 通过组合的方式加入​​","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"装饰模式","slug":"装饰模式","permalink":"http://luyaoming.com/tags/装饰模式/"},{"name":"桥接模式","slug":"桥接模式","permalink":"http://luyaoming.com/tags/桥接模式/"},{"name":"享元模式","slug":"享元模式","permalink":"http://luyaoming.com/tags/享元模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（八）","date":"2016-05-15T11:58:32.000Z","path":"2016/05/15/Android源码设计模式解析与实践--读书笔记（八）/","text":"主要介绍代理模式 组合模式 适配器模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 代理模式也称为委托模式 当无法或者不想直接访问某个对象时 或者访问某个对象存在困难时 通过一个代理对象来间接访问 为了保护客户端使用的透明性 委托对象和代理对象需要实现相同的接口 代理分静态代理和动态代理两种 静态代理是在代码运行之前 代理类的class编译文件在编译期的时候已经生成 而动态代理是 根据实际需要 使用到的时候再在运行时生成 先说一下静态代理 只要记住委托和被委托实现相同的接口 并且被委托类通过委托类来完成任务 具体的代码实现如下 public interface ISubject&#123; void doSomethingA(); void doSomethingB();&#125;public class RealSubject implements ISubject&#123; public void dosomethingA()&#123; ... &#125; public void dosomethingB()&#123; ... &#125; &#125;public class ProxySubject implements ISubject&#123; private RealSubject mSub; public ProxySubject(RealSubject sub)&#123; mSub = sub; &#125; public void dosomethingA()&#123; sub.dosomethingA(); //添加一些额外的代码之类的 也可以不加 ... &#125; public void dosomethingB()&#123; sub.dosomethingB(); //添加一些额外的代码之类的 也可以不加 ... &#125;&#125;public class Test&#123; main()&#123; ISubject sub = new ProxySubject(new RealSubject()); hello(sub); &#125; //此访问接受的是一个接口类型 说明他并不关心传递进来的是否是代理类 public static void hello(ISubject sub)&#123; sub.dosomethingA(); sub.dosomethingB(); &#125; &#125; 在使用代理类时 可以有不同的代理类来扩展不同的dosomething 一个被代理类可以对应多个代理类 代理类和被代理类实现相同的接口是为了告诉被代理类 你需要做的事情 我都可以为你做 然后 再说动态代理 java给我们提供了一个便捷的动态代理接口 InvocationHandler 实现这个接口需要重写invoke方法 public class DynamicProxy implements InvocationHandler&#123; //被代理的类引用 已经抽象成Object private Object obj; public DynamicProxy(Object o)&#123; this.obj = o; &#125; @override public Object invoke(Object proxy,Method method,Object[] args)&#123; Object reslut = method.invoke(obj,args); //添加一些额外的代码之类的 也可以不加 ... return reslut; &#125;&#125;public class Test&#123; main()&#123; ISubject rs = new RealSubject(); //DynamicProxy 在运行此构造之前 不知道代理的人是RealSubject 这就是与静态代理的区别 DynamicProxy proxy = new DynamicProxy(rs); ClassLoader loader = rs.getClass().getClassLoader(); ISubject proxySubject = Proxy.newProxyInstance(loader,new Class[]&#123;ISubject.class&#125;,proxy); proxySubject.dosomethingA(); proxySubject.dosomethingB(); &#125;&#125; 这个动态代理类 可以代理多个不同的被代理类 因为在实际需要运行时才构建这个代理类出来 而不是一开始就构建好 其实质是对代理者和被代理者的解耦 在Android源码中有很多使用代理模式的例子 例如ActivityManagerNative和ActivityManagerProxy 都实现了IActivityManager接口 ActivityManagerNative只是个抽象类没有太多逻辑 真正的被代理类是ActivityManagerNative的子类ActivityManagerService 这个service是系统级别的service并且运行于独立的进程空间里 这种情况下他是不方便访问的 所以就用到代理 ActivityManagerProxy正是在另一个线程空间操纵ActivityManagerService的行为 他们跨进程的通讯是通过binder来完成 再举一个例子 现在比较流行的网络通讯工具包retrofit 就是采用动态代理加观察者模式来实现的 //官网的例子代码 先定义一个构造url和参数的接口public interface GitHub &#123; @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\") Call&lt;List&lt;Contributor&gt;&gt; contributors(@Path(\"owner\") String owner,@Path(\"repo\") String repo);&#125;// Create an instance of our GitHub API interface.GitHub github = retrofit.create(GitHub.class);//这个create操作就是使用了动态代理 代码如下 /** Create an implementation of the API defined by the &#123;@code service&#125; interface. */@SuppressWarnings(\"unchecked\") // Single-interface proxy creation guarded by parameter safety.public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadMethodHandler(method).invoke(args); &#125; &#125;);&#125; 组合模式也称为整体部分模式 将一组相似的对象看作一组对象来处理 并根据一个树状结构来组合对象 比较经典的例子就是文件夹的形式 因为文件夹里面有文件夹 也有文件 要知道一共有多少文件 需要遍历这个文件树 需要用到递归 //定义一个抽象类 作为节点的抽象 他可以是根 分支 或者叶子public abstract class Dir&#123; protected List&lt;Dir&gt; dirs = new ArrayList&lt;Dir&gt;(); private String name; public Dir(String name)&#123; this.name = name; &#125; public abstract void addDir(Dir dir)； public abstract void rmDir(); public abstract void clear(); public abstract void print(); public abstract List&lt;Dir&gt; getFile(); public String getName();&#125;//定义一个文件夹类 属于根或者分支public class Folder extends Dir&#123; public Folder(String name)&#123; super(name); &#125; @override public void addDir(Dir dir)&#123; dirs.add(dir); &#125; @override public void rmDir(Dir dir)&#123; dirs.remove(dir); &#125; @override public void clear()&#123; dirs.clear(); &#125; @override public void print()&#123; system.out.print(\"(\"); Iterator&lt;Dir&gt; iter = dirs.iterator(); while(iter.hasNext())&#123; Dir dir = iter.next(); dir.print(); if(iter.hasNext())&#123; system.out.print(\",\"); &#125; &#125; System.out.print(\")\"); &#125; &#125;//定义叶子节点public class File extends Dir&#123; public File(String name)&#123; super(name); &#125; @override public void addDir(Dir dir)&#123; throw UnSupportOperationException(\"文件对象不支持该操作\"); &#125; @override public void rmDir(Dir dir)&#123; throw UnSupportOperationException(\"文件对象不支持该操作\"); &#125; @override public void clear()&#123; throw UnSupportOperationException(\"文件对象不支持该操作\"); &#125; @overide public void print()&#123; system.out.print(getName()); &#125; @override public void getFiles()&#123; throw UnSupportOperationException(\"文件对象不支持该操作\"); &#125; &#125;public class Test&#123; main()&#123; //构造根目录C盘 Dir diskC = new Folder(\"C\"); diskC.addDir(new File(\"img.txt\")); Dir dirwin = new Folder(\"windows\"); dirwin.addDir(new File(\"exploder.exe\")); dirC.addDir(dirwin); dirC.print(); &#125; &#125; 这种组合模式称为透明的组合模式 因为根节点与叶子节点具有相同的结构在叶子节点中 有些方法是没有必要实现的 就如上述的写成抛出异常的判断 目录与目录与文件之间是通过接口或抽象类的形式产生依赖的 符合依赖倒置原则 适配器模式适配器模式把一个类的接口变换成客户端所期待的另一种接口 从而使接口不匹配而无法在一起工作的两个类能够在一起工作 他的使用场景为 系统需要使用现在的类 而类的接口不兼容 想要建立一个想重复使用的类 用于与一些彼此之间没有太大关联的类 包括一些可能在将来引进的类一起工作 需要统一的输出接口 而输入端的类型不可预知 有类适配器与对象适配器两种 类适配器比较暴力 直接使用继承和实现吧两样不关联的东西强行扭在一起 例如 无论是手机还是平板电脑还是笔记本 都需要一个电源适配器 用于电压的转换 下面要讲220v的电压转为5v才能给设备使用 //这是目标接口 转为5v使用public interface FiveVolt()[ public int getVolt5(); ]public class Volt220()&#123; public int getVlot220()&#123; return 220; &#125;&#125;public class VoltAdapter extends Volt220 implements FiveVolt&#123; @override public int getVolt5()&#123; return 5; &#125;&#125; 上面的代码 相当于强制帮Volt220实现一个输出Volt5的接口 通过添加中间部件的方式 而这个中间部件 就称之为适配器 而往往现实中 适配器不应该是一个具体的某个事物（extends=“is a”关系）如上述代码 他不应该是一个电压 他原本属于一个变压器 他应该继承变压器的抽象类而不是具体的电压 但是java不允许多重继承 所以接下来用代理的方式 实现对象适配器 //这是目标接口 转为5v使用public interface FiveVolt()[ public int getVolt5(); ]public class Volt220()&#123; public int getVlot220()&#123; return 220; &#125;&#125;public class VoltAdapter extends implements FiveVolt&#123; Volt220 mVolt220; public VoltAdapter(Volt220 adatee)&#123; mVolt220 = adtee; &#125; public int getVolt220()&#123; return mVolt220.getVolt220(); &#125; public int getVolt5()&#123; return 5; &#125; &#125; 直接将被适配的对象包含在adapter中 使用组合的方式实现接口的兼容的效果 在Android中比较常见的适配器模式的使用场景 ：在listview和gridview的adapter中用到 他就是场景3的情况 统一的输出接口getView里输出一个view 输入类型不可预知 由用户来自定义 Recyclerview也一样 他的adapter统一输出目标是viewHoder不是view 不过他们使用适配器模式的原理也是一样的","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"代理模式","slug":"代理模式","permalink":"http://luyaoming.com/tags/代理模式/"},{"name":"组合模式","slug":"组合模式","permalink":"http://luyaoming.com/tags/组合模式/"},{"name":"适配器模式","slug":"适配器模式","permalink":"http://luyaoming.com/tags/适配器模式/"}]},{"title":"吉他练习视频-平凡之路","date":"2016-05-15T05:50:46.000Z","path":"2016/05/15/吉他练习视频-平凡之路/","text":"初学者水平 进步中 平凡之路 20150304换个浏览器吧亲 试试chrome Firefox safari 别再用落后的IE啦","categories":[{"name":"Music","slug":"Music","permalink":"http://luyaoming.com/categories/Music/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://luyaoming.com/tags/吉他/"},{"name":"视频","slug":"视频","permalink":"http://luyaoming.com/tags/视频/"}]},{"title":"吉他练习视频-真的爱你","date":"2016-05-15T05:48:42.000Z","path":"2016/05/15/吉他练习视频-真的爱你/","text":"喜欢beyond的歌 弹得一般般 观者莫见笑 真的爱你 20150124 换个浏览器吧亲 试试chrome Firefox safari 别再用落后的IE啦","categories":[{"name":"Music","slug":"Music","permalink":"http://luyaoming.com/categories/Music/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://luyaoming.com/tags/吉他/"},{"name":"视频","slug":"视频","permalink":"http://luyaoming.com/tags/视频/"}]},{"title":"吉他练习视频-我是真的受伤了","date":"2016-05-15T05:46:25.000Z","path":"2016/05/15/吉他练习视频-我是真的受伤了/","text":"这首歌张学友唱过 王菀之唱过 我唱过 哈哈😜 我是真的受伤了 20150121 换个浏览器吧亲 试试chrome Firefox safari 别再用落后的IE啦","categories":[{"name":"Music","slug":"Music","permalink":"http://luyaoming.com/categories/Music/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://luyaoming.com/tags/吉他/"},{"name":"视频","slug":"视频","permalink":"http://luyaoming.com/tags/视频/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（七）","date":"2016-05-14T08:31:04.000Z","path":"2016/05/14/Android源码设计模式解析与实践--读书笔记（七）/","text":"主要介绍访问者模式 中介者模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 访问者模式访问者模式是一种将数据操作与数据结构分离的模式 现实中使用率不高 他的使用场景在： 对象结构比较稳定 但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作 而需要避免这些操作‘污染’这些对象的类 也不希望在增加新操作是修改这些类 怎样理解操作与结构相分离呢 public class A&#123; public void doSomething()&#123; ... &#125; public accept(B b)&#123; b.visit(this); &#125;&#125;public class B&#123; public void visit(A a)&#123; a.doSomething(); &#125;&#125; 在上面的例子中 B就是一个访问者 一开始会觉得这个B很多余 因为到头来都是在调用A的doSomething()操作 跟B一点关系都没有 但是试想一下 如果对A新增不同的操作 势必会对A产生很多不同的方法 这样对A的操作与A本身的结构就会耦合在一起了 回想一下 在Android开发中 会见到很多叫dataHelper的类 他们的本质就是访问者 他们吧数据的操作封装在外面（helper）了 而数据本身的结构是不变的不轻易修改的 这样才符合单一职责原则 而今天所说的访问者模式 是上面的例子的拓展 一讲到拓展 就肯定与接口扯不开了 abstract class Element &#123; public abstract void accept(IVisitor visitor); public abstract void doSomething();&#125;interface IVisitor &#123; public void visit(ConcreteElement1 el1); public void visit(ConcreteElement2 el2);&#125;class ConcreteElement1 extends Element &#123; public void doSomething()&#123; System.out.println(\"1\"); &#125; public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125;class ConcreteElement2 extends Element &#123; public void doSomething()&#123; System.out.println(\"2\"); &#125; public void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125;class Visitor implements IVisitor &#123; public void visit(ConcreteElement1 el1) &#123; el1.doSomething(); &#125; public void visit(ConcreteElement2 el2) &#123; el2.doSomething(); &#125;&#125;class ObjectStruture &#123; public static List&lt;Element&gt; getList()&#123; List&lt;Element&gt; list = new ArrayList&lt;Element&gt;(); Random ran = new Random(); for(int i=0; i&lt;10; i++)&#123; int a = ran.nextInt(100); if(a&gt;50)&#123; list.add(new ConcreteElement1()); &#125;else&#123; list.add(new ConcreteElement2()); &#125; &#125; return list; &#125;&#125;public class Client &#123; public static void main(String[] args)&#123; List&lt;Element&gt; list = ObjectStruture.getList(); for(Element e: list)&#123; e.accept(new Visitor()); &#125; &#125;&#125; 新增了一个元素的抽象类 新增了一个访问者的接口 所谓的拓展 仅此而已 新增元素抽象类 是为了定义必须有的accept(Vistor v)方法来接收访问者 定义访问者接口是为了不需要为每一个vistor在元素类中创建一个accept方法 只需要新增不同的vistor即可（开放闭合原则 对修改关闭 对扩展开放） 访问者模式在Android的编译期注解所用到 编译期注解的核心是APT （annotation processing tools）就是在某些代码上添加注解 在编译时编译器会检查abstractProcessor的子类并且调用该类型的process函数 然后将添加了注解的所有元素都传递到process函数中 使得开发人员可以在编译期间进行相应的处理 例如根据注解生成java类 这也是butterknife的基本原理 对于编译器来说 代码中的元素结构是基本不变的 组成代码的基本元素包含包 类 函数 字段 类型参数 变量 那么可以采用访问者模式吧他们的操作放到外面 public interface Element&#123; ElementKind getkind(); Set&lt;Modifier&gt; getModifiers(); &lt;R,P&gt; R accept(ElementVistor&lt;R,P&gt; v,P p);&#125;public interface ElementVistor&lt;R,P&gt;&#123; R visit(Element e,P p); R visit(PackageElement e,P p); R visit(TypeElement e,P p); R visit(VariableElement e,P p); R visit(ExecutableElement e.P p);&#125; 具体的实现类没有在这里写了 自行脑补 中介者模式中介者模式中的中介者包装了一系列对象相互作用的方式 使得这些对象不必相互明显作用 从而使他们松耦合 这个模式使对象之间的多对多关系变成一对多关系 将网状解耦股改成星状结构 降低系统复杂度 提高扩展性 要理解这个模式并不难 例如想象一台电脑有很多不同的部件组成 有cpu 内存 显卡 io设备 他们之间是有联系的 例如从io设备读取用户的输入数据 把他们放到内存中 cpu对内存的数据进行处理 再经过显卡进行运算 最后通过io设备显示出来 如果每一个组件作为一个类 那么他们之间的联系在各自的组件中添加方法 想想都复杂 于是主板应运而生 他是为了解决连接他们之间的联系而存在 把他们的网状结构瓦解成星状结构 在Android开发中 activity就是中介者 在他那里处理组件之间的逻辑","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"访问者模式","slug":"访问者模式","permalink":"http://luyaoming.com/tags/访问者模式/"},{"name":"中介者模式","slug":"中介者模式","permalink":"http://luyaoming.com/tags/中介者模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（六）","date":"2016-05-08T08:41:02.000Z","path":"2016/05/08/Android源码设计模式解析与实践--读书笔记（六）/","text":"主要介绍观察者模式 模板模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 观察者模式这是一个使用率非常高的模式 常用在订阅-发布系统 他的主要作用就是解耦 对于Android而言 可以使得ui层与业务逻辑解耦 定义：他是一种一对多的依赖关系 当被观察的对象状态变化时 依赖他的观察者都会受到通知并自动更新 本身java的api已经自带了Observer和observable 接口 写一个简单的代码流程说下他的使用方式 用住户订阅报纸的方式来说明 public class TestNewsPaper &#123;public static void main(String args[])&#123; NewsPaperOffice newsPaperOffice = new NewsPaperOffice(); HouseHolder holderA = new HouseHolder(\"我是A\"); HouseHolder holderB = new HouseHolder(\"我是B\"); newsPaperOffice.addObserver(holderA); newsPaperOffice.addObserver(holderB); newsPaperOffice.postNewsPaper(\"这是今天的头条新闻\"); newsPaperOffice.deleteObserver(holderA); newsPaperOffice.postNewsPaper(\"这是第二天的头条新闻\");&#125;//报社public static class NewsPaperOffice extends Observable &#123; public void postNewsPaper(String newsContent)&#123; //要打开这个change开关 他才会更新 setChanged(); //内置的更新方法 notifyObservers(newsContent); &#125;&#125;//住户public static class HouseHolder implements Observer &#123; String name; public HouseHolder(String name) &#123; this.name = name; &#125; @Override public void update(Observable observable, Object data) &#123; String news = (String) data; System.out.println(name+\",我收到了：\"+news); &#125; &#125;&#125; java的观察者模式相当简单 里面自带了update方法 然而 只包含一个更新方法是不够的 例如用户不止是接收报纸内容 还会接受定期报社派送的礼物 这样一个update方法就不够用了 其实这些Observer和Observable都相当简单 可以自己写 或者采用Android自带的api 如果java项目里包含Android的api 直接运行是会报错的 所以这里我用一个activity包住 public class TestNewsPaper2Activity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); main(null); &#125; public interface IHouseHolder &#123; //获取报纸内容 void getNewsPaper(String content); //收取报社定期派送的赠品 void getPresents(String present); &#125; public static class HouseHolder2 implements IHouseHolder&#123; private String name; public HouseHolder2(String name)&#123; this.name = name; &#125; @Override public void getNewsPaper(String content) &#123; System.out.println(name+\",接受的报纸内容：\"+content); &#125; @Override public void getPresents(String present) &#123; System.out.println(name+\",接受的礼物名称：\"+present); &#125;&#125;//报社public static class NewsPaperOffice2 extends Observable&lt;IHouseHolder&gt; &#123; public void notifyGetNewPaper(String content)&#123; synchronized (mObservers)&#123; for(int i=mObservers.size()-1;i&gt;0;i--)&#123; mObservers.get(i).getNewsPaper(content); &#125; &#125; &#125; public void notifyGetPresent(String present)&#123; synchronized (mObservers)&#123; for(int i=mObservers.size()-1;i&gt;0;i--)&#123; mObservers.get(i).getPresents(present); &#125; &#125; &#125;&#125;public static void main(String args[])&#123; NewsPaperOffice2 newsPaperOffice2 = new NewsPaperOffice2(); HouseHolder2 a = new HouseHolder2(\"A\"); HouseHolder2 b = new HouseHolder2(\"B\"); newsPaperOffice2.registerObserver(a); newsPaperOffice2.registerObserver(b); newsPaperOffice2.notifyGetNewPaper(\"这是今天的内容2\"); newsPaperOffice2.notifyGetPresent(\"赠品乳酸奶\"); &#125;&#125; 在Android中使用观察者模式的额地方相当多 只要符合1对多关系 一处通知 全部更新的这样的场景 都可以用到 例如 listview的adapter recyclerview的recyclerViewAdapter 四大组件中的BroadcastReceiver 还有第三方组件 时间总线 EventBus 和 otto 和结合前两者优势的AndroidEventBus 看看他们的源码实现都是使用观察者模式 模板模式定义：定义一个操作的算法的框架 而将一些步骤或者具体的实现延迟到子类中 是的子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤 使用场景： 多个子类有公有的方法 重要 复杂的算法 可以把算法设计为模板方法 周边的相关细节由各个子类来实现 重构时 模板方法是一个经常使用的模式 把相同的代码抽取到父类中 然后通过钩子函数约束其行为 延续之前加载图片的算法 public interface Loader&#123; public void loadimg(BitmapRequest request);&#125;//这是个抽象类 定义了主要的算法框架来加载图片 而具体的实现细节由子类补充public abstract class AbsLoader implements Loader&#123; private static BitmapCache mCache = ...; //final方法 子类不能修改 @override public final void loadimg(BitmapRequest request)&#123; //先从缓存中获取图片 Bitmap resultBitmap = mCache.get(request); if(resultBitmap == null)&#123; //显示图片加载中 showLoading(); //加载图片 resultBitmap = onLoadImg(request); //缓存图片 cacheBitmap(request,resultBitmap); &#125;else&#123; request.justCacheInMem = true; &#125; // 将图片分发给调用端 deliveryToUIThread(request,resultBitmap); &#125; //定义一个抽象方法 子类需要实现 protected abstract Bitmap onLoadImg(BitmapRequest result);&#125;//子类1 加载网络图片的加载器public class UrlLoader extends AbsLoader&#123; @override public Bitmap onLoadImg(BitmapRequest result)&#123; //具体实现 ... &#125;&#125;//子类2 加载本地图片的加载器public class LocalLoader extends AbsLoader&#123; @override public Bitmap onLoadImg(BitmapRequest result)&#123; //具体实现 ... &#125;&#125; 模板模式可以概括为 流程封装 把固定的流程封装到final函数 让子类去实现定制某些步骤 父类提取公用的代码 提高了代码的复用率同时有更好的扩展性其实模板模式在我们Android总到处皆是 就从activity的启动生命周期来说 他的启动流程是固定的 从ActivityThread.main()到onCreate()到onStart()到onResume() 但是他的具体函数 可以留给我们去实现","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://luyaoming.com/tags/观察者模式/"},{"name":"模板模式","slug":"模板模式","permalink":"http://luyaoming.com/tags/模板模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（五）","date":"2016-05-02T13:56:48.000Z","path":"2016/05/02/Android源码设计模式解析与实践--读书笔记（五）/","text":"主要介绍策略模式和状态模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 策略模式定义：定义一系列的算法 并且将每一个算法都封装起来 而且使他们可以相互替代应用场景： 针对同一类型问题的多种处理方式 仅仅是具体行为有所差异 需要安全地封装多种同一类型的操作时 出现同一个抽象类有多个子类 而又需要使用if-else或者switch-case来选择具体子类时 下面用一个例子来说明这个模式 public class PriceCalculator&#123; private static final int BUS =1; private static final int SUBWAY = 2; public static void main(String[] args)&#123; PriceCalculator p = new PriceCalculator(); p.calculate(16,BUS); P.calculate(16,SUBWAY); &#125; private int busPrice(int km)&#123; ... &#125; private int subwayPrice(int km)&#123; ... &#125; int calculate(int km,int type)&#123; if(type == BUS)&#123; return busPrice(km); &#125;else if(type == SUBWAY)&#123; return subway(km); &#125; &#125;&#125; 上面的代码 首先 他不符合单一职责模式 第二个 每次新增计算方式 需要新增if-else 不符合开放闭合原则 下面来修改这些代码​public interface CalculatorStrategy&#123; int calculatePrice(int km);&#125; public class BusStratery implements CalculatorStrategy&#123; @override public int calculate(int km)&#123; ... &#125;&#125;public class SubwayStrategy implements CalculatorStrategy&#123;@override public int calculate(int km)&#123; ... &#125;&#125;public class TrafficCalculator&#123; main()&#123; TrafficCalculator traffic = new TrafficCalculator(); //直接创建对象的方式来分离开不同的策略 traffic.setStrategy(new SubwayStrategy(16)); traffic.calculatePrice(); &#125; CalculatorStrategy cal; //使用接口的方式传入参数 private void setStrategy(CalculatorStrategy c)&#123; this.cal = c; &#125; private int calculatePrice()&#123; return cal.calculate(); &#125; &#125; 策略模式在Android中也很常见 最简单的例子就是设置点击事件 onClickListener这个接口带有 onClick这个方法 不同的listener可以有不同的实现方式 new 不同的listener来对不同的监听器进行封装 然而我们喜欢写setOnclickListener(this)然后让Activity或者fragment来覆盖onClick这个方法 其实 Activity就是这个策略 只不过他里面有好多if-else 把一个策略当好几个策略来用 状态模式使用场景： 一个对象的行为取决于它的状态 并且必须在运行时根据状态改变它的行为 代码中有大量与对象状态有关的条件语句 例如 一个操作中含有庞大的多分支语句（使用if-else） 且这些分支依赖于该对象的状态 提到拆解if-else 应该都会想到上面提到的策略模式的用法 但是状态模式跟他的不同点在于他的行为是平行的不可替换的 而策略模式是彼此独立的可相互替换的 举一个常见的出现多if-else的例子 public class TvControler&#123; private static final int POWER_ON = 1; private static final int POWER_OFF = 2; private int state = POWER_OFF; public void powerOn()&#123; state = POWER_ON; if(state == POWER_OFF)&#123; sys.out.p(\"开机\"); &#125; &#125; public void powerOff()&#123; state = POWER_OFF; if(state == POWER_ON)&#123; sys.out.p(\"关机\"); &#125; &#125; public void nextChanel()&#123; if(state == POWER_ON)&#123; sys.out.p(\"下一频道\"); &#125;else&#123; sys.out.p(\"还没开机\"); &#125; &#125; public void prevChanel()&#123; if(state == POWER_ON)&#123; sys.out.p(\"上一频道\"); &#125;else&#123; sys.out.p(\"还没开机\"); &#125; &#125; public void turnUp()&#123; if(state == POWER_ON)&#123; sys.out.p(\"调高音量\"); &#125;else&#123; sys.out.p(\"还没开机\"); &#125; &#125; public void turnDown()&#123; if(state == POWER_ON)&#123; sys.out.p(\"调低音量\"); &#125;else&#123; sys.out.p(\"还没开机\"); &#125; &#125;&#125; 缺点好明显 加入新增其他状态 例如休眠状态 那么 就要在nextChanel prevChanel turnUp turnDown四个方法中新增判断条件 很麻烦 状态模式就是为了解决这个问题而存在的 先别看下面的代码 先想想要怎么重构 首先 把变化的部分抽象出来 nextChanel 这些方法属于变化的部分 因为他需要根据状态来改变写法 新建不同的状态 继承或实现抽象出来的变化 并且实现这些各自变化的部分 把这些状态引入到调用类中 只开放一个地方可以改变状态 并使用接口调用方法 看看具体实现的代码吧​//1 抽象变化的部分public interface TvState&#123; void nextChanel(); void prevChanel(); void turnOn(); void turnDown();&#125; //2 创建不同的状态public class PowerOffState implements TvState&#123; @override public void nextChanel()&#123; //未开机转不了台 什么都没做 &#125; @override public void prevChanel()&#123; //未开机转不了台 什么都没做 &#125; @override public void turnOn()&#123; //未开机调不了音量 什么都没做 &#125; @override public void turnDown()&#123; //未开机调不了音量 什么都没做 &#125; &#125;public class PowerOnState implements TvState&#123; @override public void nextChanel()&#123; system.out.print(\"下一频道\"); &#125; @override public void prevChanel()&#123; system.out.print(\"上一频道\"); &#125; @override public void turnOn()&#123; system.out.print(\"音量调高\"); &#125; @override public void turnDown()&#123; system.out.print(\"音量调低\"); &#125; public interface PowerControler&#123; public void powerOn(); public void powerOff();&#125; public class TVController implements PowerControler&#123; TvState currentState; public void setTvState(TvState state)&#123; currentState = state; &#125; @override public void powerOn()&#123; setTvstate(new PowerOnState()); sys.out.p(\"开机\"); &#125; @override public void powerOff()&#123; setTvstate(new PowerOffState()); sys.out.p(\"关机\"); &#125; //行为根据状态而改变 public void nextChanel()&#123; currentState.nextChanel(); &#125; public void prevChanel()&#123; currentState.prevChanel(); &#125; public void turnUp()&#123; currentState.turnUp(); &#125; public void turnDown()&#123; currentState.turnDown(); &#125;&#125; public class Test&#123; main()&#123; TvController c = new TvController(); c.powerOn(); c.nextChannel(); c.turnUp(); c.powerOff(); //关机后 在调高音量 调用关机状态的turnUp方法 c.turnUp(); &#125; &#125;//打印结果如下//开机//下一频道//调高音量//关机 重构的方式跟策略模式大同小异吗 没错 都是利用接口来解耦 所以面向接口编程 可以在很多模式都应用到 所以每次要重构那部分代码时 想想想怎么用接口把他们分离开来 是个好的思想开头 Android中也有地方可以用到状态模式 例如软件在登录前和登录后可以执行的操作 每加一个操作都要加一次if -else 来判断是否是登录用户 用状态模式就可以避免这个问题","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"策略模式","slug":"策略模式","permalink":"http://luyaoming.com/tags/策略模式/"},{"name":"状态模式","slug":"状态模式","permalink":"http://luyaoming.com/tags/状态模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（四）","date":"2016-05-02T10:18:24.000Z","path":"2016/05/02/Android源码设计模式解析与实践--读书笔记（四）/","text":"主要介绍三种工厂模式：抽象工厂 工厂方法 简单工厂 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 对于构建对象类型的模式 一般都用在创建复杂对象上 用new就可以完成创建的对象无需使用这些创建模式 简单工厂模式先看一下类图不愧为简单工厂 名副其实 相当简单 缺点是当每新建一个产品时 都需要修改SimpleFactory里的判断语句 根据传入的参数不同 生产不同的产品你见到的代码类似于 public class ConcreateFactory&#123;//构造函数...public Product create(String productType)&#123; if(\"a\".equals(productType))&#123; return new ProductA(); &#125;else if(\"b\".equals(productType))&#123; return new ProductB(); &#125;else if(\"新增产品\".equals(productType))&#123; return new ProductC(); &#125; &#125;&#125; 一个工厂就可以生产多种产品 这些产品应该属于同一系列（继承自同一抽象类或接口）其实这种模式并不符合我们面向对象六大模式中的开放闭合模式 因为他每次新增产品都需要修改工厂类 下面的工厂方法解决这个问题 工厂方法模式先看类图相比简单工厂 多了一个抽象的工厂类 当每新增一个产品时 对应的要新增一个具体的工厂来专门生产它 这样就可以避免每次新增产品时修改工厂类了（解决了上面简单工厂的问题） 然而 随着产品数的增加 工厂类也要增加 关系是一对一的 这种实现方法未免太low了 所以又有了新的方法解决这个问题 答案就是使用反射来作为输入参数决定生产那种产品 这样既可以做到不修改工厂类 也不需要每次新增产品类型时都新建工厂 具体代码如下 //定义一个抽象工厂类 让类型作为参数传入public abstract class Factory&#123; public abstract &lt;T extends Product&gt; T create(Class&lt;T&gt; clz);&#125;//具体的工厂类 感觉类名生产具体的产品public ConcreateFact extends Factory&#123; @override public &lt;T extends Product&gt; T create(Class&lt;T&gt; clz)&#123; Product p = null; try&#123; p = (Product)Class.forName(clz.getName()).getInstance(); &#125;catch (Exeception e)&#123; ... &#125; return p; &#125;&#125;//客户端public class Client&#123; main(...)&#123; Factory fact = new ConcreateFact(); //生产a Product a = fact.create(ProductA.class); //生产b Product b = fact.create(ProductB.class); &#125;&#125; 可以说这是种讨巧的方法 因为我需要在生产之前我已经明确生产什么产品 传入具体的类型 如果我知道产品的id号但不知道具体是哪个类（是哪个类需要根据id号逐个判断）这种方法就行不通了 这时就需要回归简单工厂方法了 或者不嫌麻烦 回归工厂方法的一对一模式了 抽象工厂模式他的定义是 为创建一组相关或者相互依赖的对象提供一个接口 而不需要指定他们具体的类（看定义似乎解决了上面工厂方法提到的问题）先上类图从图中可以看到 一个工厂可以创建不同的产品了（我说的不同 是指这些产品可以继承自不同的接口）主要分四个角色 抽象工厂 具体工厂 抽象产品 具体产品 使用抽象工厂让接口和实现做到真正的分离 客户端使用抽象工厂来创建需要的对象 而客户端不知道实现是谁 客户端只是面向了产品的接口编程 使其从具体的产品中解耦 缺点：很明显又是 在拓展的时候 不符合开放闭合原则 譬如新增产品类型ProductC 需要修改抽象工厂 并修改对应的具体工厂类","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"http://luyaoming.com/tags/抽象工厂模式/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"http://luyaoming.com/tags/工厂方法模式/"},{"name":"简单工厂模式","slug":"简单工厂模式","permalink":"http://luyaoming.com/tags/简单工厂模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（三）","date":"2016-05-02T01:25:49.000Z","path":"2016/05/02/Android源码设计模式解析与实践--读书笔记（三）/","text":"主要介绍建造者模式 原型模式 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii builder模式builder模式是我们平时比较多见的模式 下面是他的使用场景： 相同的方法 不同的执行顺序 产生不同的事件结果时 多个部件或零件 都可以装配到对象中 但是产生的运行结果又不相同 产品类非常复杂 或者产品类中的调用顺序不同产生了不同的作用 当初始化一个对象特别复杂 如参数多 且很多参数都具有默认值时 不想提供setter方法让用户随时改变里面的值 只想在初始化时让用户提供值 当成员变量比较多的时候 写构造函数是一件很痛苦的事 其实builder模式在我们Android的dialog中已经有体现 此次拓展由上一节读书笔记的例子 加载图片类 public final class ImageLoader&#123; //将builder构建单独起来 也可以作为内部类的形式嵌入 private ImageLoaderConfig mConfig; //单例模式构造函数 ... public void init(ImageLoaderConfig config)&#123; mConfig = config; checkConfig(); &#125; public void displayImage(...)&#123; Bitmap bitmap = mImageCache.get(imageUrl); if(bitmap != null)&#123; imageView.setImageBitmap(bitmap); return; &#125; //添加加载请求 submitLoaderRequest(imgUrl,imageView); &#125; private void submitLoaderRequest(...)&#123; ... &#125; private Bitmap downLoadImage()&#123; ... &#125;&#125; ​ //配置类 关键代码public class ImageLoaderConfig&#123; private BitmapCache bc; private DisplayConfig displayConfig; private LoadPolicy loadPolicy; private int threadCount; //私有化构造函数 防止外部new private ImageLoaderConfig()&#123;&#125; public static class Builder&#123; //图片缓存配置对象 给一个初始化的值 BitmapCache bc = new MemoryCache(); //加载图片时候的loading和加载失败的图片配置对象 DisplayConfig displayConfig = new DisplayConfig(); //加载策略 LoadPolicy loadPolicy = new SerialPolicy(); //线程数量 默认cpu数量+1 int threadCount = Runtime.getRuntime().availableProcessors()+1; //提供给客户端的公用方法 public Builder setThreadCount(int count)&#123; threadCount = Math.max(1,count); return this; &#125; public Builder setCache(BitmapCache cache)&#123; bitmapCache = cache; return this; &#125; public Builder setLoadingPlaceHolder(int resId)&#123; displayConfig.loadingResId = resId; return this; &#125; public Builder setNotFoundPlaceHolder(int resId)&#123; displayConfig.failedResId = resId; return this; &#125; public Builder setLoadPolicy(LoadPolicy policy)&#123; if(policy != null)&#123; loadPolicy = policy; &#125; return this; &#125; private void applyConfig()&#123; config.bitmapCache = this.bitmapCache; config.display = this.displayConfig; config.loadPolicy = this.loadPolicy; config.threadCount = this.threadCount; &#125; //根据设置好的属性创建配置对象 public ImageLoaderConfig create()&#123; ImageLoaderConfig config = new ImageLoaderConfig(); return applyConfig(config); &#125; &#125; &#125; //客户端测试类public class Test&#123; public static void main(...)&#123; ImageLoaderConfig c= new ImageLoaderConfig.Builder() .setLoadingPlaceHolder(R.drawable.loading) .setNotFoundPlaceHolder(R.drawable.not_found) .setCache(new DoubleCache(this)) .setTreadCount(4) .setLoadPolicy(new ReversePolicy()) .create(); ImageLoader.getInstance().init(c); &#125;&#125; 原型模式原型模式的本质是一个对象拷贝 他应用的场景如下： 类初始化需要消耗非常多的资源 这个资源包括数据 硬件资源等 通过原型拷贝避免这些消耗 通过new产生一个对象需要非常繁琐的数据准备或者访问权限 一个对象需要提供给其他对象访问 且各个调用者可能都需要修改其值时 可以考虑使用原型模式拷贝多个对象供调用者使用 就是保护性拷贝 拷贝分浅层拷贝和深层拷贝两种 下面先用代码说明这两者的区别 public class WordDoc implements Cloneable&#123; private String text; private ArrayList&lt;String&gt; image = new ArrayList&lt;String&gt;(); public WordDoc()&#123;&#125;; @override protect WordDoc clone()&#123; try&#123; WordDoc doc = (WordDoc)super.clone(); doc.text = this.text; //这里对image进行了深层拷贝 doc.image = (ArrayList&lt;String&gt;)super.image.clone(); return doc; &#125;catch(Exception e)&#123; ... &#125; return null; &#125;&#125; 上面的例子中 doc.image = (ArrayList&lt;String&gt;)super.image.clone();这句话就是对arraylist对象的拷贝 如果简单地写出doc.image = this.image就是浅层拷贝 当修改arrayList里面的值得时候 原来的arraylist也会被修改 因为浅层拷贝只传递了引用的地址 而深层拷贝是对引用类型进行一次完整拷贝 当修改arrayList里面的值得时候 原来的arraylist没有影响 所以浅层拷贝和深层拷贝的区别主要体现在对引用的处理上 有这么一个需求 假设一个对象的内容只允许客户端读取 而不允许修改 通常来说getter方法可以拿到该对象 只要get().list.add(1)就会轻松改掉list的原始集合 使用保护性拷贝可以防止这类事情发生 下面用代码说下保护性拷贝的意义 public class User implements Coloneable&#123; private int age; private String name; private String phone; private ArrayList&lt;String&gt; books; @override protect User clone()&#123; User user = null; try&#123; user = (User)super.clone(); user.age = this.age; user.name = this.name; user.phone = this.phone; user.books = (ArrayList&lt;String&gt;)super.clone(); return user; &#125;catche(e)&#123; ... &#125; return null; &#125;&#125;public interface Login&#123; void login();&#125;//客户端 记录userpublic class LoginImpl implements Login&#123; @override public void login()&#123; //初始化 User user = new User(); user.age = \"10\"; user.name = \"名字\"; user.phonw = \"1111111\"; user.books = new ArrayList&lt;String&gt;(); books.add(\"书名1\"); books.add(\"书名2\"); setLoginUser(user); &#125;&#125;public class LoginSession&#123; private User loginedUser; //单例模式构造函数 ... void setLoginUser(User user)&#123; loginedUser = user; &#125; public User getLoginUser()&#123; return loginedUser.clone(); &#125; &#125; 注意 在getLoginUser()方法中 返回的是一个克隆对象 而不是对象本身 用此方法或得到的对象这么修改也不会影响原来的user对象 这就是保护性拷贝 原型模式的优点： 是在内存中二进制流的拷贝 要比直接new一个对象性能好很多 缺点：直接在内存中拷贝 构造函数不会执行​​​","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"builder模式","slug":"builder模式","permalink":"http://luyaoming.com/tags/builder模式/"},{"name":"原型模式","slug":"原型模式","permalink":"http://luyaoming.com/tags/原型模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（二）","date":"2016-04-30T07:50:47.000Z","path":"2016/04/30/Android源码设计模式解析与实践--读书笔记（二）/","text":"主要介绍单例模式的几种用法 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 单例模式单例模式应该是们使用的第一个 而且是经常使用的模式 首先是 周所周知的饿汉模式和懒汉模式 //懒汉模式 public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125;//饿汉模式public class Singleton&#123; private static Singleton instance = new Single(); private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; retrun instance; &#125;&#125; 区分饿汉模式和懒汉模式 ：饿汉是一来什么都不说先new对象 很饥渴的样子 懒汉是一来我什么都不干 当需要调用到我的时候我再new对象 以前我容易把他两个搞混懒汉模式对比饿汉模式在一定程度上节约了资源 但是每次加载都需要进入同步锁 一样也会造成同步开销 所以还有个折中的方法是 Double check Lock （DCl） public class Singleton&#123; private static Singleton instance = null; private Single()&#123;&#125; public Static Singleton getInstance()&#123; if(instance == null)&#123; sychronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 有两次判空 第一次是为了避免不必要的同步 第二次为了确认是null的情况下创建实例。但是DCL在高并发的环境中还是有可能会失效的 原因要从instance = new Singleton()这行代码说起 这行代码可以分解成三个汇编命令： 给Singleton的实例分配内存 调用Singleton()的构造函数 初始化成员变量 将instance对象指向分配的内存空间（此时instance就不是null了） java编译器允许处理器乱序执行 也就是执行顺序可能是1-2-3 也可能是1-3-2 如果是1-3-2 譬如A线程在3执行完准备执行2 此时切换到B线程已经发现instance不为空 线程B将instance直接取走 在使用的时候由于该instance未执行过构造函数 （本例中构造函数里的内容为空 实际开发中构造函数会有些赋值之类的操作） 此时就会出错 在java1.5之后可以在定义instance时加volatile关键字来使DCl生效 也就是private volatile static Singleton instance =null 如果上述的单例模式写法还是不让你满意的话 you may try this //静态内部类单例模式public class Singleton&#123; private Singleton()&#123;&#125; private static Singleton getInstance&#123; return SingletonHolder.instance; &#125; private static class SingletonHolder&#123; private static final Singleton instance = new Instance(); &#125;&#125; 这种方式既能确保线程安全 也能保证实例对象的唯一性 同时也延迟了单例的实例化 这是最推荐的单例模式写法 说到 static final 你肯定还会想到enum 枚举 枚举的所有成员变量都是这种声明 public enum SingletonEnum&#123; INSTANCE; void doSomething()&#123; System.out.print(\"枚举单例模式\"); &#125; //构造函数(其实也可以不写) SingletonEnum()&#123; &#125; &#125; 单例模式还可以用容器的方式来实现 下面这种方法可以将多个单例注入到一个统一的管理类中 public class SingletonManager&#123; private static Map&lt;String,Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private SingletonManager()&#123;&#125;; public static void registerService(String key,Object instance)&#123; if(!objMap.containsKey(key))&#123; objMap.put(key,instance); &#125; &#125; public static Object getService(String key)&#123; return objMap.get(key); &#125;&#125; 在Android中的应用 例如Android源码中view从xml中创建 public final View createView(...)&#123;//从缓存中获取构造函数 Constructor&lt;? extends View&gt; construtor = sConstrutorMap.get(name); Class&lt;? extends View&gt; clazz = null; if(construtor == null)&#123; clazz = ... construtor = clazz.getConstrutor(...); //创建的构造函数放到缓存中以便下次直接读取 sConstrutorMap.put(name,construtor); ... //通过反射来构造view final View view = construtor.newInstance(); ... return view； &#125;&#125; 单例模式的好处就不说了 我来说他的缺点 单例模式一般没有接口实现 扩展起来很困难若要扩展 只能修改 单例对象如果持有Context 那么很容易发生内存泄漏 此时注意传递给单例对象的Context最好是Application Context","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"单例模式","slug":"单例模式","permalink":"http://luyaoming.com/tags/单例模式/"}]},{"title":"Android源码设计模式解析与实践--读书笔记（一）","date":"2016-04-29T13:24:00.000Z","path":"2016/04/29/Android源码设计模式解析与实践--读书笔记（一）/","text":"通过下面的伪代码 使用一半抄写的方式加深理解 将这些原则应用到自己的代码风格中 就是我写这篇博客的目的 Android源码设计模式解析与实践 原著：何红辉 关爱民 – –读书笔记 by asii 单一职责原则单一职责原则 Single Responsibility Principe 缩写SRP 。他的定义是：就一个类而言 应该仅有一个引起他变化的原因。简单来说 一个类应该是一组相关性很高的函数和数据的封装 下面用一个图片加载的例子来说明 使用伪代码的形式记录 public class ImageLoader&#123; //图片缓存 LruCache&lt;String,Bitmap&gt; mImageCache; //线程池 ExecutorService mExecutorService = ...; //构造函数 Public ImageLoader()&#123;&#125; private void initImageCache()&#123; mImageCache = new LruCache&lt;String,Bitmap&gt;()&#123;...&#125; ... &#125; public void displayImage()&#123; mExecutorService.submit(new Runnable()&#123; ... &#125;); &#125; public void downLoadImage()&#123;...&#125;&#125; 上面的代码分两个逻辑 一个定义ImageCache 一个下载和显示图片 考虑到他是一个ImageLoder顾名思义只是加载图片用的 故应该吧ImageCache分开来 分开的代码如下： public class ImageLoader&#123; //图片缓存（****只变化了这里***） ImageCache mImageCache; //线程池 ExecutorService mExecutorService = ...; //构造函数 Public ImageLoader()&#123;&#125; private void initImageCache()&#123; mImageCache = new LruCache&lt;String,Bitmap&gt;()&#123;...&#125; ... &#125; public void displayImage()&#123; mExecutorService.submit(new Runnable()&#123; ... &#125;); &#125; public void downLoadImage()&#123;...&#125;&#125; //定义一个ImageCache类public class ImageCache&#123; LruCache&lt;String,Bitmap&gt; mImageCache; //构造函数 public ImageCache()&#123;&#125; private void initImageCache（）&#123; ... &#125; //set方法 //get方法&#125; 开闭原则开闭原则 英文open close principle 缩写ocp 他的定义是：软件中的对象（类 模块 函数等）应该对于扩展是开放的，但是对于修改是封闭的 继续上面的例子来说说明这个原则 例如 我要多一种缓存方式 本地缓存来处理图片 public DiskCache&#123; public String cacheDir=\"...”； //get方法 //set方法&#125;public class ImageLoader&#123; //内存缓存 ImageCache mImageCache; //sd卡缓存 DiskCache mDiskCache; ... //是否使用sdcard缓存 private boolean isUseDiskCache; public void useDiskCache(boolean useDiskCache)&#123; isUseDiskCache = ... &#125; public void displayImage()&#123; Bitmap b; if(isUseDiskCache)&#123; b = mDiskCache.get(...) ... &#125;else&#123; b = mImageCache.get(...) ... &#125; &#125;&#125; 如果我要再加一种缓存方式 例如双缓存DoubleCache 那么就需要修改ImageLoader 在里面新增一个DoubleCache 然后在displayImage在再加一个if判断在操作 再往后想 如果将来每次新增cache类型 都需要修改ImageLoader类 就是一个糟糕的设计了 所以here 用到了ocp 观察上面代码 发现缓存的实现无非get和set 所以可以把这里变化的代码抽象起来then show you the code //定义一个接口来抽象缓存和读取图片这个行为public Interface ICacheImage&#123; public Bitmap get(String url); public void set(String url,Bitmap b);&#125;public ImageCache implement ICacheImage&#123; get()... set()...&#125;public DiskCache implement ICacheImage&#123; get()... set()...&#125;public DoubleCache implement ICacheImage&#123; get()... set()...&#125;public class ImageLoader&#123; // 用接口的形式定义一个缓存方式 这个缓存方式可以通过下面的set方法来接收 ICacheImage mImageCache = ... public void setImageCache(ICacheImage cacheType)&#123; ... &#125; public void displayImage()&#123; mImageCache.get()... ... &#125;&#125;//使用这个ImageLoaderpublic Test&#123; main(...)&#123; ImageLoader imageLoader = new ... //使用内存缓存 imageLoader.setImageCache(new ImageCache()); //使用sd卡缓存 imageLoader.setImageCache(new DiskCache()); //使用双缓存 imageLoader.setImageCache(new DoubleCache()); //使用自定义的缓存方式 imageLoader.setImageCache(new ICacheImage)&#123; @override get()&#123; ... &#125; @override set()&#123; ... &#125; &#125;; &#125;&#125; ​ 依赖倒置原则依赖倒置原则 英文 dependence inversion principle 缩写dip他在java语言中表现是 模块间的依赖通过抽象发生 实现类之间不发生直接的依赖关系 起依赖关系是通过接口和抽象类产生。高层次的模块不依赖于低层次的模块 高层模块就是调用端 低层模块就是具体实现类 从之前的例子来解释这个原则ImageLoader的第一个成员变量被定义为接口而不是具体的实现类 就是通过抽象将高层和低层隔离开了 里氏替换原则liskov substitution principle 缩写lsp 所有引用基类的地方必须能透明地使用其他子类 public class Window&#123; public void show(View child)&#123; child.draw(); &#125;&#125;Public abstract Class View&#123; public abstract void draw(); public void measure(width ,height)&#123;...&#125;&#125;public class Button extends View&#123; draw()&#123; ... &#125;&#125;public class TextView extends View&#123; draw()&#123; ... &#125;&#125; window依赖于view 而view定义了一个视图抽象 measure是各个子类共享的方法 子类通过覆盖view的draw方法实现各自的特色 任何继承自view类的子类都可以设置给show方法 就是所说的里氏替换原则 接口隔离原则interfaceSegregation principle 缩写isp 类间的依赖关系应该建立在最小的接口上。接口隔离原则将庞大臃肿的接口拆分成更小更具体的接口 客户只需要知道感兴趣的方法 先看一个例子​public void set()&#123; FileOutputStream fos = null; try&#123; fos = new ... ... &#125;catch(FilenotFoundException e)&#123; e.printStackTrace(); &#125;finally&#123; if(fos != null)&#123; try&#123; fos.close(); &#125;catch(IOException e)&#123; ... &#125; &#125; &#125;&#125; 这段代码里try套try 看着很烦 那么可以吧finally里面这段抽出来 由于任何可关闭的流都调用close这个方法 变化的部分就是这个关闭动作 所以可以把它抽象出来 有个Closeable接口就是专门定义这个方法的 使用isp原则 见下面代码 public final class CloseUtil()&#123; public static void close(Closeable c)&#123; if( c != null)&#123; try&#123; c.close(); &#125;catch(IOException e)&#123; ... &#125; &#125; &#125;&#125;public void set()&#123; FileOutputStream fos = null; try&#123; fos = new ... ... &#125;catch(FilenotFoundException e)&#123; e.printStackTrace(); &#125;finally&#123; CloseUtil.close(fos); &#125;&#125; 这个closeUtil可以使用到任何一个可关闭的对象中 保证了代码的重用性 最少知识原则英文law of demeter 缩写lod 定义 一个对象应该对其他对象有最少的了解 例如 举例子 通过租客向中介租房 //房间public class Room&#123; private float area; priavte float price; ...&#125;//中介public class Mediator&#123; public List&lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); public Mediator()&#123; for()&#123; mRooms.add(new Room(...)); &#125; &#125; &#125;//租客public class Tenant&#123; //租客心中的平方 价格 public float myArea; public fioat myPrice; public void rentRoom(Mediator m)&#123; for(Room room: m.mRooms)&#123; if(isSuitable(room))&#123; .... &#125; &#125; &#125; private boolean isSuitable()&#123; //比较room的价钱 平方与 租客心中的价钱平方 ... &#125; &#125; 可以看到租客自己对房间的价格平方遍历中介的房间进行比较 而中介只做了一个提供房间的角色而已 一个好中介 应该自动帮租客筛选房间 而不是租客自己来筛选 租客只需要提供自己心中的平方与价钱 其他不需要关心 就可以得到想要的房子 这就是最少知识原则 具体实现如下 //中介public class Mediator&#123; public List&lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); public Mediator()&#123; for()&#123; mRooms.add(new Room(...)); &#125; &#125; public Room rentout(float tenantArea,float tenantPrice)&#123; for(Room room:mRooms)&#123; if(isSuitable(tenantArea,tenantPrice,room))&#123; return room; &#125; &#125; &#125; private boolean isSuitable(float area,float price,Room m)&#123; return ...; &#125; &#125;//租客public class Tenant&#123; //租客心中的平方 价格 public float myArea; public fioat myPrice; public void rentRoom(Mediator mediator)&#123; Room myRoom = mediator.rentOut(myArea,myPrice); ... &#125;&#125;","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://luyaoming.com/categories/Design-Patterns/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://luyaoming.com/tags/Android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://luyaoming.com/tags/读书笔记/"},{"name":"面向对象的六大原则","slug":"面向对象的六大原则","permalink":"http://luyaoming.com/tags/面向对象的六大原则/"}]},{"title":"hello asii 使用github pages+hexo 搭建的第一个博客","date":"2016-04-24T07:55:22.000Z","path":"2016/04/24/hello-asii/","text":"2016年4月28日22:45 更新 今天中午还在埋怨怎么dnspod的域名解析这么久 要等3天 其实是自己懵逼了 是自己没有在dnspod填写正确的ip地址导致的 之前看着教程一步一步做 有一步做错了 没发现到 幸好自己反省后重新发现到问题 解决法案（2步） 打开终端 输入ping asi2012asi.github.io（自己的github repo地址） 复制获取到的ip地址 打开dnspod 新增两个记录 主机记录分别填@和www 记录类型都填A 线路默认 记录值填刚刚我ping的地址 保存后就ok了 那个CMADE 加不加无所谓 访问域名都能出来 见下图的第一条和第四条的记录 （第一次传图 没控制好大小） 使用dnspod来解析域名 都等了2天多了 域名还是ping不通 今天问过客服 说要等够72小时 天呐 今晚再检查了各个绑定域名的步骤有没有弄错 希望明天可以弄好","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://luyaoming.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://luyaoming.com/tags/hexo/"}]},{"title":"Hello World","date":"1970-01-01T00:00:00.000Z","path":"1970/01/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 修改了这里啦啦啦 Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://luyaoming.com/categories/Hexo/"}],"tags":[]}]